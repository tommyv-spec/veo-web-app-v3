<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Veo 3.1 Video Generator</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <link rel="apple-touch-icon" href="/static/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0F172A;
            --bg-surface: #1E293B;
            --bg-elevated: #334155;
            --bg-input: #0F172A;
            --border-color: #334155;
            --border-subtle: #475569;
            --accent: #6366F1;
            --accent2: #8B5CF6;
            --accent-glow: rgba(99, 102, 241, 0.3);
            --text-primary: #F8FAFC;
            --text-secondary: #94A3B8;
            --text-muted: #64748B;
            --success: #10B981;
            --warning: #F59E0B;
            --error: #EF4444;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; line-height: 1.5; }
        
        .app-container { min-height: 100vh; display: flex; flex-direction: column; transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1); }
        .app-container.state-initial .main-content { display: flex; justify-content: center; align-items: flex-start; padding: 40px 24px; flex: 1; }
        .app-container.state-initial .config-panel { width: 90%; max-width: 1400px; animation: fadeInUp 0.5s ease-out; }
        .app-container.state-initial .results-panel { display: none; }
        .app-container.state-active .main-content { display: grid; grid-template-columns: 480px 1fr; gap: 0; flex: 1; }
        .app-container.state-active .config-panel { border-right: 1px solid var(--border-color); padding: 24px; height: calc(100vh - 64px); overflow-y: auto; animation: slideInLeft 0.6s ease-out; }
        .app-container.state-active .results-panel { display: block; padding: 24px; height: calc(100vh - 64px); overflow-y: auto; animation: fadeIn 0.8s ease-out 0.2s both; }
        @media (max-width: 900px) {
            .app-container.state-active .main-content { grid-template-columns: 1fr; }
            .app-container.state-active .config-panel { height: auto; border-right: none; border-bottom: 1px solid var(--border-color); }
            .app-container.state-active .results-panel { height: auto; }
        }
        
        /* Vertical stack layout for config-panel */
        .config-panel { display: flex; flex-direction: column; gap: 16px; }
        
        /* Simple mode (1 image): Images → Settings → Dialogue */
        .config-panel #simpleImagesCard { order: 1; }
        .config-panel #settingsCard { order: 2; }
        .config-panel #simpleDialogueSection { order: 3; }
        .config-panel #storyboardContainer { order: 4; }
        .config-panel #customPromptSection { order: 5; }
        .config-panel .generate-container { order: 6; }
        .config-panel #jobsCard { order: 7; }
        
        /* Storyboard mode (2+ images): Settings → Script Editor */
        .config-panel.storyboard-active #settingsCard { order: 1; }
        .config-panel.storyboard-active #storyboardContainer { order: 2; }
        .config-panel.storyboard-active #simpleImagesCard { order: 10; }
        .config-panel.storyboard-active #simpleDialogueSection { order: 10; }
        .config-panel.storyboard-active #customPromptSection { order: 3; }
        .config-panel.storyboard-active .generate-container { order: 4; }
        .config-panel.storyboard-active #jobsCard { order: 5; }
        
        .header { background: var(--bg-surface); border-bottom: 1px solid var(--border-color); padding: 16px 24px; display: flex; align-items: center; justify-content: space-between; height: 64px; position: relative; z-index: 9500; }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon { width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent), var(--accent2)); border-radius: var(--radius-md); display: flex; align-items: center; justify-content: center; font-size: 20px; box-shadow: 0 4px 12px var(--accent-glow); }
        .logo h1 { font-size: 18px; font-weight: 600; }
        .header-actions { display: flex; gap: 12px; align-items: center; }
        .btn-new-job { display: none; }
        .state-active .btn-new-job { display: inline-flex; }
        
        /* User menu styles */
        .user-menu { position: relative; }
        .user-btn { display: flex; align-items: center; gap: 8px; padding: 6px 12px; background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: var(--radius-md); cursor: pointer; color: var(--text-primary); font-size: 14px; transition: all 0.2s; }
        .user-btn:hover { background: var(--bg-input); border-color: var(--border-subtle); }
        .user-avatar { width: 28px; height: 28px; border-radius: 50%; background: linear-gradient(135deg, var(--accent), var(--accent2)); display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 600; overflow: hidden; }
        .user-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .user-name { max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .user-dropdown { position: absolute; top: 100%; right: 0; margin-top: 8px; background: var(--bg-surface); border: 1px solid var(--border-color); border-radius: var(--radius-md); min-width: 200px; box-shadow: 0 8px 24px rgba(0,0,0,0.3); display: none; z-index: 10000; }
        .user-dropdown.show { display: block; }
        .user-dropdown-header { padding: 12px 16px; border-bottom: 1px solid var(--border-color); }
        .user-dropdown-email { font-size: 12px; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; }
        .user-dropdown-item { padding: 10px 16px; display: flex; align-items: center; gap: 8px; cursor: pointer; color: var(--text-secondary); font-size: 14px; transition: all 0.2s; }
        .user-dropdown-item:hover { background: var(--bg-elevated); color: var(--text-primary); }
        .user-dropdown-item.logout { color: var(--error); }
        .user-dropdown-item.logout:hover { background: rgba(239, 68, 68, 0.1); }
        
        /* API Keys Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 10000; padding: 20px; box-sizing: border-box; }
        .modal-overlay.show { display: flex; }
        .modal { background: var(--bg-surface); border: 1px solid var(--border-subtle); border-radius: 16px; width: 100%; max-width: 480px; max-height: calc(100vh - 40px); overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); margin: auto; }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; background: var(--bg-elevated); }
        .modal-header h2 { font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 10px; margin: 0; }
        .modal-close { background: var(--bg-input); border: none; color: var(--text-muted); width: 32px; height: 32px; border-radius: 8px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .modal-close:hover { background: var(--error); color: white; }
        .modal-body { padding: 24px; overflow-y: auto; flex: 1; }
        .modal-footer { padding: 16px 24px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 12px; background: var(--bg-elevated); }
        
        /* API Keys List */
        .api-keys-info { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1)); padding: 14px 18px; border-radius: 12px; margin-bottom: 20px; font-size: 13px; color: var(--text-secondary); border: 1px solid rgba(99, 102, 241, 0.2); }
        .api-keys-info strong { color: var(--text-primary); display: block; margin-bottom: 6px; }
        .api-keys-info a { color: var(--accent); text-decoration: none; font-weight: 500; }
        .api-keys-info a:hover { text-decoration: underline; }
        .api-keys-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 24px; min-height: 60px; }
        .api-key-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; background: var(--bg-elevated); border-radius: 12px; border: 1px solid var(--border-color); transition: all 0.2s; }
        .api-key-item:hover { border-color: var(--accent); }
        .api-key-item.invalid { border-color: var(--error); background: rgba(239, 68, 68, 0.05); }
        .api-key-item.inactive { opacity: 0.5; }
        .api-key-info { display: flex; flex-direction: column; gap: 4px; }
        .api-key-name { font-weight: 600; font-size: 14px; color: var(--text-primary); }
        .api-key-suffix { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--text-muted); }
        .api-key-status { font-size: 11px; font-weight: 500; }
        .api-key-status.valid { color: var(--success); }
        .api-key-status.invalid { color: var(--error); }
        .api-key-actions { display: flex; gap: 6px; }
        .api-key-actions button { background: var(--bg-input); border: none; color: var(--text-muted); cursor: pointer; padding: 6px 10px; border-radius: 8px; font-size: 14px; transition: all 0.2s; }
        .api-key-actions button:hover { background: var(--accent); color: white; }
        .api-key-actions button.delete:hover { background: var(--error); color: white; }
        
        /* Key Status Indicators */
        .api-key-item.status-working { border-left: 3px solid var(--success); }
        .api-key-item.status-rate_limited { border-left: 3px solid #f59e0b; }
        .api-key-item.status-invalid { border-left: 3px solid var(--error); background: rgba(239, 68, 68, 0.05); }
        .api-key-item.status-unknown { border-left: 3px solid var(--text-muted); }
        .api-key-status.status-working { color: var(--success); }
        .api-key-status.status-rate_limited { color: #f59e0b; }
        .api-key-status.status-invalid { color: var(--error); }
        .api-key-status.status-unknown { color: var(--text-muted); }
        
        /* Keys Summary */
        .keys-summary { display: flex; gap: 12px; margin-bottom: 8px; }
        .keys-summary-item { flex: 1; padding: 12px 16px; border-radius: 10px; text-align: center; }
        .keys-summary-item .count { font-size: 24px; font-weight: 700; display: block; }
        .keys-summary-item .label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.8; }
        .keys-summary-item.working { background: rgba(16, 185, 129, 0.15); color: var(--success); }
        .keys-summary-item.rate-limited { background: rgba(245, 158, 11, 0.15); color: #f59e0b; }
        .keys-summary-item.invalid { background: rgba(239, 68, 68, 0.15); color: var(--error); }
        #apiKeysSummary { margin-bottom: 20px; }
        
        /* Add Keys Form */
        .add-key-section { border-top: 1px solid var(--border-color); padding-top: 20px; margin-top: 4px; }
        .add-key-section h4 { font-size: 13px; font-weight: 600; margin-bottom: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; }
        .add-key-input { display: flex; gap: 10px; margin-bottom: 16px; }
        .add-key-input input { flex: 1; padding: 12px 16px; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 10px; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 13px; transition: border-color 0.2s; }
        .add-key-input input:focus { outline: none; border-color: var(--accent); }
        .add-key-input input::placeholder { color: var(--text-muted); }
        .bulk-add-section { margin-top: 20px; }
        .bulk-add-section textarea { width: 100%; height: 100px; padding: 12px 16px; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 10px; color: var(--text-primary); font-family: 'JetBrains Mono', monospace; font-size: 12px; resize: vertical; transition: border-color 0.2s; }
        .bulk-add-section textarea:focus { outline: none; border-color: var(--accent); }
        .bulk-add-section textarea::placeholder { color: var(--text-muted); }
        .bulk-add-hint { font-size: 11px; color: var(--text-muted); margin-top: 8px; }
        .empty-keys { text-align: center; padding: 40px 20px; color: var(--text-muted); background: var(--bg-elevated); border-radius: 12px; border: 2px dashed var(--border-color); }
        .empty-keys .icon { font-size: 48px; margin-bottom: 12px; opacity: 0.5; }
        
        .card { background: var(--bg-surface); border: 1px solid var(--border-color); border-radius: var(--radius-lg); padding: 20px; margin-bottom: 0; }
        .card-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; color: var(--text-muted); margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
        
        /* Settings card - clean single row layout */
        /* ===== Settings Card - Clean Form Layout ===== */
        #settingsCard .config-grid { display: flex; flex-direction: column; gap: 20px; }
        #settingsCard .config-grid .group { display: flex; flex-direction: column; gap: 8px; }
        #settingsCard .config-grid .lbl { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.6px; color: var(--text-muted); margin: 0; display: block; }
        #settingsCard .config-grid .lbl .info-icon { margin-left: 4px; }
        
        /* Segmented control */
        #settingsCard .seg {
            display: flex; border-radius: var(--radius-sm); overflow: hidden;
            border: 1px solid var(--border-color); background: var(--bg-input);
        }
        #settingsCard .seg button {
            flex: 1; padding: 10px 0; font-size: 12px; font-weight: 500;
            background: transparent; border: none; color: var(--text-muted);
            cursor: pointer; transition: all 0.15s; text-align: center;
        }
        #settingsCard .seg button.active { background: var(--accent); color: white; font-weight: 600; }
        #settingsCard .seg button:hover:not(.active) { background: rgba(255,255,255,0.03); color: var(--text-secondary); }
        #settingsCard .seg button + button { border-left: 1px solid var(--border-color); }
        #settingsCard .seg button.active + button,
        #settingsCard .seg button + button.active { border-left-color: transparent; }
        #flowVariantsSeg { flex: none; }
        #flowVariantsSeg button { flex: none; padding: 8px 14px; min-width: 38px; font-size: 13px; }
        
        /* 2-col and 3-col grids */
        #settingsCard .cols-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        #settingsCard .cols-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
        
        #settingsCard #contextSection textarea { min-height: 50px; }
        
        /* Hints */
        #settingsCard .backend-hint { display: none; padding: 12px 16px; border-radius: var(--radius-sm); font-size: 12px; line-height: 1.6; }
        #settingsCard .backend-hint.flow-hint { background: rgba(99,102,241,0.06); border: 1px solid rgba(99,102,241,0.12); color: var(--text-secondary); }
        #settingsCard .backend-hint.api-hint { background: rgba(16,185,129,0.06); border: 1px solid rgba(16,185,129,0.12); color: var(--text-secondary); }
        
        @media (max-width: 500px) {
            #settingsCard .cols-2 { grid-template-columns: 1fr; }
            #settingsCard .cols-3 { grid-template-columns: 1fr; }
        }
        
        .config-grid { display: flex; flex-direction: column; gap: 16px; }
        .config-box { background: var(--bg-elevated); border-radius: var(--radius-md); padding: 14px; }
        .config-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        @media (max-width: 500px) { .config-row { grid-template-columns: 1fr; } }
        
        label { display: flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 500; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
        input, select, textarea { width: 100%; padding: 10px 14px; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: var(--radius-sm); color: var(--text-primary); font-family: inherit; font-size: 13px; transition: all 0.2s ease; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); }
        textarea { font-family: 'JetBrains Mono', monospace; font-size: 12px; min-height: 140px; resize: vertical; line-height: 1.6; }
        select { cursor: pointer; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394A3B8' d='M6 8L2 4h8z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px; }
        
        .section-step { display: inline-flex; align-items: center; justify-content: center; width: 22px; height: 22px; background: linear-gradient(135deg, var(--accent), var(--accent2)); color: white; border-radius: 50%; font-size: 11px; font-weight: 600; flex-shrink: 0; }
        
        .info-icon { display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; background: var(--bg-input); color: var(--text-muted); border-radius: 50%; font-size: 10px; cursor: help; position: relative; transition: all 0.2s; border: 1px solid var(--border-color); }
        .info-icon:hover { background: var(--accent); color: white; border-color: var(--accent); }
        .info-icon .tooltip { display: none; position: fixed; background: var(--bg-surface); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: 14px 16px; width: 300px; max-width: calc(100vw - 32px); max-height: calc(100vh - 32px); overflow-y: auto; z-index: 1000; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4); text-transform: none; letter-spacing: normal; }
        .info-icon:hover .tooltip { display: block; }
        .info-icon .tooltip h5 { font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; }
        .info-icon .tooltip p { font-size: 11px; color: var(--text-secondary); line-height: 1.5; margin: 0 0 8px 0; }
        .info-icon .tooltip p:last-child { margin-bottom: 0; }
        .info-icon .tooltip ul { font-size: 11px; color: var(--text-secondary); line-height: 1.5; margin: 8px 0; padding-left: 16px; }
        .info-icon .tooltip li { margin-bottom: 4px; }
        .info-icon .tooltip table { width: 100%; margin-top: 10px; font-size: 10px; border-collapse: collapse; }
        .info-icon .tooltip td { padding: 6px 8px; border: 1px solid var(--border-color); color: var(--text-secondary); }
        .info-icon .tooltip td:first-child { font-weight: 500; background: var(--bg-elevated); color: var(--text-primary); }
        
        .upload-area { border: 2px dashed var(--border-color); border-radius: var(--radius-md); padding: 20px 16px; text-align: center; cursor: pointer; transition: all 0.2s ease; background: var(--bg-input); position: relative; }
        .upload-area:hover { border-color: var(--accent); background: rgba(99, 102, 241, 0.05); }
        .upload-area.uploading { pointer-events: none; border-color: var(--accent); }
        .upload-area .upload-icon { font-size: 28px; margin-bottom: 6px; }
        .upload-area p { font-size: 12px; color: var(--text-secondary); margin-bottom: 2px; }
        .upload-area span { font-size: 10px; color: var(--text-muted); }
        
        /* Upload loading animation */
        .upload-loading { display: none; flex-direction: column; align-items: center; gap: 12px; padding: 10px 0; }
        .upload-area.uploading .upload-loading { display: flex; }
        .upload-area.uploading .upload-content { display: none; }
        .upload-spinner { width: 32px; height: 32px; border: 3px solid var(--border-color); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .upload-loading-text { font-size: 12px; color: var(--accent); font-weight: 500; }
        
        .uploaded { font-size: 11px; color: var(--success); margin-top: 8px; font-weight: 500; }
        
        .image-thumbnails { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 12px; }
        .image-thumb { position: relative; width: 64px; height: 64px; border-radius: var(--radius-sm); overflow: hidden; border: 2px solid var(--border-color); cursor: pointer; transition: all 0.2s; }
        .image-thumb:hover { border-color: var(--accent); transform: scale(1.05); }
        .image-thumb img { width: 100%; height: 100%; object-fit: cover; }
        .image-thumb .thumb-remove { position: absolute; top: -6px; right: -6px; width: 20px; height: 20px; background: var(--error); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; opacity: 0; transition: opacity 0.2s; border: 2px solid var(--bg-surface); }
        .image-thumb:hover .thumb-remove { opacity: 1; }
        .image-thumb .thumb-index { position: absolute; bottom: 2px; left: 2px; background: rgba(0, 0, 0, 0.75); color: white; font-size: 9px; padding: 2px 5px; border-radius: 4px; font-weight: 600; }
        
        /* Storyboard Mode Styles */
        .storyboard-container { display: none; }
        .storyboard-container.active { display: block; }
        
        .storyboard-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .storyboard-header h3 { font-size: 13px; font-weight: 600; color: var(--text-primary); display: flex; align-items: center; gap: 8px; margin: 0; }
        
        /* Mode Toggle Buttons */
        .storyboard-mode-toggle { display: flex; gap: 4px; background: var(--bg-input); padding: 3px; border-radius: var(--radius-sm); }
        .mode-btn { padding: 6px 12px; font-size: 11px; font-weight: 500; border: none; background: transparent; color: var(--text-muted); cursor: pointer; border-radius: 4px; transition: all 0.2s; white-space: nowrap; }
        .mode-btn:hover { color: var(--text-primary); }
        .mode-btn.active { background: var(--accent); color: white; }
        
        /* Mode Hint */
        .storyboard-mode-hint { padding: 8px 12px; background: var(--bg-elevated); border-radius: var(--radius-sm); margin-bottom: 12px; font-size: 11px; color: var(--text-secondary); border-left: 3px solid var(--accent); }
        
        /* Image hover preview */
        #imagePreview { position: fixed; pointer-events: none; z-index: 10000; display: none; border-radius: var(--radius-md); overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); border: 2px solid var(--accent); background: var(--bg-surface); }
        #imagePreview img { display: block; max-width: 250px; max-height: 300px; object-fit: contain; }
        #imagePreview.visible { display: block; }
        
        .storyboard-main { display: flex; gap: 12px; }
        
        /* Sidebar: Image thumbnails */
        .storyboard-sidebar { width: 80px; flex-shrink: 0; display: flex; flex-direction: column; gap: 8px; }
        .storyboard-sidebar-image { width: 70px; border-radius: var(--radius-sm); overflow: hidden; border: 2px solid var(--border-color); position: relative; background: var(--bg-input); cursor: default; transition: all 0.2s; }
        .storyboard-sidebar-image.draggable { cursor: grab; }
        .storyboard-sidebar-image.draggable:hover { border-color: var(--accent); }
        .storyboard-sidebar-image.draggable:active { cursor: grabbing; }
        .storyboard-sidebar-image.being-dragged { opacity: 0.4; border-color: var(--accent); }
        body.is-dragging-image { cursor: grabbing !important; }
        body.is-dragging-image * { cursor: grabbing !important; }
        .storyboard-sidebar-image img { width: 100%; height: 50px; object-fit: cover; display: block; }
        .storyboard-sidebar-image .img-index { position: absolute; top: 4px; left: 4px; background: rgba(0,0,0,0.85); color: white; font-size: 9px; padding: 1px 5px; border-radius: 3px; font-weight: 600; }
        .storyboard-sidebar-image .img-range { font-size: 8px; color: var(--text-muted); text-align: center; padding: 3px 2px; background: var(--bg-elevated); }
        .storyboard-sidebar-image .img-remove { position: absolute; top: 2px; right: 2px; width: 16px; height: 16px; background: rgba(0,0,0,0.7); color: white; border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0; transition: opacity 0.2s; }
        .storyboard-sidebar-image:hover .img-remove { opacity: 1; }
        .storyboard-sidebar-image .img-remove:hover { background: var(--error); }
        .storyboard-sidebar-add { width: 70px; height: 50px; border: 2px dashed var(--border-color); border-radius: var(--radius-sm); display: flex; align-items: center; justify-content: center; color: var(--text-muted); font-size: 18px; cursor: pointer; transition: all 0.2s; }
        .storyboard-sidebar-add:hover { border-color: var(--accent); color: var(--accent); }
        
        /* Rich Editor */
        .storyboard-editor-col { flex: 1; display: flex; flex-direction: column; }
        
        .storyboard-editor { width: 100%; min-height: 280px; max-height: 450px; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: var(--radius-sm); padding: 12px 12px 12px 40px; font-family: 'JetBrains Mono', monospace; font-size: 11px; line-height: 1.7; color: var(--text-primary); overflow-y: auto; outline: none; position: relative; }
        .storyboard-editor:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); }
        .storyboard-editor.drag-over { background: rgba(99, 102, 241, 0.05); border-color: var(--accent); }
        
        /* Scene Divider - for Storyboard mode */
        .scene-divider-wrapper { margin: 12px 0 6px -28px; }
        .scene-divider-wrapper:first-child { margin-top: 0; }
        
        /* Scene transition toggle (Blend to / Cut to) - floats above scene box */
        .scene-transition-toggle { display: inline-flex; align-items: center; gap: 3px; padding: 2px 8px; margin-bottom: 4px; margin-left: 10px; background: var(--bg-surface); border-radius: 4px; cursor: pointer; border: 1px solid var(--border-color); transition: all 0.2s; font-size: 9px; }
        .scene-transition-toggle:hover { border-color: var(--accent); background: var(--bg-elevated); }
        .scene-transition-toggle.blend { background: rgba(99, 102, 241, 0.2); border-color: var(--accent); }
        .scene-transition-toggle .trans-icon { font-size: 10px; }
        .scene-transition-toggle .trans-label { color: var(--text-secondary); text-transform: uppercase; font-weight: 600; letter-spacing: 0.3px; }
        .scene-transition-toggle.blend .trans-label { color: var(--accent); }
        
        /* Scene box container */
        .scene-divider { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: var(--bg-elevated); border: 1px solid var(--accent); border-radius: var(--radius-sm); user-select: none; transition: all 0.2s; }
        .scene-divider:hover { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
        .scene-divider.dragging { opacity: 0.5; border-style: dashed; }
        .scene-divider.drop-target { border-color: var(--success); background: rgba(16, 185, 129, 0.2); border-width: 2px; }
        
        /* Image thumbnail */
        .scene-divider-img { width: 40px; height: 40px; border-radius: 4px; object-fit: cover; pointer-events: none; flex-shrink: 0; }
        
        /* Clip mode toggle (Blend/Continue/Fresh) - next to image */
        .clip-mode-toggle { display: flex; border-radius: 4px; overflow: hidden; border: 1px solid var(--border-color); flex-shrink: 0; }
        .clip-mode-btn { padding: 4px 6px; font-size: 8px; text-transform: uppercase; font-weight: 600; background: var(--bg-input); color: var(--text-muted); border: none; cursor: pointer; transition: all 0.15s; white-space: nowrap; letter-spacing: 0.2px; }
        .clip-mode-btn:not(:last-child) { border-right: 1px solid var(--border-color); }
        .clip-mode-btn:hover { background: var(--bg-elevated); color: var(--text-secondary); }
        .clip-mode-btn.active { background: var(--accent); color: white; }
        .clip-mode-btn.active.blend-btn { background: #6366f1; }
        .clip-mode-btn.active.continue-btn { background: #10b981; }
        .clip-mode-btn.active.fresh-btn { background: #f59e0b; }
        
        /* Scene info */
        .scene-divider-info { flex: 1; pointer-events: none; min-width: 0; }
        .scene-divider-label { font-size: 10px; font-weight: 700; color: var(--accent); }
        .scene-divider-hint { font-size: 9px; color: var(--text-muted); }
        
        /* Scene actions */
        .scene-divider-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
        .scene-divider-remove { background: transparent; border: none; color: var(--text-muted); cursor: pointer; font-size: 12px; padding: 2px 6px; border-radius: 3px; }
        .scene-divider-remove:hover { color: var(--error); background: rgba(239, 68, 68, 0.1); }
        
        /* Global interpolation toggle disabled state */
        .toggle-row.disabled { opacity: 0.4; pointer-events: none; }
        .toggle-row.disabled .toggle { background: var(--bg-input) !important; }
        .toggle-row.disabled .toggle::after { left: 50% !important; transform: translateX(-50%); }
        
        /* Last Frame drop zone - OLD LARGE VERSION REMOVED */
        
        /* Compact Last Frame indicator (shown when set) */
        .last-frame-indicator { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            margin: 12px 0 4px -28px; 
            padding: 6px 10px; 
            background: rgba(16, 185, 129, 0.1); 
            border: 1px solid var(--success); 
            border-radius: var(--radius-sm); 
        }
        .last-frame-thumb { width: 28px; height: 28px; border-radius: 4px; object-fit: cover; }
        .last-frame-indicator .last-frame-text { font-size: 10px; color: var(--success); font-weight: 600; flex: 1; }
        .last-frame-remove-btn { background: transparent; border: none; color: var(--text-muted); cursor: pointer; font-size: 12px; padding: 2px 6px; border-radius: 3px; }
        .last-frame-remove-btn:hover { color: var(--error); background: rgba(239, 68, 68, 0.1); }
        .end-frame-blend-badge { 
            font-size: 8px; 
            font-weight: 700; 
            color: var(--accent); 
            background: rgba(99, 102, 241, 0.15); 
            padding: 2px 6px; 
            border-radius: 3px; 
            letter-spacing: 0.3px;
            cursor: default;
        }
        
        /* Drop zone indicator between lines */
        .drop-indicator { height: 3px; background: var(--accent); margin: 4px 0; border-radius: 2px; display: none; }
        .drop-indicator.active { display: block; }
        
        /* Drop indicator line (appears when dragging between lines) */
        .drop-indicator-line { 
            height: 24px;
            margin: 4px 0 4px -28px;
            padding: 4px 12px;
            background: linear-gradient(90deg, var(--accent), rgba(99, 102, 241, 0.3)); 
            border-radius: 4px; 
            pointer-events: none; 
            font-size: 9px;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
        }
        .drop-indicator-line.end-frame {
            background: linear-gradient(90deg, var(--success), rgba(16, 185, 129, 0.3));
        }
        
        /* Lines with gutter numbers */
        .scene-line { position: relative; padding: 2px 0; min-height: 1.5em; }
        .scene-line::before { content: attr(data-line); position: absolute; left: -32px; width: 24px; text-align: right; font-size: 9px; color: var(--text-muted); user-select: none; pointer-events: none; opacity: 0.6; }
        
        /* Placeholder for empty editor */
        .scene-line.placeholder-line:empty::before { content: 'Paste your script here...'; position: static; width: auto; text-align: left; font-size: 13px; color: var(--text-muted); opacity: 0.5; font-style: italic; }
        
        /* Image indicator dot for auto-cycle mode */
        .scene-line[data-img]::after { content: attr(data-img); position: absolute; right: 4px; top: 2px; font-size: 8px; color: var(--accent); opacity: 0.7; user-select: none; pointer-events: none; }
        
        .scene-text-block { min-height: 1.5em; }
        
        /* Simple Mode Rich Editor (single image) */
        .simple-editor-container { position: relative; }
        .simple-rich-editor { width: 100%; min-height: 200px; max-height: 400px; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: var(--radius-sm); padding: 12px 12px 12px 40px; font-family: 'JetBrains Mono', monospace; font-size: 12px; line-height: 1.7; color: var(--text-primary); overflow-y: auto; outline: none; }
        .simple-rich-editor:focus { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-glow); }
        .simple-rich-editor .simple-line { position: relative; padding: 2px 0; min-height: 1.5em; }
        .simple-rich-editor .simple-line::before { content: attr(data-line); position: absolute; left: -32px; width: 24px; text-align: right; font-size: 9px; color: var(--text-muted); user-select: none; pointer-events: none; opacity: 0.6; }
        .simple-rich-editor .simple-line.placeholder-line:empty::before { content: 'Paste your script here...'; position: static; width: auto; text-align: left; font-size: 13px; color: var(--text-muted); opacity: 0.5; font-style: italic; }
        
        .storyboard-summary { display: flex; align-items: center; flex-wrap: wrap; gap: 12px; padding: 10px 12px; background: var(--bg-input); border-radius: var(--radius-sm); margin-top: 12px; font-size: 11px; }
        .storyboard-summary .summary-item { display: flex; align-items: center; gap: 4px; color: var(--text-secondary); }
        .storyboard-summary .summary-item.ok { color: var(--success); }
        .storyboard-summary .summary-item.warn { color: var(--warning); }
        
        .aspect-selector { display: flex; gap: 12px; }
        .aspect-btn { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 6px; padding: 12px; background: var(--bg-input); border: 2px solid var(--border-color); border-radius: var(--radius-sm); cursor: pointer; transition: all 0.2s; }
        .aspect-btn:hover { border-color: var(--border-subtle); }
        .aspect-btn.active { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
        .aspect-btn .aspect-icon { width: 32px; height: 24px; border: 2px solid currentColor; border-radius: 3px; color: var(--text-muted); transition: color 0.2s; }
        .aspect-btn.active .aspect-icon { color: var(--accent); }
        .aspect-btn .aspect-icon.vertical { width: 18px; height: 28px; }
        .aspect-btn span { font-size: 11px; color: var(--text-muted); font-weight: 500; }
        .aspect-btn.active span { color: var(--accent); }
        
        .resolution-toggle { display: flex; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: var(--radius-sm); overflow: hidden; }
        .resolution-toggle button { flex: 1; padding: 10px; background: transparent; border: none; color: var(--text-muted); font-family: inherit; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .resolution-toggle button.active { background: var(--accent); color: white; }
        .resolution-toggle button:hover:not(.active) { background: var(--bg-elevated); }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; }
        .toggle-label { display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--text-secondary); }
        .toggle { width: 44px; height: 24px; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 12px; cursor: pointer; position: relative; transition: all 0.2s; }
        .toggle.active { background: var(--accent); border-color: var(--accent); }
        .toggle::after { content: ''; position: absolute; top: 3px; left: 3px; width: 16px; height: 16px; background: var(--text-muted); border-radius: 50%; transition: all 0.2s; }
        .toggle.active::after { transform: translateX(20px); background: white; }
        
        .btn { display: inline-flex; align-items: center; justify-content: center; gap: 6px; padding: 10px 18px; border: none; border-radius: var(--radius-sm); font-family: inherit; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .btn:active { transform: scale(0.97); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
        .btn-primary { background: linear-gradient(135deg, var(--accent), var(--accent2)); color: white; box-shadow: 0 4px 12px var(--accent-glow); }
        .btn-primary:hover { box-shadow: 0 6px 20px var(--accent-glow); transform: translateY(-1px); }
        .btn-secondary { background: var(--bg-elevated); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-secondary:hover { background: var(--border-color); }
        .btn-danger { background: var(--error); color: white; }
        .btn-sm { padding: 6px 12px; font-size: 12px; }
        .btn-start { padding: 14px 32px; font-size: 15px; font-weight: 600; border-radius: var(--radius-md); }
        .btn-approve { background: var(--success); color: white; }
        .btn-reject { background: var(--error); color: white; }
        .btn-redo { background: var(--warning); color: white; }
        
        .generate-container { margin-top: 20px; text-align: center; }
        .generate-container .btn-start { width: 100%; max-width: 280px; }
        
        .config-top-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; align-items: start; margin-bottom: 16px; }
        .config-top-row .card { margin-bottom: 0; }
        @media (max-width: 700px) { .config-top-row { grid-template-columns: 1fr; } .config-top-row .card { margin-bottom: 16px; } }
        .state-active .config-top-row { grid-template-columns: 1fr; }
        .state-active .config-top-row .card { margin-bottom: 16px; }
        
        .badge { display: inline-block; padding: 4px 10px; border-radius: 99px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .badge-pending, .badge-pending_review { background: rgba(99, 102, 241, 0.15); color: var(--accent); }
        .badge-running, .badge-generating, .badge-processing { background: rgba(99, 102, 241, 0.15); color: var(--accent); }
        .badge-paused { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .badge-redo_queued, .badge-flow_redo_queued { background: rgba(251, 191, 36, 0.2); color: #f59e0b; }
        .badge-waiting_approval { background: rgba(245, 158, 11, 0.15); color: #f59e0b; }
        .badge-completed, .badge-approved { background: rgba(16, 185, 129, 0.15); color: var(--success); }
        .badge-failed, .badge-max_attempts { background: rgba(239, 68, 68, 0.15); color: var(--error); }
        .badge-skipped { background: rgba(251, 191, 36, 0.15); color: #f59e0b; }
        .badge-rejected { background: rgba(239, 68, 68, 0.15); color: var(--error); }
        
        .jobs-list { display: flex; flex-direction: column; gap: 8px; max-height: 280px; overflow-y: auto; }
        .job-item { background: var(--bg-elevated); border-radius: var(--radius-md); padding: 12px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; }
        .job-item:hover { border-color: var(--border-subtle); }
        .job-item.selected { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
        .job-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .job-id { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--text-muted); }
        
        .progress-bar { height: 4px; background: var(--bg-input); border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.3s ease; }
        .progress-text { display: flex; justify-content: space-between; font-size: 10px; color: var(--text-muted); margin-top: 6px; }
        
        .stats-row { display: flex; gap: 8px; margin: 12px 0; }
        .stat { flex: 1; text-align: center; padding: 10px; background: var(--bg-elevated); border-radius: var(--radius-sm); }
        .stat-val { font-size: 18px; font-weight: 600; }
        .stat-lbl { font-size: 9px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
        
        .clips-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 16px; margin-top: 12px; }
        .clips-grid.expanded-mode { grid-template-columns: 1fr; gap: 20px; }
        /* Dual-view: collapsed shown by default, expanded hidden */
        .clip-video-expanded { display: none; width: 100%; }
        .clips-grid.expanded-mode .clip-video-collapsed { display: none; }
        .clips-grid.expanded-mode .clip-video-expanded { display: block; width: 100%; background: #000; border-radius: var(--radius-sm) var(--radius-sm) 0 0; }
        .clip-video-expanded .variants-grid { width: 100%; box-sizing: border-box; }
        .clip-actions-collapsed { }
        .clip-actions-expanded { display: none; }
        .clips-grid.expanded-mode .clip-actions-collapsed { display: none; }
        .clips-grid.expanded-mode .clip-actions-expanded { display: block; }
        .clip-card { background: var(--bg-elevated); border-radius: var(--radius-lg); overflow: hidden; transition: all 0.2s; border: 2px solid transparent; }
        .clip-card:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3); }
        .clip-card.clip-rejected { border-color: var(--error); opacity: 0.8; }
        .clip-card.clip-approved { border-color: var(--success); }
        .clip-card.clip-generating { border-color: var(--accent); }
        .clip-card.clip-redo_queued, .clip-card.clip-flow_redo_queued { border-color: #f59e0b; }
        .clip-card.clip-skipped { border-color: #f59e0b; opacity: 0.7; background: rgba(245, 158, 11, 0.05); }
        /* Expanded variants grid — 4 per row, big cards */
        .variants-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; padding: 8px; }
        @media (max-width: 900px) { .variants-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 600px) { .variants-grid { grid-template-columns: repeat(2, 1fr); } }
        .variant-group-header { padding: 8px 12px 4px; font-size: 12px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; border-top: 1px solid var(--border); margin-top: 4px; }
        .variant-group-header:first-child { border-top: none; margin-top: 0; }
        .variant-group-count { font-weight: 400; font-size: 11px; opacity: 0.6; text-transform: none; letter-spacing: 0; }
        .variant-card { position: relative; border-radius: var(--radius-sm); overflow: hidden; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; background: rgba(0,0,0,0.3); }
        .variant-card:hover { border-color: rgba(99, 102, 241, 0.5); }
        .variant-card.variant-selected { border-color: var(--success); box-shadow: 0 0 12px rgba(16, 185, 129, 0.3); }
        .variant-card video { width: 100%; aspect-ratio: 9/16; object-fit: cover; display: block; border-radius: var(--radius-sm); }
        .variant-label { position: absolute; top: 6px; left: 6px; background: rgba(0,0,0,0.7); color: white; font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 4px; backdrop-filter: blur(4px); }
        .variant-select-btn { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); padding: 4px 14px; font-size: 11px; font-weight: 600; border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s; background: rgba(255,255,255,0.15); color: white; backdrop-filter: blur(4px); }
        .variant-select-btn:hover { background: var(--primary); }
        .variant-card.variant-selected .variant-select-btn { background: var(--success); color: white; }
        .expand-toggle { background: rgba(255,255,255,0.08); border: 1px solid var(--border); color: var(--text-muted); padding: 4px 10px; border-radius: 6px; font-size: 11px; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 4px; }
        .expand-toggle:hover { background: rgba(255,255,255,0.14); color: white; }
        .clip-video { background: #000; aspect-ratio: 9/16; max-height: 260px; display: flex; align-items: center; justify-content: center; position: relative; flex-direction: column; }
        .clip-video video { width: 100%; height: 100%; object-fit: contain; }
        .clip-video .video-container { width: 100%; height: 100%; position: relative; }
        .clip-video .video-container video { width: 100%; height: 100%; object-fit: contain; }
        .video-download-btn { position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.7); border: none; border-radius: 6px; padding: 6px 8px; cursor: pointer; font-size: 14px; opacity: 0; transition: opacity 0.2s; z-index: 10; }
        .video-container:hover .video-download-btn, .video-container:hover .video-voice-btn { opacity: 1; }
        .all-approved .video-download-btn, .all-approved .video-voice-btn { opacity: 1; }
        .video-download-btn:hover { background: rgba(99, 102, 241, 0.9); }
        .video-voice-btn { position: absolute; top: 8px; right: 42px; background: rgba(147, 51, 234, 0.8); border: none; border-radius: 6px; padding: 6px 8px; cursor: pointer; font-size: 14px; opacity: 0; transition: opacity 0.2s; z-index: 10; }
        .video-voice-btn:hover { background: rgba(147, 51, 234, 1); }
        .video-voice-btn.selected { background: rgba(34, 197, 94, 0.9); opacity: 1; }
        
        .variant-nav { position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 4px; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 12px; backdrop-filter: blur(4px); }
        .variant-btn { background: transparent; border: none; color: white; cursor: pointer; font-size: 10px; padding: 2px 6px; opacity: 0.8; transition: opacity 0.2s; }
        .variant-btn:hover:not(:disabled) { opacity: 1; }
        .variant-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .variant-indicator { font-size: 10px; color: white; font-weight: 600; min-width: 36px; text-align: center; }
        
        .clip-content { padding: 12px; }
        .clip-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        .clip-idx { font-weight: 600; font-size: 12px; }
        .clip-frames { display: flex; align-items: center; gap: 4px; font-size: 9px; color: var(--text-muted); background: var(--bg-input); padding: 3px 6px; border-radius: 4px; margin-bottom: 6px; overflow: hidden; }
        .clip-frames .frame-icon { font-size: 10px; }
        .clip-frames .frame-names { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .clip-text { font-size: 11px; color: var(--text-secondary); display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin-bottom: 10px; line-height: 1.4; }
        .clip-actions { display: flex; gap: 6px; }
        .clip-actions .btn { flex: 1; padding: 6px; font-size: 11px; }
        
        .generating-spinner { font-size: 28px; animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .generating-state, .pending-state, .failed-state { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; height: 100%; }
        .generating-state { animation: pulse 1.5s ease-in-out infinite; }
        .generating-text, .pending-text, .failed-text { font-size: 11px; color: var(--text-muted); }
        .pending-icon { font-size: 24px; opacity: 0.5; }
        .failed-icon { font-size: 24px; }
        .failed-state { color: var(--error); }
        .clip-progress { padding: 4px; }
        .clip-progress-bar { height: 3px; background: var(--bg-input); border-radius: 2px; overflow: hidden; position: relative; }
        .clip-progress-bar::after { content: ''; position: absolute; top: 0; left: 0; height: 100%; width: 30%; background: linear-gradient(90deg, var(--accent), var(--accent2)); animation: clipProgress 1.5s ease-in-out infinite; }
        @keyframes clipProgress { 0% { left: -30%; } 100% { left: 100%; } }
        
        .generation-progress { background: var(--bg-elevated); border-radius: var(--radius-md); padding: 14px; margin-bottom: 12px; }
        .gen-status { font-size: 13px; color: var(--text-secondary); margin-bottom: 10px; display: flex; align-items: center; gap: 8px; }
        .gen-bar { height: 6px; background: var(--bg-input); border-radius: 3px; overflow: hidden; }
        .gen-bar-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.5s ease; }
        
        .review-banner { background: linear-gradient(135deg, var(--accent), var(--accent2)); color: white; padding: 14px 18px; border-radius: var(--radius-md); margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; }
        .review-banner h3 { font-size: 14px; font-weight: 600; }
        .review-stats { display: flex; gap: 12px; }
        .review-stat { text-align: center; padding: 6px 12px; background: rgba(255, 255, 255, 0.15); border-radius: var(--radius-sm); }
        .review-stat-val { font-size: 16px; font-weight: 600; }
        .review-stat-lbl { font-size: 9px; text-transform: uppercase; opacity: 0.8; }
        
        .rejected-notice { display: flex; flex-direction: column; gap: 8px; align-items: center; padding: 6px; background: rgba(239, 68, 68, 0.1); border-radius: var(--radius-sm); }
        .rejected-notice span { font-size: 11px; color: var(--error); }
        .rejected-notice .btn { width: 100%; }
        .max-notice { font-size: 11px; color: var(--warning); text-align: center; padding: 6px; background: rgba(245, 158, 11, 0.1); border-radius: var(--radius-sm); }
        
        .line-validation { display: flex; flex-direction: column; gap: 4px; }
        .line-check { display: flex; align-items: flex-start; gap: 8px; padding: 8px 10px; border-radius: var(--radius-sm); font-size: 11px; }
        .line-check.line-ok { background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); }
        .line-check.line-short { background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); }
        .line-check.line-long { background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); }
        .line-check .line-num { font-weight: 600; min-width: 28px; }
        .line-check .line-status { font-weight: 500; min-width: 80px; }
        .line-check.line-ok .line-status { color: var(--success); }
        .line-check.line-short .line-status { color: var(--error); }
        .line-check.line-long .line-status { color: var(--warning); }
        .line-check .line-images { background: var(--bg-input); padding: 2px 6px; border-radius: 4px; color: var(--accent); font-size: 10px; white-space: nowrap; }
        .line-check .line-info { color: var(--text-secondary); flex: 1; }
        .validation-summary { font-size: 12px; padding: 8px 12px; border-radius: var(--radius-sm); margin-bottom: 8px; }
        .validation-summary.all-ok { background: rgba(16, 185, 129, 0.15); color: var(--success); }
        .validation-summary.has-issues { background: rgba(239, 68, 68, 0.15); color: var(--error); }
        
        .logs { max-height: 140px; overflow-y: auto; background: var(--bg-input); border-radius: var(--radius-sm); padding: 8px; font-family: 'JetBrains Mono', monospace; font-size: 10px; margin-top: 12px; }
        .alert-banner { background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white; padding: 16px; border-radius: var(--radius-md); margin-bottom: 16px; text-align: center; animation: pulse 2s infinite; }
        .alert-banner h4 { margin: 0 0 8px 0; font-size: 16px; }
        .alert-banner p { margin: 0; font-size: 13px; opacity: 0.9; }
        .alert-banner a { color: white; text-decoration: underline; font-weight: 600; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        .log { padding: 4px 0; display: flex; gap: 10px; border-bottom: 1px solid var(--border-color); }
        .log:last-child { border: none; }
        .log-time { color: var(--text-muted); }
        .log-msg { color: var(--text-secondary); }
        
        .empty { text-align: center; padding: 40px; color: var(--text-muted); }
        .empty h3 { font-size: 14px; color: var(--text-secondary); margin-bottom: 6px; }
        .empty p { font-size: 12px; }
        
        .modal { position: fixed; inset: 0; background: #0F172A; display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal-box { background: var(--bg-surface); border: 1px solid var(--border-color); border-radius: var(--radius-lg); padding: 24px; width: 100%; max-width: 360px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6); }
        .modal h3 { margin-bottom: 12px; font-size: 16px; }
        .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 16px; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-surface); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--border-subtle); }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideInLeft { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
        .generating { animation: pulse 2s infinite; }
        .tip-text { font-size: 11px; color: var(--text-muted); margin-top: 10px; line-height: 1.5; }
        .tip-text strong { color: var(--text-secondary); }
        
        /* ====== Tutorial Overlay ====== */
        .tutorial-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(8px);
            z-index: 99999; display: none; flex-direction: column;
        }
        .tutorial-overlay.show { display: flex; }
        .tutorial-header {
            background: linear-gradient(135deg, rgba(99,102,241,0.25), rgba(139,92,246,0.2));
            border-bottom: 1px solid var(--border-color); padding: 14px 24px;
            display: flex; align-items: center; justify-content: space-between; flex-shrink: 0;
        }
        .tutorial-header h2 {
            font-size: 17px; font-weight: 700; display: flex; align-items: center; gap: 10px; margin: 0;
        }
        .tutorial-header h2 .tut-icon {
            background: linear-gradient(135deg, var(--accent), var(--accent2)); width: 34px; height: 34px;
            border-radius: 10px; display: inline-flex; align-items: center; justify-content: center; font-size: 17px;
        }
        .tutorial-progress { height: 3px; background: var(--bg-elevated); flex-shrink: 0; }
        .tutorial-progress-fill {
            height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2));
            width: 0%; transition: width 0.15s ease-out;
        }
        .tutorial-iframe-wrap { flex: 1; overflow: hidden; position: relative; }
        .tutorial-iframe-wrap iframe {
            width: 100%; height: 100%; border: none; background: var(--bg-primary);
        }
        .tutorial-scroll-hint {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: var(--accent); color: white; padding: 8px 18px; border-radius: 99px;
            font-size: 12px; font-weight: 600; display: flex; align-items: center; gap: 6px;
            animation: tutBounce 2s ease-in-out infinite; pointer-events: none; z-index: 2;
            box-shadow: 0 4px 20px rgba(99,102,241,0.4); transition: opacity 0.4s;
        }
        .tutorial-scroll-hint.hidden { opacity: 0; pointer-events: none; }
        @keyframes tutBounce { 0%,100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-6px); } }
        .tutorial-footer {
            border-top: 1px solid var(--border-color); padding: 14px 24px; display: flex;
            justify-content: space-between; align-items: center; flex-shrink: 0; background: var(--bg-surface);
        }
        .tutorial-footer .dont-show {
            display: flex; align-items: center; gap: 8px; cursor: pointer;
            font-size: 13px; color: var(--text-secondary); user-select: none;
        }
        .tutorial-footer .dont-show input[type=checkbox] {
            width: 16px; height: 16px; accent-color: var(--accent); cursor: pointer;
        }
        .tutorial-close-btn {
            padding: 10px 28px; background: linear-gradient(135deg, var(--accent), var(--accent2)); border: none;
            border-radius: var(--radius-sm); color: white; font-weight: 600; font-size: 14px; cursor: not-allowed;
            transition: all 0.2s; opacity: 0.35;
        }
        .tutorial-close-btn.enabled { opacity: 1; cursor: pointer; }
        .tutorial-close-btn.enabled:hover { transform: translateY(-1px); box-shadow: 0 4px 16px var(--accent-glow); }
        .btn-tutorial { background: rgba(99,102,241,0.15); border: 1px solid rgba(99,102,241,0.3); color: #818CF8; }
        .btn-tutorial:hover { background: rgba(99,102,241,0.25); border-color: rgba(99,102,241,0.5); }
        @media (max-width: 600px) {
            .tutorial-footer { flex-direction: column; gap: 12px; }
        }
        
        /* ====== Onboarding Sidebar ====== */
        .onboarding-sidebar {
            position: fixed; top: 64px; right: 0; bottom: 0; width: 370px; z-index: 9000;
            background: var(--bg-surface); border-left: 1px solid var(--border-color);
            display: flex; flex-direction: column; transform: translateX(100%);
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: -4px 0 24px rgba(0,0,0,0.3);
        }
        .onboarding-sidebar.open { transform: translateX(0); }
        .onboarding-sidebar.open ~ .main-content,
        body.onboarding-active .main-content { margin-right: 370px; transition: margin-right 0.35s cubic-bezier(0.4, 0, 0.2, 1); }
        .ob-header {
            padding: 16px 18px; border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, rgba(99,102,241,0.15), rgba(139,92,246,0.1));
            display: flex; align-items: center; justify-content: space-between; flex-shrink: 0;
        }
        .ob-header h3 { font-size: 14px; font-weight: 700; display: flex; align-items: center; gap: 8px; margin: 0; }
        .ob-header .ob-step-label { font-size: 11px; color: var(--text-muted); }
        .ob-close { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 18px; padding: 4px 8px; border-radius: 6px; transition: all 0.2s; }
        .ob-close:hover { background: var(--bg-elevated); color: var(--text-primary); }
        .ob-progress { height: 3px; background: var(--bg-elevated); flex-shrink: 0; }
        .ob-progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.4s ease-out; }
        .ob-body { flex: 1; overflow-y: auto; padding: 20px 18px; }
        .ob-step-num {
            display: inline-flex; align-items: center; justify-content: center;
            width: 28px; height: 28px; border-radius: 8px; font-size: 13px; font-weight: 700;
            background: linear-gradient(135deg, var(--accent), var(--accent2)); color: white;
            margin-bottom: 12px;
        }
        .ob-step-title { font-size: 17px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px; line-height: 1.3; }
        .ob-step-desc { font-size: 13px; color: var(--text-secondary); line-height: 1.65; margin-bottom: 16px; }
        .ob-step-desc strong { color: var(--text-primary); }
        .ob-step-desc a { color: #818CF8; text-decoration: none; }
        .ob-step-desc a:hover { text-decoration: underline; }
        .ob-step-list { list-style: none; padding: 0; margin: 0 0 16px; counter-reset: oblist; }
        .ob-step-list li {
            counter-increment: oblist; padding: 8px 0 8px 32px; position: relative;
            font-size: 13px; color: var(--text-secondary); line-height: 1.5;
            border-bottom: 1px solid rgba(71,85,105,0.15);
        }
        .ob-step-list li::before {
            content: counter(oblist); position: absolute; left: 0; top: 8px;
            width: 22px; height: 22px; background: var(--bg-elevated); border: 1px solid var(--border-color);
            border-radius: 6px; display: flex; align-items: center; justify-content: center;
            font-weight: 700; font-size: 11px; color: var(--accent);
        }
        .ob-tip {
            background: rgba(16,185,129,0.08); border-left: 3px solid var(--success);
            border-radius: 0 8px 8px 0; padding: 10px 14px; margin: 12px 0;
            font-size: 12px; color: var(--text-secondary); line-height: 1.55;
        }
        .ob-tip strong { color: var(--success); }
        .ob-warn {
            background: rgba(239,68,68,0.08); border-left: 3px solid var(--error);
            border-radius: 0 8px 8px 0; padding: 10px 14px; margin: 12px 0;
            font-size: 12px; color: var(--text-secondary); line-height: 1.55;
        }
        .ob-warn strong { color: var(--error); }
        .ob-status {
            display: flex; align-items: center; gap: 8px; padding: 10px 14px;
            border-radius: 8px; margin: 14px 0; font-size: 13px; font-weight: 600;
        }
        .ob-status.waiting { background: rgba(99,102,241,0.1); color: var(--accent); }
        .ob-status.waiting .ob-spinner { display: inline-block; animation: spin 1.2s linear infinite; }
        .ob-status.done { background: rgba(16,185,129,0.12); color: var(--success); }
        .ob-footer {
            padding: 14px 18px; border-top: 1px solid var(--border-color);
            display: flex; flex-direction: column; gap: 10px; flex-shrink: 0; background: var(--bg-surface);
        }
        .ob-nav { display: flex; gap: 8px; }
        .ob-nav .btn { flex: 1; font-size: 13px; padding: 9px 14px; }
        .ob-skip { text-align: center; }
        .ob-skip button {
            background: none; border: none; color: var(--text-muted); font-size: 11px;
            cursor: pointer; padding: 4px 8px; transition: color 0.2s;
        }
        .ob-skip button:hover { color: var(--text-primary); }
        /* Toggle tab on the left edge when sidebar is closed */
        .ob-toggle-tab {
            position: fixed; right: 0; top: 50%; transform: translateY(-50%);
            background: var(--accent); color: white; border: none; cursor: pointer;
            padding: 12px 6px; border-radius: 8px 0 0 8px; font-size: 12px; font-weight: 700;
            writing-mode: vertical-rl; text-orientation: mixed; z-index: 8999;
            box-shadow: -2px 0 12px rgba(99,102,241,0.3); transition: all 0.3s;
            display: none;
        }
        .ob-toggle-tab:hover { padding-right: 10px; background: var(--accent2); }
        .ob-toggle-tab.visible { display: block; }
        .onboarding-sidebar.open + .ob-toggle-tab { display: none; }
        @media (max-width: 900px) {
            .onboarding-sidebar { width: 100%; top: auto; bottom: 0; height: 45vh; min-height: 280px;
                transform: translateY(100%); border-left: none; border-top: 1px solid var(--border-color); }
            .onboarding-sidebar.open { transform: translateY(0); }
            .onboarding-sidebar.open ~ .main-content,
            body.onboarding-active .main-content { margin-right: 0; margin-bottom: 45vh; }
            .ob-toggle-tab { writing-mode: horizontal-tb; right: 50%; top: auto; bottom: 0;
                transform: translateX(50%); border-radius: 8px 8px 0 0; padding: 6px 16px; }
        }
    </style>
</head>
<body>
    <!-- Hidden 1x1 transparent image for drag preview -->
    <img id="emptyDragImage" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="position:absolute;top:-9999px;left:-9999px;width:1px;height:1px;">
    
    <div class="app-container state-initial" id="appContainer">
        <header class="header">
            <div class="logo">
                <div class="logo-icon">🎬</div>
                <h1>Veo 3.1 Studio</h1>
            </div>
            <div class="header-actions">
                <button class="btn btn-tutorial btn-sm" onclick="openTutorial()" title="How to use this platform">📖 Tutorial</button>
                <button class="btn btn-secondary btn-sm" onclick="window.open('/static/my-worker.html', '_blank')" title="Set up your Flow worker">🖥️ My Worker</button>
                <button class="btn btn-secondary btn-sm btn-new-job" onclick="collapseResults()">➕ New Job</button>
                <button class="btn btn-secondary btn-sm" onclick="refreshJobs()">🔄 Refresh</button>
                
                <!-- User Menu -->
                <div class="user-menu" id="userMenu" style="display: none;">
                    <button class="user-btn" onclick="toggleUserDropdown()">
                        <div class="user-avatar" id="userAvatar">
                            <span id="userInitial">?</span>
                        </div>
                        <span class="user-name" id="userName">User</span>
                        <span style="font-size: 10px;">▼</span>
                    </button>
                    <div class="user-dropdown" id="userDropdown">
                        <div class="user-dropdown-header">
                            <div class="user-name" id="userNameFull" style="max-width: none; font-weight: 500;"></div>
                            <div class="user-dropdown-email" id="userEmail"></div>
                        </div>
                        <div class="user-dropdown-item" onclick="openApiKeysModal()">
                            <span>🔑</span> API Keys
                        </div>
                        <div class="user-dropdown-item" onclick="document.getElementById('userDropdown').classList.remove('show');openTutorial();">
                            <span>📖</span> Tutorial
                        </div>
                        <div class="user-dropdown-item logout" onclick="logout()">
                            <span>🚪</span> Sign Out
                        </div>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- API Keys Modal -->
        <div class="modal-overlay" id="apiKeysModal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;">
            <div class="modal" style="margin:auto;">
                <div class="modal-header">
                    <h2>🔑 API Keys</h2>
                    <button class="modal-close" onclick="closeApiKeysModal()">×</button>
                </div>
                <div class="modal-body">
                    <div class="api-keys-info">
                        <strong>Your own Gemini API keys</strong><br>
                        Add your own keys to use your quota. If you don't add any, server keys will be used.<br>
                        <a href="https://console.cloud.google.com" target="_blank">Get API keys from Google Cloud Console →</a>
                        <br><span style="font-size:11px;opacity:0.7;">Create Project → Enable "Generative Language API" → Credentials → Create API Key</span>
                    </div>
                    
                    <!-- Summary of key statuses -->
                    <div id="apiKeysSummary" style="display:none;"></div>
                    
                    <div class="api-keys-list" id="apiKeysList">
                        <div class="empty-keys" id="emptyKeysMessage">
                            <div class="icon">🔐</div>
                            <p>No API keys added yet</p>
                            <p style="font-size: 12px; margin-top: 8px;">Add your Gemini API keys below to use your own quota</p>
                        </div>
                    </div>
                    
                    <div class="add-key-section">
                        <h4>Add Single Key</h4>
                        <div class="add-key-input">
                            <input type="text" id="newApiKeyInput" placeholder="AIzaSy..." autocomplete="off">
                            <button class="btn btn-primary btn-sm" onclick="addSingleApiKey()">Add</button>
                        </div>
                        
                        <div class="bulk-add-section">
                            <h4>Bulk Add (paste multiple keys)</h4>
                            <textarea id="bulkApiKeysInput" placeholder="Paste multiple API keys, one per line..."></textarea>
                            <div class="bulk-add-hint">One key per line. Duplicates will be skipped.</div>
                            <button class="btn btn-secondary btn-sm" style="margin-top: 8px;" onclick="addBulkApiKeys()">Add All Keys</button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeApiKeysModal()">Close</button>
                </div>
            </div>
        </div>
        
        <!-- Onboarding Sidebar (reactive, step-by-step) -->
        <div class="onboarding-sidebar" id="obSidebar">
            <div class="ob-header">
                <h3>📖 <span id="obHeaderTitle">Getting Started</span></h3>
                <div style="display:flex;align-items:center;gap:10px;">
                    <span class="ob-step-label" id="obStepLabel">Step 1 of 7</span>
                    <button class="ob-close" onclick="obMinimize()" title="Minimize">−</button>
                </div>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" id="obProgressFill" style="width:0%"></div></div>
            <div class="ob-body" id="obBody">
                <!-- Filled dynamically by JS -->
            </div>
            <div class="ob-footer">
                <div class="ob-nav" id="obNav">
                    <!-- Filled dynamically -->
                </div>
                <div class="ob-skip">
                    <button onclick="obDismiss()">Hide tutorial permanently</button>
                </div>
            </div>
        </div>
        <button class="ob-toggle-tab" id="obToggleTab" onclick="obReopen()">📖 Tutorial</button>
        
        <!-- Tutorial Overlay (loads tutorial.html via iframe) -->
        <div class="tutorial-overlay" id="tutorialOverlay">
            <div class="tutorial-header">
                <h2><span class="tut-icon">📖</span> Platform Tutorial</h2>
                <span style="font-size:12px;color:var(--text-muted);" id="tutorialScrollPct">0% read</span>
            </div>
            <div class="tutorial-progress"><div class="tutorial-progress-fill" id="tutorialProgressFill"></div></div>
            <div class="tutorial-iframe-wrap">
                <iframe id="tutorialIframe" src="about:blank"></iframe>
                <div class="tutorial-scroll-hint" id="tutorialScrollHint">↓ Scroll through the entire tutorial to continue</div>
            </div>
            <div class="tutorial-footer">
                <label class="dont-show">
                    <input type="checkbox" id="tutorialDontShow">
                    Don't show this again
                </label>
                <button class="tutorial-close-btn" id="tutorialCloseBtn" onclick="closeTutorial()">
                    Got it — Let's Go!
                </button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="config-panel">
                <div class="card" id="simpleImagesCard">
                    <div class="card-title">
                        <span class="section-step">1</span>
                        Images
                        <span class="info-icon">?
                            <div class="tooltip">
                                <h5>📤 Upload Images</h5>
                                <p>Upload 1 or more reference images (PNG, JPG, WebP).</p>
                                <table>
                                    <tr><td>1 image</td><td>Simple mode - same image for all clips</td></tr>
                                    <tr><td>2+ images</td><td>Storyboard mode - transitions between images</td></tr>
                                </table>
                                <p style="margin-top:10px;color:var(--success);">💡 With multiple images, each clip transitions from one image to the next!</p>
                            </div>
                        </span>
                    </div>
                    
                    <!-- Simple Mode: Just upload area and thumbnails -->
                    <div id="simpleModeContainer" class="simple-mode-container">
                        <div class="upload-area" id="uploadArea">
                            <div class="upload-content">
                                <div class="upload-icon">📤</div>
                                <p>Drop images or click to upload</p>
                                <span>PNG, JPG, WebP • Required</span>
                            </div>
                            <div class="upload-loading">
                                <div class="upload-spinner"></div>
                                <span class="upload-loading-text">Uploading...</span>
                            </div>
                        </div>
                        <input type="file" id="fileInput" multiple accept=".png,.jpg,.jpeg,.webp" hidden>
                        <div class="uploaded" id="uploadedCount"></div>
                        <div class="image-thumbnails" id="imageThumbnails"></div>
                    </div>
                </div>
                
                <div class="card" id="settingsCard">
                    <div class="card-title">
                        <span class="section-step">2</span>
                        Settings
                        <span class="info-icon">?
                            <div class="tooltip">
                                <h5>⚙️ Configure Settings</h5>
                                <p>Select your preferred options for video generation:</p>
                                <table>
                                    <tr><td>Language</td><td>Voice language for dialogue</td></tr>
                                    <tr><td>Aspect</td><td>9:16 vertical or 16:9 horizontal</td></tr>
                                    <tr><td>Duration</td><td>Clip length (4s, 6s, or 8s)</td></tr>
                                    <tr><td>Interpolation</td><td>Enable for smooth motion</td></tr>
                                    <tr><td>AI Prompts</td><td>Let AI optimize visuals</td></tr>
                                </table>
                            </div>
                        </span>
                    </div>
                    <div class="config-grid">
                        <!-- Method -->
                        <div class="group">
                            <div class="lbl">Method
                                <span class="info-icon">?
                                    <div class="tooltip">
                                        <h5>🔧 Generation Method</h5>
                                        <p>Choose how videos are generated:</p>
                                        <ul>
                                            <li><strong>Auto:</strong> Uses API keys if available, otherwise Flow</li>
                                            <li><strong>API Keys:</strong> Direct Gemini API (faster, requires keys)</li>
                                            <li><strong>Flow:</strong> Browser automation via your worker (no keys needed)</li>
                                        </ul>
                                    </div>
                                </span>
                            </div>
                            <div class="seg" id="backendToggle">
                                <button class="active" data-value="auto" onclick="selectBackend(this)">Auto</button>
                                <button data-value="api" onclick="selectBackend(this)">API Keys</button>
                                <button data-value="flow" onclick="selectBackend(this)">Flow</button>
                            </div>
                            <div id="backendHintFlow" class="backend-hint flow-hint" style="display:none;">
                                <strong style="color:var(--accent);">🖥️ Flow Mode Selected</strong> — Generate videos using your Google account. No API keys needed.<br>
                                <div style="margin-top:10px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
                                    <a href="/static/my-worker.html" target="_blank" style="display:inline-flex;align-items:center;gap:6px;padding:8px 16px;background:var(--accent);color:white;border-radius:8px;font-size:13px;font-weight:600;text-decoration:none;transition:opacity 0.15s;">🖥️ Set Up My Worker →</a>
                                    <span style="font-size:11px;color:var(--text-muted);">Install once, then keep it running while generating</span>
                                </div>
                                <div style="margin-top:12px;display:flex;align-items:center;gap:10px;">
                                    <span style="font-size:13px;font-weight:600;color:var(--text);">Variants per clip:</span>
                                    <div class="seg" id="flowVariantsSeg" style="margin:0;">
                                        <button data-value="1" onclick="selectFlowVariants(this)">x1</button>
                                        <button data-value="2" class="active" onclick="selectFlowVariants(this)">x2</button>
                                        <button data-value="3" onclick="selectFlowVariants(this)">x3</button>
                                        <button data-value="4" onclick="selectFlowVariants(this)">x4</button>
                                    </div>
                                    <span style="font-size:11px;color:var(--text-muted);">How many video options Flow generates per clip</span>
                                </div>
                            </div>
                            <div id="backendHintAPI" class="backend-hint api-hint" style="display:none;">
                                <strong style="color:var(--success);">🔑 API</strong> — Add your Gemini API keys in <span onclick="openApiKeysModal()" style="color:var(--success);text-decoration:underline;cursor:pointer;font-weight:500;">API Keys settings</span> to get started.
                            </div>
                        </div>
                        
                        <!-- Language + Duration + Words/Line -->
                        <div class="cols-3">
                            <div class="group">
                                <div class="lbl">Language</div>
                                <select id="language">
                                    <option>English</option>
                                    <option>Italian</option>
                                    <option>Spanish</option>
                                    <option>French</option>
                                    <option>German</option>
                                </select>
                            </div>
                            <div class="group">
                                <div class="lbl">Duration</div>
                                <select id="duration">
                                    <option value="8">8 seconds</option>
                                    <option value="6">6 seconds</option>
                                    <option value="4">4 seconds</option>
                                </select>
                            </div>
                            <div class="group">
                                <div class="lbl">Words / Line</div>
                                <input type="number" id="wordsPerLine" min="10" max="35" value="21" 
                                    style="text-align:center;" oninput="debounceWordsPerLine()">
                            </div>
                        </div>
                        
                        <!-- Aspect Ratio + Resolution -->
                        <div class="cols-2">
                            <div class="group">
                                <div class="lbl">Aspect Ratio</div>
                                <div class="seg" id="aspectSeg">
                                    <button data-value="16:9" onclick="selectAspectSeg(this)">16:9</button>
                                    <button class="active" data-value="9:16" onclick="selectAspectSeg(this)">9:16</button>
                                </div>
                            </div>
                            <div class="group">
                                <div class="lbl">Resolution</div>
                                <div class="seg" id="resSeg">
                                    <button class="active" data-value="720p" onclick="selectResSeg(this)">720p HD</button>
                                    <button data-value="1080p" onclick="selectResSeg(this)">1080p Full HD</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Interpolation + AI Prompts -->
                        <div class="cols-2">
                            <div class="group" id="interpToggleRow">
                                <div class="lbl">Interpolation
                                    <span class="info-icon">?
                                        <div class="tooltip">
                                            <h5>🎬 Interpolation</h5>
                                            <p>Uses AI to generate smooth motion between frames.</p>
                                            <ul>
                                                <li><strong>1 image + ON:</strong> Natural talking motion</li>
                                                <li><strong>Multiple + ON:</strong> Smooth transitions</li>
                                                <li><strong>OFF:</strong> Static/minimal motion</li>
                                            </ul>
                                            <p style="color:var(--success);">✓ Recommended: Keep ON</p>
                                            <p style="color:var(--text-muted);font-size:11px;margin-top:8px;">📌 In Storyboard mode, this is controlled per-scene.</p>
                                        </div>
                                    </span>
                                </div>
                                <div class="seg" id="interpSeg">
                                    <button class="active" data-value="true" onclick="selectInterpSeg(this)">On</button>
                                    <button data-value="false" onclick="selectInterpSeg(this)">Off</button>
                                </div>
                            </div>
                            <div class="group">
                                <div class="lbl">AI Prompts
                                    <span class="info-icon">?
                                        <div class="tooltip">
                                            <h5>🤖 AI Prompts</h5>
                                            <p>Let AI analyze images and optimize prompts.</p>
                                            <ul>
                                                <li><strong>Visual analysis:</strong> Camera, lighting, scene</li>
                                                <li><strong>Voice profile:</strong> Matches subject</li>
                                                <li><strong>Gestures:</strong> Natural movements</li>
                                            </ul>
                                            <p style="color:var(--text-muted);">Turn OFF to write custom prompt.</p>
                                        </div>
                                    </span>
                                </div>
                                <div class="seg" id="aiSeg">
                                    <button class="active" data-value="true" onclick="selectAISeg(this)">On</button>
                                    <button data-value="false" onclick="selectAISeg(this)">Off</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Generation Mode Selector -->
                        <div class="group" id="generationModeRow" style="display:none;">
                            <div class="lbl">Generation Mode
                                <span class="info-icon">?
                                    <div class="tooltip">
                                        <h5>⚡ Generation Mode</h5>
                                        <p>Choose how clips are processed:</p>
                                        <ul>
                                            <li><strong>🔀 Smart (Staggered):</strong> Odd clips (1,3,5) first in parallel, then even clips (2,4) use confirmed frames.</li>
                                            <li><strong>⚡ Fast (Parallel):</strong> All clips at once. Fastest, but may have gaps.</li>
                                            <li><strong>🔗 Safe (Sequential):</strong> One at a time. Slowest but most reliable.</li>
                                        </ul>
                                    </div>
                                </span>
                            </div>
                            <select id="generationMode" style="width:100%;">
                                <option value="staggered" selected>🔀 Smart (Staggered) - Fast with smooth transitions</option>
                                <option value="parallel">⚡ Fast (Parallel) - May have transition gaps</option>
                                <option value="sequential">🔗 Safe (Sequential) - Guaranteed smooth transitions</option>
                            </select>
                        </div>
                        
                        <!-- Hidden inputs -->
                        <input type="hidden" id="exportFramesStart" value="0">
                        <input type="hidden" id="exportFramesEnd" value="7">
                        <input type="hidden" id="togSmartTrim" data-value="true">
                        
                        <div id="contextSection">
                            <label>Context for AI <span style="font-weight:400;text-transform:none;letter-spacing:normal;color:var(--text-muted);">(optional)</span>
                                <span class="info-icon">?
                                    <div class="tooltip">
                                        <h5>📝 Context for AI</h5>
                                        <p>Optionally add details the AI can't see in the image:</p>
                                        <ul>
                                            <li>Speaker's profession or role</li>
                                            <li>Mood or tone (serious, friendly, urgent)</li>
                                            <li>Setting context (indoor, outdoor, studio)</li>
                                            <li>Voice style preferences</li>
                                            <li>Any relevant backstory</li>
                                        </ul>
                                        <p style="color:var(--text-muted);margin-top:8px;">Leave empty to let AI analyze the image only.</p>
                                    </div>
                                </span>
                            </label>
                            <textarea id="contextInput" placeholder="Optional: e.g., Speaker is a medical doctor explaining a diagnosis, professional and reassuring tone, clinic setting..." style="min-height:50px;"></textarea>
                        </div>
                    </div>
                </div>
                
                <!-- Storyboard Mode: Auto-distributes images across lines -->
                <div id="storyboardContainer" class="storyboard-container card">
                    <div class="storyboard-header">
                        <h3>🎬 Script Editor</h3>
                        <div style="display:flex;align-items:center;gap:12px;">
                            <!-- Auto-split toggle -->
                            <div style="display:flex;align-items:center;gap:6px;">
                                <span style="font-size:11px;color:var(--text-muted);">✂️ Auto-split</span>
                                <div class="toggle active" id="autoSplitToggleStoryboard" onclick="toggleAutoSplit()" title="ON: Auto-split into ~7s clips | OFF: Each line = 1 clip"></div>
                            </div>
                            <div class="storyboard-mode-toggle">
                                <button id="btnAutoCycle" class="mode-btn active" onclick="setEditorMode('auto')" title="Images cycle through clips automatically">
                                    🔄 Auto-Cycle
                                </button>
                                <button id="btnStoryboard" class="mode-btn" onclick="setEditorMode('storyboard')" title="Drag images to create scene breaks">
                                    🎬 Storyboard
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="storyboard-mode-hint" id="modeHint">
                        <span id="modeHintText">🔄 Images cycle automatically: Clip 1→Image 1, Clip 2→Image 2, Clip 3→Image 3, Clip 4→Image 1...</span>
                    </div>
                    
                    <div class="storyboard-main">
                        <div class="storyboard-sidebar" id="storyboardSidebar">
                            <!-- Image thumbnails with line ranges -->
                        </div>
                        
                        <div class="storyboard-editor-col">
                            <div id="richEditor" 
                                 class="storyboard-editor" 
                                 contenteditable="true"
                                 oninput="syncFromRichEditor()"
                                 onpaste="handleRichEditorPaste(event)"
                                 ondragover="handleEditorDragOver(event)"
                                 ondragleave="handleEditorDragLeave(event)"
                                 ondrop="handleEditorDrop(event)">
                            </div>
                        </div>
                    </div>
                    
                    <div class="storyboard-summary" id="storyboardSummary">
                        <!-- Generated dynamically -->
                    </div>
                </div>
                
                <!-- Simple Mode: Separate dialogue section -->
                <div class="card" id="simpleDialogueSection">
                    <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span class="section-step">3</span>
                            Dialogue Script
                            <span class="info-icon">?
                                <div class="tooltip">
                                    <h5>✍️ Dialogue Lines</h5>
                                    <p><strong>Auto-split ON:</strong> Paste your script and it auto-splits into ~7 second clips based on language speaking rate.</p>
                                    <p><strong>Auto-split OFF:</strong> Each line you paste or type = 1 clip. Press Enter to create a new clip.</p>
                                    <p style="color:var(--text-muted);font-size:10px;margin-top:6px;">Toggle auto-split with the switch →</p>
                                </div>
                            </span>
                        </div>
                        <!-- Auto-split toggle inline with title -->
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="font-size:11px;color:var(--text-muted);">✂️ Auto-split</span>
                            <div class="toggle active" id="autoSplitToggle" onclick="toggleAutoSplit()" title="ON: Auto-split into ~7s clips | OFF: Each line = 1 clip"></div>
                        </div>
                    </div>
                    <div id="simpleEditorContainer" class="simple-editor-container">
                        <div id="simpleRichEditor" 
                             class="simple-rich-editor" 
                             contenteditable="true"
                             oninput="syncFromSimpleEditor()"
                             onpaste="handleSimpleEditorPaste(event)"
                             onkeydown="handleSimpleEditorKeydown(event)">
                        </div>
                    </div>
                    <textarea id="dialogueInput" style="display:none;"></textarea>
                    <div id="splitStatus" style="font-size:11px;color:var(--text-muted);margin-top:8px;display:none;"></div>
                    <div id="lineValidation" style="margin-top:10px;display:none;"></div>
                </div>
                
                <div class="card" id="customPromptSection" style="display:none;">
                    <div class="card-title">Custom Visual Prompt</div>
                    <textarea id="customPrompt" placeholder="Describe the visual style, camera movement, and scene details...

Example: A realistic vertical video of a professional presenter speaking directly to camera. Medium close-up shot, soft studio lighting, neutral background."></textarea>
                    <p class="tip-text"><strong>Tips:</strong> Describe camera angle, lighting, subject behavior, background, mood.</p>
                </div>
                
                <div class="generate-container">
                    <button class="btn btn-primary btn-start" id="startBtn" onclick="createJob()">🚀 Start Generation</button>
                </div>
                
                <div class="card" id="jobsCard" style="display:none;">
                    <div class="card-title">📋 Jobs</div>
                    <div class="jobs-list" id="jobsList"><div class="empty"><h3>No jobs yet</h3></div></div>
                </div>
            </div>
            
            <div class="results-panel">
                <div class="card">
                    <div class="card-title" style="display:flex;justify-content:space-between;align-items:center;">
                        <span>
                            <span class="section-step">4</span>
                            Review & Approve
                            <span class="info-icon">?
                                <div class="tooltip">
                                    <h5>✅ Review & Approve</h5>
                                    <p>Watch each generated clip and review.</p>
                                    <ul>
                                        <li>Use <strong>◀ ▶</strong> to browse variants</li>
                                        <li>Click <strong>✓</strong> to approve</li>
                                        <li>Click <strong>↻</strong> to regenerate</li>
                                        <li>Click <strong>🗑</strong> to delete</li>
                                    </ul>
                                    <p style="color:var(--success);">📥 Once all approved, click Download!</p>
                                </div>
                            </span>
                        </span>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <div id="jobActions"></div>
                            <button class="btn btn-secondary btn-sm" onclick="collapseResults()" title="Collapse panel" style="padding:6px 10px;">✕</button>
                        </div>
                    </div>
                    <div id="noJob" class="empty"><h3>Select a job to view details</h3><p>Jobs appear here after generation starts</p></div>
                    <div id="jobDetails" style="display:none;">
                        <div id="jobInfo"></div>
                        <div id="clipsList"></div>
                        <div class="logs" id="logs"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============================================================================
        // Authentication
        // =============================================================================
        let currentUser = null;
        
        async function checkAuth() {
            try {
                const response = await fetch('/auth/me');
                if (response.status === 401) {
                    window.location.href = '/login';
                    return false;
                }
                const data = await response.json();
                currentUser = data.user;
                showUserInfo(currentUser);
                
                // Load API keys FIRST so onboarding can detect them
                if (typeof loadApiKeys === 'function') {
                    console.log('[Auth] Calling loadApiKeys...');
                    await loadApiKeys();
                    console.log('[Auth] loadApiKeys done. userApiKeys:', typeof userApiKeys, Array.isArray(userApiKeys) ? userApiKeys.length : 'N/A');
                } else {
                    console.log('[Auth] loadApiKeys not yet defined!');
                }
                
                // Show tutorial on first visit + start onboarding (keys are now loaded)
                setTimeout(() => {
                    if (typeof checkShowTutorial === 'function') checkShowTutorial();
                    if (typeof checkShowOnboarding === 'function') checkShowOnboarding();
                }, 600);
                return true;
            } catch (error) {
                console.error('Auth check failed:', error);
                window.location.href = '/login';
                return false;
            }
        }
        
        function showUserInfo(user) {
            const userMenu = document.getElementById('userMenu');
            const userAvatar = document.getElementById('userAvatar');
            const userInitial = document.getElementById('userInitial');
            const userName = document.getElementById('userName');
            const userNameFull = document.getElementById('userNameFull');
            const userEmail = document.getElementById('userEmail');
            
            if (!user) return;
            
            // Show user menu
            userMenu.style.display = 'block';
            
            // Set avatar
            if (user.picture) {
                userAvatar.innerHTML = `<img src="${user.picture}" alt="${user.name || 'User'}">`;
            } else {
                const initial = (user.name || user.email || '?')[0].toUpperCase();
                userInitial.textContent = initial;
            }
            
            // Set names
            const displayName = user.name || user.email.split('@')[0];
            userName.textContent = displayName;
            userNameFull.textContent = user.name || 'User';
            userEmail.textContent = user.email;
        }
        
        function toggleUserDropdown() {
            const dropdown = document.getElementById('userDropdown');
            dropdown.classList.toggle('show');
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const userMenu = document.getElementById('userMenu');
            const dropdown = document.getElementById('userDropdown');
            if (userMenu && !userMenu.contains(e.target)) {
                dropdown.classList.remove('show');
            }
        });
        
        async function logout() {
            try {
                await fetch('/auth/logout', { method: 'POST' });
            } catch (e) { }
            window.location.href = '/login';
        }
        
        // Check auth on page load
        checkAuth();
        
        // =============================================================================
        // API Keys Management
        // =============================================================================
        let userApiKeys = [];
        
        function openApiKeysModal() {
            document.getElementById('userDropdown').classList.remove('show');
            document.getElementById('apiKeysModal').classList.add('show');
            loadApiKeys();
        }
        
        function closeApiKeysModal() {
            document.getElementById('apiKeysModal').classList.remove('show');
        }
        
        // Close modal when clicking overlay
        document.getElementById('apiKeysModal')?.addEventListener('click', function(e) {
            if (e.target === this) closeApiKeysModal();
        });
        
        async function loadApiKeys() {
            try {
                const res = await fetch('/api/user/keys');
                if (!res.ok) throw new Error('Failed to load keys');
                const data = await res.json();
                userApiKeys = data.keys;
                userApiKeysSummary = data.summary || {};
                console.log('[LoadApiKeys] Loaded', userApiKeys.length, 'keys. has_keys:', data.has_keys, 'count:', data.count);
                renderApiKeysList();
            } catch (e) {
                console.error('Failed to load API keys:', e);
            }
        }
        
        let userApiKeysSummary = {};
        
        function renderApiKeysList() {
            const list = document.getElementById('apiKeysList');
            const empty = document.getElementById('emptyKeysMessage');
            const summaryEl = document.getElementById('apiKeysSummary');
            
            // Update summary
            if (summaryEl && userApiKeysSummary) {
                const s = userApiKeysSummary;
                if (s.total > 0) {
                    summaryEl.innerHTML = `
                        <div class="keys-summary">
                            <div class="keys-summary-item working"><span class="count">${s.working || 0}</span><span class="label">Working</span></div>
                            <div class="keys-summary-item rate-limited"><span class="count">${s.rate_limited || 0}</span><span class="label">Rate Limited</span></div>
                            <div class="keys-summary-item invalid"><span class="count">${s.invalid || 0}</span><span class="label">Invalid</span></div>
                        </div>
                        <button class="btn btn-secondary btn-sm" onclick="revalidateAllKeys()" style="margin-top:12px;width:100%;">🔄 Re-check All Keys</button>
                    `;
                    summaryEl.style.display = 'block';
                } else {
                    summaryEl.style.display = 'none';
                }
            }
            
            if (userApiKeys.length === 0) {
                list.innerHTML = '';
                list.appendChild(empty.cloneNode(true));
                return;
            }
            
            const statusIcons = {
                'working': '✅',
                'rate_limited': '⚠️',
                'invalid': '❌',
                'unknown': '❓'
            };
            
            const statusLabels = {
                'working': 'Working',
                'rate_limited': 'Rate Limited',
                'invalid': 'Invalid',
                'unknown': 'Unknown'
            };
            
            list.innerHTML = userApiKeys.map(key => {
                const status = key.key_status || (key.is_valid ? 'working' : 'invalid');
                const icon = statusIcons[status] || '❓';
                const label = statusLabels[status] || status;
                
                return `
                <div class="api-key-item status-${status} ${key.is_active ? '' : 'inactive'}">
                    <div class="api-key-info">
                        <div class="api-key-name">Key ...${key.key_suffix}</div>
                        <div class="api-key-status status-${status}">
                            ${icon} ${label}
                            ${key.is_active ? '' : ' • Disabled'}
                        </div>
                    </div>
                    <div class="api-key-actions">
                        <button onclick="revalidateKey(${key.id})" title="Re-check">🔄</button>
                        <button onclick="toggleApiKey(${key.id})" title="${key.is_active ? 'Disable' : 'Enable'}">
                            ${key.is_active ? '⏸️' : '▶️'}
                        </button>
                        <button class="delete" onclick="deleteApiKey(${key.id})" title="Delete">🗑️</button>
                    </div>
                </div>
            `}).join('');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function revalidateKey(keyId) {
            try {
                const res = await fetch(`/api/user/keys/${keyId}/revalidate`, { method: 'POST' });
                const data = await res.json();
                
                if (!res.ok) {
                    alert(data.detail || 'Failed to revalidate key');
                    return;
                }
                
                await loadApiKeys();
            } catch (e) {
                alert('Failed to revalidate key');
            }
        }
        
        async function revalidateAllKeys() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '⏳ Checking...';
            btn.disabled = true;
            
            try {
                const res = await fetch('/api/user/keys/revalidate-all', { method: 'POST' });
                const data = await res.json();
                
                if (!res.ok) {
                    alert(data.detail || 'Failed to revalidate keys');
                    return;
                }
                
                await loadApiKeys();
                alert(data.message);
            } catch (e) {
                alert('Failed to revalidate keys');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }
        
        async function addSingleApiKey() {
            const input = document.getElementById('newApiKeyInput');
            const addBtn = document.querySelector('.add-key-input .btn-primary');
            const key = input.value.trim();
            
            if (!key) {
                alert('Please enter an API key');
                return;
            }
            
            // Show loading state with text
            const originalBtnText = addBtn?.innerHTML || 'Add';
            if (addBtn) {
                addBtn.innerHTML = '⏳ Validating...';
                addBtn.disabled = true;
                addBtn.style.minWidth = '100px';
            }
            
            try {
                const res = await fetch('/api/user/keys', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ key })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    alert(data.detail || 'Failed to add key');
                    return;
                }
                
                input.value = '';
                await loadApiKeys();
                
                // Show validation result
                if (data.message) {
                    // Could show a toast here instead
                }
            } catch (e) {
                alert('Failed to add API key');
            } finally {
                if (addBtn) {
                    addBtn.innerHTML = 'Add';
                    addBtn.disabled = false;
                }
            }
        }
        
        async function addBulkApiKeys() {
            const textarea = document.getElementById('bulkApiKeysInput');
            const lines = textarea.value.split('\n').map(l => l.trim()).filter(l => l);
            
            if (lines.length === 0) {
                alert('Please paste at least one API key');
                return;
            }
            
            try {
                const res = await fetch('/api/user/keys/bulk', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ keys: lines })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    alert(data.detail || 'Failed to add keys');
                    return;
                }
                
                textarea.value = '';
                alert(data.message);
                await loadApiKeys();
            } catch (e) {
                alert('Failed to add API keys');
            }
        }
        
        async function toggleApiKey(keyId) {
            try {
                const res = await fetch(`/api/user/keys/${keyId}/toggle`, { method: 'PUT' });
                if (!res.ok) throw new Error('Failed to toggle key');
                await loadApiKeys();
            } catch (e) {
                alert('Failed to toggle API key');
            }
        }
        
        async function deleteApiKey(keyId) {
            if (!confirm('Delete this API key?')) return;
            
            try {
                const res = await fetch(`/api/user/keys/${keyId}`, { method: 'DELETE' });
                if (!res.ok) throw new Error('Failed to delete key');
                await loadApiKeys();
            } catch (e) {
                alert('Failed to delete API key');
            }
        }
        
        // =============================================================================
        // Application State
        // =============================================================================
        let uploadJobId=null, uploadedImages=[], uploadedFilesData=[], selectedJobId=null, lastLogId=0, clipStates={}, hasJobs=false;
        let preUploadedVoiceSample = null; // Pre-uploaded voice for cloning
        let selectedVoiceClipsPerJob = {}; // Per-job: {jobId: [{filename, index, jobId}]}
        
        // Export metadata persistence
        function saveExportMetadata(filename, metadata) {
            try {
                const key = `export_meta_${filename}`;
                localStorage.setItem(key, JSON.stringify(metadata));
            } catch (e) { console.warn('Failed to save export metadata:', e); }
        }
        
        function getExportMetadata(filename) {
            try {
                const key = `export_meta_${filename}`;
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : null;
            } catch (e) { return null; }
        }
        
        let lastFrameIndex = null; // Index of image to use as last frame (end of video)
        const API='/api';
        
        function setActiveState(){ const c=document.getElementById('appContainer'); if(!c.classList.contains('state-active')){ c.classList.remove('state-initial'); c.classList.add('state-active'); } document.getElementById('jobsCard').style.display='block'; }
        function collapseResults(){ 
            const c=document.getElementById('appContainer'); 
            c.classList.remove('state-active'); 
            c.classList.add('state-initial'); 
            selectedJobId=null;
            document.querySelectorAll('.job-item').forEach(el=>el.classList.remove('selected'));
            // Clear form for new job
            uploadJobId=null;uploadedImages=[];uploadedFilesData=[];
            document.getElementById('uploadedCount').textContent='';
            document.getElementById('imageThumbnails').innerHTML='';
            document.getElementById('dialogueInput').value='';
            document.getElementById('contextInput').value='';
            document.getElementById('lineValidation').style.display='none';
            document.getElementById('splitStatus').style.display='none';
            // Reset file input (important for re-uploading same files)
            document.getElementById('fileInput').value='';
            // Reset simple editor
            renderSimpleEditor();
            // Reset storyboard
            sceneBreaks = [];
            lastFrameIndex = null;
            editorMode = 'auto';
            updateUIMode();
        }
        
        // Position tooltips to stay within viewport
        document.querySelectorAll('.info-icon').forEach(icon => {
            icon.addEventListener('mouseenter', function() {
                const tooltip = this.querySelector('.tooltip');
                if (!tooltip) return;
                
                const iconRect = this.getBoundingClientRect();
                const tooltipWidth = 300;
                const padding = 16;
                
                // Calculate horizontal position - prefer right of icon, but stay in viewport
                let left = iconRect.right + 8;
                if (left + tooltipWidth > window.innerWidth - padding) {
                    // Would overflow right - try left side
                    left = iconRect.left - tooltipWidth - 8;
                    if (left < padding) {
                        // Still overflow - center in viewport
                        left = Math.max(padding, (window.innerWidth - tooltipWidth) / 2);
                    }
                }
                
                // Calculate vertical position - below icon, but stay in viewport
                let top = iconRect.bottom + 8;
                
                // Apply position
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
                tooltip.style.bottom = 'auto';
                
                // Check if it overflows bottom and adjust
                requestAnimationFrame(() => {
                    const tooltipRect = tooltip.getBoundingClientRect();
                    if (tooltipRect.bottom > window.innerHeight - padding) {
                        // Move above the icon instead
                        tooltip.style.top = 'auto';
                        tooltip.style.bottom = (window.innerHeight - iconRect.top + 8) + 'px';
                    }
                });
            });
        });
        
        // Speaking rates (words per second) by language - MUST BE DEFINED EARLY
        const SPEAKING_RATES = {
            "English": 2.5, "Italian": 2.8, "Spanish": 2.8, "French": 2.5, "German": 2.2,
            "Portuguese": 2.7, "Dutch": 2.4, "Polish": 2.3, "Russian": 2.2,
            "Japanese": 3.0, "Korean": 3.0, "Chinese": 3.2, "Arabic": 2.3, "Hindi": 2.6, "Turkish": 2.5
        };
        
        function selectAspectSeg(el){ document.querySelectorAll('#aspectSeg button').forEach(b=>b.classList.remove('active')); el.classList.add('active'); }
        function getSelectedAspect(){ const a=document.querySelector('#aspectSeg button.active'); return a?a.dataset.value:'9:16'; }
        function selectResSeg(el){ document.querySelectorAll('#resSeg button').forEach(b=>b.classList.remove('active')); el.classList.add('active'); }

        function selectBackend(el){ 
            document.querySelectorAll('#backendToggle button').forEach(b=>b.classList.remove('active')); 
            el.classList.add('active');
            const val = el.dataset.value;
            document.getElementById('backendHintFlow').style.display = val === 'flow' ? 'block' : 'none';
            document.getElementById('backendHintAPI').style.display = val === 'api' ? 'block' : 'none';
        }
        function selectFlowVariants(el){
            document.querySelectorAll('#flowVariantsSeg button').forEach(b=>b.classList.remove('active'));
            el.classList.add('active');
        }
        function getFlowVariantsCount(){
            const a=document.querySelector('#flowVariantsSeg button.active');
            return a ? parseInt(a.dataset.value) : 2;
        }
        function selectInterpSeg(el){ document.querySelectorAll('#interpSeg button').forEach(b=>b.classList.remove('active')); el.classList.add('active'); }
        function selectAISeg(el){ document.querySelectorAll('#aiSeg button').forEach(b=>b.classList.remove('active')); el.classList.add('active'); }
        function getSelectedResolution(){ const a=document.querySelector('#resSeg button.active'); return a?a.dataset.value:'720p'; }
        
        // Debounce timer for words per line input
        let wordsPerLineTimer = null;
        function debounceWordsPerLine() {
            clearTimeout(wordsPerLineTimer);
            wordsPerLineTimer = setTimeout(() => {
                updateWordsPerLine();
            }, 300);
        }
        
        // Punctuation for natural breaks (duplicated here for early access)
        const HARD_STOPS_EARLY = ['.', '!', '?', '。', '！', '？', '।'];
        const SOFT_STOPS_EARLY = [',', ';', ':', '—', '–', '-', '،', '、', ')'];
        
        // Words per line - update and re-split when value changes
        function updateWordsPerLine() {
            const dialogueInput = document.getElementById('dialogueInput');
            if (!dialogueInput || !dialogueInput.value.trim()) return;
            
            // Check if auto-split is enabled - if OFF, don't resplit
            const autoSplitEnabled = isAutoSplitEnabled();
            if (!autoSplitEnabled) {
                console.log(`[updateWordsPerLine] Auto-split is OFF, skipping re-split`);
                return;
            }
            
            // Get the target words from input
            const targetWords = parseInt(document.getElementById('wordsPerLine')?.value) || 18;
            console.log(`[updateWordsPerLine] Target: ${targetWords} words`);
            
            // Get the raw text (remove line numbers if present)
            const currentText = dialogueInput.value.trim();
            const lines = currentText.split('\n').filter(l => l.trim());
            
            // Extract raw text by removing line numbers
            const rawText = lines.map(l => l.replace(/^\d+\|/, '').trim()).filter(l => l).join(' ');
            
            if (rawText.length < 20) return;
            
            // Split the raw text into words
            const words = rawText.split(/\s+/).filter(w => w);
            const totalWords = words.length;
            
            // Get current language and weak words set
            const lang = document.getElementById('language').value || 'English';
            const weakWordsSet = WEAK_WORDS[lang] || WEAK_WORDS["English"] || new Set();
            
            // Helper to check if a word is weak
            const isWeakWord = (word) => {
                if (!word) return false;
                const cleanWord = word.replace(/[.,!?;:'")\]—–-]+$/, '').toLowerCase();
                return weakWordsSet.has(cleanWord);
            };
            
            console.log(`[updateWordsPerLine] Total words: ${totalWords}, Target per line: ${targetWords}, Language: ${lang}`);
            
            // Smart split with punctuation awareness AND weak word avoidance
            const newLines = [];
            let startIdx = 0;
            
            while (startIdx < words.length) {
                const remaining = words.length - startIdx;
                
                // If remaining fits in one line, take it all
                if (remaining <= targetWords + 2) {
                    newLines.push(words.slice(startIdx).join(' '));
                    break;
                }
                
                let splitIdx = null;
                
                // Helper to get word at position relative to target
                const getWordAt = (offset) => {
                    const idx = startIdx + targetWords + offset - 1;
                    if (idx >= startIdx && idx < words.length) {
                        return { word: words[idx], idx: idx };
                    }
                    return null;
                };
                
                const hasHardStop = (w) => w && HARD_STOPS_EARLY.some(s => w.word.endsWith(s));
                const hasSoftStop = (w) => w && SOFT_STOPS_EARLY.some(s => w.word.endsWith(s));
                
                // Priority 1: HARD STOP at target+2, +1, -1, -2 (skip weak words)
                for (const offset of [2, 1, -1, -2]) {
                    const w = getWordAt(offset);
                    if (hasHardStop(w) && !isWeakWord(w.word)) {
                        splitIdx = w.idx + 1;
                        console.log(`[updateWordsPerLine] HARD STOP at ${offset}: "${w.word}"`);
                        break;
                    }
                }
                
                // Priority 2: SOFT STOP at target+2, +1, -1, -2 (skip weak words)
                if (splitIdx === null) {
                    for (const offset of [2, 1, -1, -2]) {
                        const w = getWordAt(offset);
                        if (hasSoftStop(w) && !isWeakWord(w.word)) {
                            splitIdx = w.idx + 1;
                            console.log(`[updateWordsPerLine] SOFT STOP at ${offset}: "${w.word}"`);
                            break;
                        }
                    }
                }
                
                // Priority 3: Find best non-weak word in range ±2
                if (splitIdx === null) {
                    for (const offset of [0, 1, -1, 2, -2]) {
                        const w = getWordAt(offset);
                        if (w && !isWeakWord(w.word)) {
                            splitIdx = w.idx + 1;
                            console.log(`[updateWordsPerLine] Best non-weak at ${offset}: "${w.word}"`);
                            break;
                        }
                    }
                }
                
                // Priority 4: Last resort - split at target even if weak
                if (splitIdx === null) {
                    splitIdx = Math.min(startIdx + targetWords, words.length);
                    console.log(`[updateWordsPerLine] Fallback to target`);
                }
                
                // Take the chunk
                const chunk = words.slice(startIdx, splitIdx).join(' ');
                newLines.push(chunk);
                startIdx = splitIdx;
            }
            
            // Format with line numbers
            const formatted = newLines.map((line, i) => `${i + 1}|${line}`).join('\n');
            
            // Update the hidden textarea
            dialogueInput.value = formatted;
            
            // Re-render the appropriate editor based on mode
            if (isStoryboardMode()) {
                // Storyboard mode - use renderStoryboardWithLines to avoid re-splitting
                renderStoryboardWithLines(newLines);
            } else {
                // Simple mode - render the styled editor
                renderSimpleEditor();
            }
            
            console.log(`[updateWordsPerLine] Updated editor with ${newLines.length} lines (storyboard: ${isStoryboardMode()})`);
            
            // Update validation
            validateDialogueLines();
            
            // Show status
            const status = document.getElementById('splitStatus');
            if(status){
                status.style.display = 'block';
                status.textContent = `✓ Split into ${newLines.length} clips (~${targetWords} words/line)`;
                status.style.color = 'var(--success)';
                setTimeout(() => { status.style.display = 'none'; }, 3000);
            }
            
            console.log(`[updateWordsPerLine] Done - ${newLines.length} lines created`);
        }
        
        // Set default words per line based on language
        function setLanguageDefaults() {
            const lang = document.getElementById('language').value;
            const wordsPerSec = SPEAKING_RATES[lang] || 2.5;
            
            // Language-specific defaults (based on testing)
            const languageDefaults = {
                "English": 21,
                "Italian": 20,
                "Spanish": 20,
                "French": 18,
                "German": 16
            };
            
            // Use specific default if available, otherwise calculate
            const defaultWords = languageDefaults[lang] || Math.round(wordsPerSec * 7);
            
            // Always reset to language default
            document.getElementById('wordsPerLine').value = defaultWords;
            
            console.log(`[Language] Changed to ${lang}, reset words per line to ${defaultWords}`);
            
            // Check if auto-split is enabled
            const autoSplitEnabled = isAutoSplitEnabled();
            
            if (autoSplitEnabled) {
                // Re-split with new language settings
                updateWordsPerLine();
            } else {
                // Auto-split is OFF - just show a message, don't resplit
                const status = document.getElementById('splitStatus');
                if(status){
                    status.style.display = 'block';
                    status.textContent = `ℹ️ Language: ${lang} (auto-split OFF - lines unchanged)`;
                    status.style.color = 'var(--accent)';
                    setTimeout(() => { status.style.display = 'none'; }, 3000);
                }
                console.log(`[Language] Auto-split is OFF, not re-splitting`);
            }
        }
        
        // Add language change listener
        document.getElementById('language').addEventListener('change', setLanguageDefaults);
        
        // Get export settings (defaults - modal will override)
        function getExportSettings() {
            const startVal = parseInt(document.getElementById('exportFramesStart')?.value);
            const endVal = parseInt(document.getElementById('exportFramesEnd')?.value);
            return {
                frames_to_cut_start: isNaN(startVal) ? 0 : startVal,
                frames_to_cut_end: isNaN(endVal) ? 7 : endVal,  // Default 7 to remove morph artifacts
                smart_trim: document.getElementById('togSmartTrim')?.dataset?.value === 'true'
            };
        }
        
        const uploadArea=document.getElementById('uploadArea'), fileInput=document.getElementById('fileInput');
        uploadArea.onclick=()=>fileInput.click();
        uploadArea.ondragover=e=>{e.preventDefault();uploadArea.style.borderColor='var(--accent)'};
        uploadArea.ondragleave=()=>uploadArea.style.borderColor='';
        uploadArea.ondrop=async e=>{e.preventDefault();uploadArea.style.borderColor='';await upload(Array.from(e.dataTransfer.files))};
        fileInput.onchange=async e=>await upload(Array.from(e.target.files));
        
        async function upload(files){
            if(!files.length)return;
            
            // Show loading state
            uploadArea.classList.add('uploading');
            const loadingText = uploadArea.querySelector('.upload-loading-text');
            if(loadingText) loadingText.textContent = `Uploading ${files.length} image${files.length > 1 ? 's' : ''}...`;
            
            try {
                const fd=new FormData();
                files.forEach(f=>fd.append('files',f));
                if(uploadJobId)fd.append('job_id',uploadJobId);
                const r=await fetch(`${API}/upload`,{method:'POST',body:fd});
                const d=await r.json();
                uploadJobId=d.job_id;
                uploadedImages=uploadedImages.concat(d.uploaded);
                
                // Load files in order using server-provided indices
                const baseIndex = uploadedFilesData.length;
                const loadPromises = files.map((f, fileIdx) => {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            // Find the server response for this file to get the correct index
                            const serverInfo = d.uploaded.find(u => u.original_filename === f.name);
                            const actualIndex = serverInfo ? serverInfo.index : (baseIndex + fileIdx);
                            resolve({
                                name: serverInfo ? serverInfo.filename : f.name,
                                originalName: f.name,
                                dataUrl: e.target.result,
                                index: actualIndex
                            });
                        };
                        reader.readAsDataURL(f);
                    });
                });
                
                // Wait for all files to load, then add them in correct order
                const loadedFiles = await Promise.all(loadPromises);
                loadedFiles.sort((a, b) => a.index - b.index);
                uploadedFilesData = uploadedFilesData.concat(loadedFiles);
                updateUIMode();
                
                document.getElementById('uploadedCount').textContent=uploadedImages.length?`✓ ${uploadedImages.length} image${uploadedImages.length>1?'s':''} uploaded`:'';
            } catch(e) {
                console.error('Upload error:', e);
                alert('Upload failed: ' + e.message);
            } finally {
                // Hide loading state
                uploadArea.classList.remove('uploading');
                if(loadingText) loadingText.textContent = 'Uploading...';
                // CRITICAL: Reset file input to allow re-uploading same files or adding more
                document.getElementById('fileInput').value = '';
            }
        }
        
        function renderThumbnails(){
            document.getElementById('imageThumbnails').innerHTML=uploadedFilesData.map((f,i)=>`<div class="image-thumb" data-index="${i}" title="${f.name}"><img src="${f.dataUrl}" alt="${f.name}"><div class="thumb-index">${i+1}</div><div class="thumb-remove" onclick="removeImage(${i})">✕</div></div>`).join('');
        }
        
        async function removeImage(i){
            // Get the filename before removing from local array
            const fileData = uploadedFilesData[i];
            const filename = fileData?.name || uploadedImages[i];
            
            // Delete from server first
            if(uploadJobId && filename){
                try {
                    const resp = await fetch(`${API}/upload/${uploadJobId}/image/${encodeURIComponent(filename)}`, {method: 'DELETE'});
                    if(!resp.ok){
                        console.error('Failed to delete image from server:', await resp.text());
                    } else {
                        console.log(`[removeImage] Deleted ${filename} from server`);
                    }
                } catch(e) {
                    console.error('Error deleting image:', e);
                }
            }
            
            // Remove from local arrays
            uploadedFilesData.splice(i,1);
            uploadedImages.splice(i,1);
            
            // Re-index remaining images to match server (0, 1, 2, ...)
            uploadedFilesData.forEach((f,j)=>f.index=j);
            
            document.getElementById('uploadedCount').textContent=uploadedImages.length?`✓ ${uploadedImages.length} image${uploadedImages.length>1?'s':''} uploaded`:'';
            
            // If all images removed, delete the upload folder and reset job ID
            if(uploadedImages.length === 0 && uploadJobId){
                try {
                    await fetch(`${API}/upload/${uploadJobId}`, {method: 'DELETE'});
                } catch(e) {}
                uploadJobId = null;
            }
            
            updateUIMode();
        }
        
        // === STORYBOARD MODE LOGIC ===
        let editorMode = 'auto'; // 'auto' = auto-cycle, 'storyboard' = manual scene breaks
        let sceneBreaks = []; // For storyboard mode: [{lineIndex: 0, imgIndex: 0}, ...]
        
        function isStoryboardMode(){
            return uploadedFilesData.length >= 2;
        }
        
        function setEditorMode(mode){
            console.log('[setEditorMode] Changing mode to:', mode);
            editorMode = mode;
            
            // Update toggle buttons
            document.getElementById('btnAutoCycle').classList.toggle('active', mode === 'auto');
            document.getElementById('btnStoryboard').classList.toggle('active', mode === 'storyboard');
            
            // Update hint text
            const hintText = document.getElementById('modeHintText');
            if(mode === 'auto'){
                hintText.textContent = '🔄 Images cycle automatically: Clip 1→Image 1, Clip 2→Image 2, Clip 3→Image 3, Clip 4→Image 1...';
            } else {
                hintText.textContent = '🎬 Drag images from sidebar into the text to create scene breaks. Each image covers all clips until the next break.';
            }
            
            // Show/hide generation mode selector
            // Only show for Auto-Cycle mode with multiple images
            updateGenerationModeVisibility();
            
            // Reset scene breaks when switching to storyboard
            if(mode === 'storyboard' && sceneBreaks.length === 0){
                // Initialize with first image at line 0, interpolation on by default
                sceneBreaks = [{ lineIndex: 0, imgIndex: 0, interpolate: true }];
            }
            
            renderStoryboard();
        }
        
        function updateGenerationModeVisibility(){
            // Show generation mode selector only for Auto-Cycle with multiple images
            const genModeRow = document.getElementById('generationModeRow');
            if(genModeRow){
                const shouldShow = editorMode === 'auto' && uploadedImages.length > 1;
                genModeRow.style.display = shouldShow ? 'flex' : 'none';
            }
        }
        
        function updateUIMode(){
            const storyboardMode = isStoryboardMode();
            const simpleImagesCard = document.getElementById('simpleImagesCard');
            const storyboardContainer = document.getElementById('storyboardContainer');
            const simpleDialogue = document.getElementById('simpleDialogueSection');
            const configPanel = document.querySelector('.config-panel');
            const interpToggleRow = document.getElementById('interpToggleRow');
            
            if(storyboardMode){
                simpleImagesCard.style.display = 'none';
                storyboardContainer.classList.add('active');
                simpleDialogue.style.display = 'none';
                if(configPanel) configPanel.classList.add('storyboard-active');
                // Disable global interpolation toggle - managed per-scene in Storyboard
                if(interpToggleRow) interpToggleRow.classList.add('disabled');
                renderStoryboard();
            } else {
                simpleImagesCard.style.display = 'block';
                storyboardContainer.classList.remove('active');
                simpleDialogue.style.display = 'block';
                if(configPanel) configPanel.classList.remove('storyboard-active');
                // Re-enable global interpolation toggle
                if(interpToggleRow) interpToggleRow.classList.remove('disabled');
                renderThumbnails();
                validateDialogueLines();
            }
            
            // Update generation mode visibility based on image count and mode
            updateGenerationModeVisibility();
        }
        
        function getDialogueLines(){
            const input = document.getElementById('dialogueInput').value.trim();
            const lines = input.split('\n').filter(l=>l.trim());
            return lines.filter(l=>/^\d+\|/.test(l.trim())).map(line=>{
                const parts = line.split('|');
                return { id: parseInt(parts[0]) || 0, text: parts.slice(1).join('|').trim() };
            });
        }
        
        // === SIMPLE RICH EDITOR (Single Image Mode) ===
        function renderSimpleEditor(){
            const editor = document.getElementById('simpleRichEditor');
            if(!editor) return;
            
            const dialogueInput = document.getElementById('dialogueInput');
            const text = dialogueInput.value.trim();
            const lines = text.split('\n').filter(l => l.trim());
            
            let htmlContent = '';
            
            if(lines.length > 0){
                lines.forEach((line, idx) => {
                    // Parse line number if present
                    let lineNum = idx + 1;
                    let lineText = line;
                    if(/^\d+\|/.test(line)){
                        const parts = line.split('|');
                        lineNum = parseInt(parts[0]) || idx + 1;
                        lineText = parts.slice(1).join('|');
                    }
                    htmlContent += `<div class="simple-line" data-line="${lineNum}">${lineText}</div>`;
                });
            } else {
                htmlContent = `<div class="simple-line placeholder-line" data-line=""></div>`;
            }
            
            editor.innerHTML = htmlContent;
        }
        
        function syncFromSimpleEditor(){
            const editor = document.getElementById('simpleRichEditor');
            if(!editor) return;
            
            const lines = editor.querySelectorAll('.simple-line');
            let allLines = [];
            
            lines.forEach((line, idx) => {
                const text = line.textContent.trim();
                if(text && !line.classList.contains('placeholder-line')){
                    allLines.push(`${idx + 1}|${text}`);
                }
            });
            
            document.getElementById('dialogueInput').value = allLines.join('\n');
            
            // Update line numbers in-place WITHOUT replacing innerHTML
            // This preserves cursor position
            clearTimeout(window.simpleEditorTimeout);
            window.simpleEditorTimeout = setTimeout(() => {
                updateSimpleEditorLineNumbers();
                validateDialogueLines();
            }, 800);
        }
        
        // Update only line numbers without replacing content
        function updateSimpleEditorLineNumbers(){
            const editor = document.getElementById('simpleRichEditor');
            if(!editor) return;
            
            const lines = editor.querySelectorAll('.simple-line');
            lines.forEach((line, idx) => {
                line.setAttribute('data-line', idx + 1);
                // Remove placeholder class if line has content
                if(line.textContent.trim()){
                    line.classList.remove('placeholder-line');
                }
            });
        }
        
        function handleSimpleEditorPaste(e){
            e.preventDefault();
            
            const editor = document.getElementById('simpleRichEditor');
            const clipboardData = e.clipboardData || window.clipboardData;
            const pastedText = clipboardData.getData('text/plain');
            
            if(!pastedText) return;
            
            const autoSplitEnabled = isAutoSplitEnabled();
            
            if(autoSplitEnabled) {
                // AUTO-SPLIT MODE: Combine all text into one, then split properly
                
                // Get existing lines
                const existingLines = [];
                editor.querySelectorAll('.simple-line').forEach((line) => {
                    const text = line.textContent.trim();
                    if(text && !line.classList.contains('placeholder-line')){
                        existingLines.push(text);
                    }
                });
                
                // Combine pasted text (join lines with space to make it continuous)
                const combinedPastedText = pastedText
                    .split('\n')
                    .map(l => l.trim())
                    .filter(l => l)
                    .join(' ');
                
                // Combine existing + new into one continuous text
                const allText = [...existingLines, combinedPastedText].join(' ').trim();
                
                // Now split the combined text properly
                const language = document.getElementById('language').value;
                const wps = SPEAKING_RATES[language] || 2.5;
                const targetWords = Math.round(wps * 6);
                const minWords = Math.round(targetWords * 0.7);
                const maxWords = Math.round(targetWords * 1.3);
                const newLines = smartSplitText(allText, minWords, targetWords, maxWords);
                
                // Update dialogueInput with numbered lines
                document.getElementById('dialogueInput').value = newLines.map((l, i) => `${i + 1}|${l}`).join('\n');
                
                // Re-render
                renderSimpleEditor();
                validateDialogueLines();
                
                // Show status
                const status = document.getElementById('splitStatus');
                if(status && newLines.length > 0){
                    status.style.display = 'block';
                    status.textContent = `✓ Re-split into ${newLines.length} clips`;
                    status.style.color = 'var(--success)';
                    setTimeout(() => { status.style.display = 'none'; }, 3000);
                }
            } else {
                // MANUAL MODE: Each line in pasted text becomes a separate clip
                const pastedLines = pastedText.split('\n').map(l => l.trim()).filter(l => l);
                
                if(pastedLines.length === 0) return;
                
                // Get existing lines
                const existingLines = [];
                editor.querySelectorAll('.simple-line').forEach((line) => {
                    const text = line.textContent.trim();
                    if(text && !line.classList.contains('placeholder-line')){
                        existingLines.push(text);
                    }
                });
                
                // Combine existing + new (each pasted line = one clip)
                const allLines = [...existingLines, ...pastedLines];
                
                // Update dialogueInput with numbered lines
                document.getElementById('dialogueInput').value = allLines.map((l, i) => `${i + 1}|${l}`).join('\n');
                
                // Re-render
                renderSimpleEditor();
                validateDialogueLines();
                
                // Show status
                const status = document.getElementById('splitStatus');
                if(status){
                    status.style.display = 'block';
                    status.textContent = `✓ Added ${pastedLines.length} line${pastedLines.length > 1 ? 's' : ''} (1 line = 1 clip)`;
                    status.style.color = 'var(--accent)';
                    setTimeout(() => { status.style.display = 'none'; }, 2000);
                }
            }
        }
        
        function updateAutoSplitStatus(){
            const toggle1 = document.getElementById('autoSplitToggle');
            const toggle2 = document.getElementById('autoSplitToggleStoryboard');
            const enabled = toggle1?.classList.contains('active') || toggle2?.classList.contains('active');
            
            // Update any status text if present
            const status = document.getElementById('autoSplitStatus');
            if(status){
                status.textContent = enabled ? 'Auto-split: ON' : 'Manual: 1 line = 1 clip';
                status.style.color = enabled ? 'var(--success)' : 'var(--accent)';
            }
        }
        
        function toggleAutoSplit(){
            const toggle1 = document.getElementById('autoSplitToggle');
            const toggle2 = document.getElementById('autoSplitToggleStoryboard');
            
            // Get current state from either toggle
            const wasActive = toggle1?.classList.contains('active') || toggle2?.classList.contains('active');
            const newState = !wasActive;
            
            // Sync both toggles
            if(toggle1) {
                if(newState) toggle1.classList.add('active');
                else toggle1.classList.remove('active');
            }
            if(toggle2) {
                if(newState) toggle2.classList.add('active');
                else toggle2.classList.remove('active');
            }
            
            updateAutoSplitStatus();
        }
        
        // Check auto-split state
        function isAutoSplitEnabled(){
            const toggle1 = document.getElementById('autoSplitToggle');
            const toggle2 = document.getElementById('autoSplitToggleStoryboard');
            return toggle1?.classList.contains('active') || toggle2?.classList.contains('active');
        }
        
        function handleSimpleEditorKeydown(e){
            const editor = document.getElementById('simpleRichEditor');
            
            // Handle Enter key - create a new line div
            if(e.key === 'Enter'){
                e.preventDefault();
                
                // Get current selection
                const selection = window.getSelection();
                const range = selection.getRangeAt(0);
                
                // Create new line div
                const newLine = document.createElement('div');
                newLine.className = 'simple-line';
                newLine.setAttribute('data-line', editor.querySelectorAll('.simple-line').length + 1);
                newLine.innerHTML = '<br>'; // Empty line needs a br to be focusable
                
                // Find current line and insert after it
                let currentLine = range.startContainer;
                while(currentLine && !currentLine.classList?.contains('simple-line')){
                    currentLine = currentLine.parentNode;
                }
                
                if(currentLine && currentLine.classList?.contains('simple-line')){
                    // Split text at cursor if in middle of line
                    const cursorOffset = range.startOffset;
                    const textContent = currentLine.textContent;
                    
                    if(cursorOffset < textContent.length){
                        // Split the text
                        const beforeText = textContent.substring(0, cursorOffset);
                        const afterText = textContent.substring(cursorOffset);
                        currentLine.textContent = beforeText || '';
                        newLine.textContent = afterText || '';
                        newLine.innerHTML = newLine.innerHTML || '<br>';
                    }
                    
                    currentLine.after(newLine);
                } else {
                    // Append at end
                    editor.appendChild(newLine);
                }
                
                // Move cursor to new line
                const newRange = document.createRange();
                newRange.setStart(newLine, 0);
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);
                
                // Sync to hidden input
                syncFromSimpleEditor();
            }
        }
        
        // Initialize simple editor on page load
        document.addEventListener('DOMContentLoaded', function(){
            renderSimpleEditor();
        });
        
        let draggedImageIndex = null;
        // Track transition points: array of clip indices where image changes
        // Default: transitions after each clip matching image count
        let transitionPoints = [];
        
        // Character rates (characters per second) by language - for cross-validation
        const CHAR_RATES = {
            "English": 14, "Italian": 15, "Spanish": 16, "French": 14, "German": 13,
            "Portuguese": 15, "Dutch": 14, "Polish": 14, "Russian": 13,
            "Japanese": 5, "Korean": 6, "Chinese": 4, "Arabic": 12, "Hindi": 14, "Turkish": 14
        };
        
        // Punctuation for natural breaks
        const HARD_STOPS = ['.', '!', '?', '。', '！', '？', '।'];
        const SOFT_STOPS = [',', ';', ':', '—', '–', '-', '،', '、', ')'];
        
        // Words that should NOT end a line (articles, prepositions, conjunctions, etc.)
        // These create awkward breaks when at the end of a line
        const WEAK_WORDS = {
            "English": new Set([
                // Articles
                'the', 'a', 'an',
                // Prepositions
                'of', 'in', 'to', 'for', 'with', 'on', 'at', 'by', 'from', 'as', 'into', 'about', 'through', 'after', 'over', 'between', 'under', 'against', 'during', 'without', 'before', 'around', 'among',
                // Conjunctions
                'and', 'but', 'or', 'nor', 'so', 'yet', 'if', 'when', 'while', 'although', 'because', 'unless', 'until', 'whether', 'that', 'which', 'who', 'whom', 'whose',
                // Possessives & Determiners
                'my', 'your', 'his', 'her', 'its', 'our', 'their', 'this', 'that', 'these', 'those',
                // Auxiliary/Common verbs
                'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can',
                // Other weak words
                "it's", "don't", "doesn't", "isn't", "aren't", "wasn't", "weren't", "won't", "wouldn't", "couldn't", "shouldn't", "can't", "not", "no", "just", 'very', 'really', 'also', 'even', 'only'
            ]),
            "Italian": new Set([
                // Articles
                'il', 'lo', 'la', 'i', 'gli', 'le', 'un', 'uno', 'una', "un'", 'l\'',
                // Prepositions (simple and articulated)
                'di', 'a', 'da', 'in', 'con', 'su', 'per', 'tra', 'fra', 'del', 'dello', 'della', 'dei', 'degli', 'delle', 'al', 'allo', 'alla', 'ai', 'agli', 'alle', 'dal', 'dallo', 'dalla', 'dai', 'dagli', 'dalle', 'nel', 'nello', 'nella', 'nei', 'negli', 'nelle', 'sul', 'sullo', 'sulla', 'sui', 'sugli', 'sulle',
                // Conjunctions
                'e', 'o', 'ma', 'però', 'quindi', 'perché', 'se', 'che', 'quando', 'mentre', 'anche', 'né', 'oppure', 'dunque', 'infatti', 'cioè',
                // Possessives & Demonstratives
                'mio', 'mia', 'miei', 'mie', 'tuo', 'tua', 'tuoi', 'tue', 'suo', 'sua', 'suoi', 'sue', 'nostro', 'nostra', 'nostri', 'nostre', 'vostro', 'vostra', 'vostri', 'vostre', 'loro', 'questo', 'questa', 'questi', 'queste', 'quello', 'quella', 'quelli', 'quelle',
                // Auxiliary verbs
                'è', 'sono', 'era', 'erano', 'essere', 'stato', 'stata', 'stati', 'state', 'ha', 'ho', 'hai', 'abbiamo', 'avete', 'hanno', 'aveva', 'avevo', 'avevi', 'avevamo', 'avevate', 'avevano',
                // Other
                'non', 'più', 'molto', 'tanto', 'poco', 'tutto', 'ogni', 'alcuni', 'alcune', 'qualche'
            ]),
            "Spanish": new Set([
                // Articles
                'el', 'la', 'los', 'las', 'un', 'una', 'unos', 'unas',
                // Prepositions
                'de', 'a', 'en', 'con', 'por', 'para', 'sin', 'sobre', 'entre', 'hacia', 'desde', 'durante', 'mediante', 'según', 'contra', 'tras', 'ante', 'bajo',
                // Conjunctions
                'y', 'e', 'o', 'u', 'pero', 'sino', 'aunque', 'porque', 'que', 'si', 'cuando', 'como', 'donde', 'mientras', 'ni', 'pues', 'ya',
                // Possessives & Demonstratives
                'mi', 'mis', 'tu', 'tus', 'su', 'sus', 'nuestro', 'nuestra', 'nuestros', 'nuestras', 'vuestro', 'vuestra', 'vuestros', 'vuestras', 'este', 'esta', 'estos', 'estas', 'ese', 'esa', 'esos', 'esas', 'aquel', 'aquella', 'aquellos', 'aquellas',
                // Auxiliary verbs
                'es', 'son', 'era', 'eran', 'ser', 'sido', 'está', 'están', 'estaba', 'estaban', 'estar', 'estado', 'ha', 'he', 'has', 'hemos', 'han', 'había', 'habían', 'haber', 'tengo', 'tienes', 'tiene', 'tenemos', 'tienen',
                // Other
                'no', 'muy', 'más', 'menos', 'mucho', 'poco', 'todo', 'cada', 'algún', 'alguna', 'algunos', 'algunas'
            ]),
            "French": new Set([
                // Articles
                'le', 'la', 'les', 'un', 'une', 'des', "l'", 'du', 'de', 'au', 'aux',
                // Prepositions
                'de', 'à', 'en', 'dans', 'avec', 'pour', 'sur', 'par', 'sans', 'sous', 'entre', 'vers', 'chez', 'depuis', 'pendant', 'avant', 'après', 'contre',
                // Conjunctions
                'et', 'ou', 'mais', 'donc', 'or', 'ni', 'car', 'que', 'qui', 'quand', 'si', 'comme', 'lorsque', 'puisque', 'quoique', 'parce',
                // Possessives & Demonstratives
                'mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'son', 'sa', 'ses', 'notre', 'nos', 'votre', 'vos', 'leur', 'leurs', 'ce', 'cet', 'cette', 'ces',
                // Auxiliary verbs
                'est', 'sont', 'était', 'étaient', 'être', 'été', 'a', 'ai', 'as', 'avons', 'avez', 'ont', 'avait', 'avaient', 'avoir', 'eu', 'fait', 'va', 'vais', 'vas', 'allons', 'allez', 'vont',
                // Other
                'ne', 'pas', "n'", 'plus', 'très', 'bien', 'tout', 'tous', 'toute', 'toutes', 'quelque', 'quelques', 'chaque', 'aucun', 'aucune'
            ]),
            "German": new Set([
                // Articles
                'der', 'die', 'das', 'den', 'dem', 'des', 'ein', 'eine', 'einer', 'einem', 'einen', 'eines',
                // Prepositions
                'von', 'zu', 'bei', 'mit', 'nach', 'aus', 'für', 'um', 'an', 'auf', 'in', 'über', 'unter', 'vor', 'hinter', 'neben', 'zwischen', 'durch', 'gegen', 'ohne', 'bis', 'seit', 'während',
                // Conjunctions
                'und', 'oder', 'aber', 'denn', 'weil', 'dass', 'wenn', 'als', 'ob', 'damit', 'obwohl', 'während', 'bevor', 'nachdem', 'sobald', 'falls',
                // Possessives & Demonstratives
                'mein', 'meine', 'meinem', 'meinen', 'meiner', 'meines', 'dein', 'deine', 'sein', 'seine', 'ihr', 'ihre', 'unser', 'unsere', 'euer', 'eure', 'dieser', 'diese', 'dieses', 'diesen', 'diesem', 'jener', 'jene', 'jenes',
                // Auxiliary verbs
                'ist', 'sind', 'war', 'waren', 'sein', 'gewesen', 'hat', 'habe', 'hast', 'haben', 'habt', 'hatte', 'hatten', 'gehabt', 'wird', 'werde', 'wirst', 'werden', 'werdet', 'wurde', 'wurden', 'kann', 'können', 'konnte', 'konnten', 'muss', 'müssen', 'musste', 'mussten', 'soll', 'sollen', 'sollte', 'sollten', 'will', 'wollen', 'wollte', 'wollten', 'darf', 'dürfen', 'durfte', 'durften', 'mag', 'mögen', 'mochte', 'mochten',
                // Other
                'nicht', 'auch', 'noch', 'schon', 'nur', 'sehr', 'viel', 'mehr', 'wenig', 'alle', 'alles', 'jeder', 'jede', 'jedes', 'kein', 'keine'
            ])
        };
        
        function smartSplitText(text, minWords, targetWords, maxWords){
            // Clean the text - remove existing line numbers
            const cleanedText = text
                .split('\n')
                .map(line => line.replace(/^\d+\|/, '').trim())
                .filter(line => line)
                .join(' ')
                .replace(/\s+/g, ' ')
                .trim();
            
            if(!cleanedText) return [];
            
            // Get language-specific rates
            const lang = document.getElementById('language').value || 'Italian';
            const wordsPerSec = SPEAKING_RATES[lang] || 2.5;
            
            // Use custom words per line if set, otherwise calculate from speaking rate
            const customWords = parseInt(document.getElementById('wordsPerLine')?.value) || 0;
            const TARGET_WORDS = customWords > 0 ? customWords : Math.round(wordsPerSec * 7);
            
            console.log(`[SmartSplit] Language: ${lang}, Target: ${TARGET_WORDS} words${customWords > 0 ? ' (custom)' : ' (auto)'}`);
            
            const words = cleanedText.split(/\s+/);
            const resultLines = [];
            let startIdx = 0;
            
            // Get weak words set for current language (fallback to English)
            const weakWordsSet = WEAK_WORDS[lang] || WEAK_WORDS["English"] || new Set();
            
            // Helper to check if a word is weak (should not end a line)
            const isWeakWord = (word) => {
                if (!word) return false;
                // Remove punctuation for checking
                const cleanWord = word.replace(/[.,!?;:'")\]—–-]+$/, '').toLowerCase();
                return weakWordsSet.has(cleanWord);
            };
            
            while(startIdx < words.length){
                const remaining = words.length - startIdx;
                
                // If remaining fits, take it all
                if(remaining <= TARGET_WORDS + 2){
                    console.log(`[SmartSplit] Taking remaining ${remaining} words`);
                    resultLines.push(words.slice(startIdx).join(' '));
                    break;
                }
                
                let splitIdx = null;
                let splitReason = '';
                
                // Helper to check if word at position has punctuation
                const getWordAt = (pos) => {
                    const idx = startIdx + pos - 1;  // Convert to 0-indexed
                    if(idx >= 0 && idx < words.length) return { word: words[idx], idx: idx };
                    return null;
                };
                
                const hasHardStop = (w) => w && HARD_STOPS.includes(w.word.slice(-1));
                const hasSoftStop = (w) => w && SOFT_STOPS.includes(w.word.slice(-1));
                
                // Priority 1: HARD STOP at target+2, +1, -1, or -2 (prefer longer lines)
                // But skip if the word is a weak word
                const hardOffsets = [2, 1, -1, -2];
                for (const offset of hardOffsets) {
                    const candidate = getWordAt(TARGET_WORDS + offset);
                    if (hasHardStop(candidate) && !isWeakWord(candidate.word)) {
                        splitIdx = candidate.idx + 1;
                        splitReason = `HARD STOP at ${offset > 0 ? '+' : ''}${offset} "${candidate.word}"`;
                        break;
                    }
                }
                
                // Priority 2: SOFT STOP at target+2, +1, -1, -2 (skip weak words)
                if(splitIdx === null){
                    const softOffsets = [2, 1, -1, -2];
                    for (const offset of softOffsets) {
                        const candidate = getWordAt(TARGET_WORDS + offset);
                        if (hasSoftStop(candidate) && !isWeakWord(candidate.word)) {
                            splitIdx = candidate.idx + 1;
                            splitReason = `SOFT STOP at ${offset > 0 ? '+' : ''}${offset} "${candidate.word}"`;
                            break;
                        }
                    }
                }
                
                // Priority 3: No punctuation - find best non-weak word in range ±2
                if(splitIdx === null){
                    // Check positions: target, +1, -1, +2, -2 (prefer closer to target)
                    const fallbackOffsets = [0, 1, -1, 2, -2];
                    for (const offset of fallbackOffsets) {
                        const candidate = getWordAt(TARGET_WORDS + offset);
                        if (candidate && !isWeakWord(candidate.word)) {
                            splitIdx = candidate.idx + 1;
                            splitReason = `Best non-weak word at ${offset === 0 ? 'target' : (offset > 0 ? '+' : '') + offset} "${candidate.word}"`;
                            break;
                        }
                    }
                    
                    // If all words in range are weak, just split at target (last resort)
                    if (splitIdx === null) {
                        splitIdx = Math.min(startIdx + TARGET_WORDS, words.length);
                        splitReason = `All weak words in range, split at target`;
                    }
                }
                
                // Take the chunk
                const chunk = words.slice(startIdx, splitIdx).join(' ');
                const chunkWords = splitIdx - startIdx;
                const estSec = chunkWords / wordsPerSec;
                
                console.log(`[SmartSplit] → ${splitReason} → ${chunkWords} words, ~${estSec.toFixed(1)}s`);
                
                resultLines.push(chunk);
                startIdx = splitIdx;
            }
            
            // NOTE: We no longer redistribute last lines
            // Last clip can be 4-8 seconds, and we dynamically pick the best duration
            
            // Final log
            console.log(`[SmartSplit] === ${resultLines.length} lines ===`);
            resultLines.forEach((line, idx) => {
                const wc = line.split(/\s+/).length;
                const estSec = wc / wordsPerSec;
                const isLast = idx === resultLines.length - 1;
                if (isLast) {
                    // Last clip picks from 4, 6, or 8 seconds
                    const bestDuration = estSec <= 4 ? 4 : (estSec <= 6 ? 6 : 8);
                    console.log(`[SmartSplit] Line ${idx + 1}: ${wc} words, ~${estSec.toFixed(1)}s (LAST CLIP - will use ${bestDuration}s)`);
                } else {
                    console.log(`[SmartSplit] Line ${idx + 1}: ${wc} words, ~${estSec.toFixed(1)}s`);
                }
            });
            
            return resultLines;
        }
        
        function mergeShortLines(lines, minSec, maxSec, wordsPerSec, charsPerSec){
            // Not needed anymore with new logic
            return lines;
        }
        
        function balanceLastLines(lines, minWords, minChars){
            return lines;
        }
        
        function renderStoryboard(){
            const editor = document.getElementById('richEditor');
            const sidebar = document.getElementById('storyboardSidebar');
            const fullText = document.getElementById('dialogueInput').value;
            const numImages = uploadedFilesData.length;
            
            let lines;
            
            // Check if auto-split is enabled
            const autoSplitEnabled = isAutoSplitEnabled();
            
            if(autoSplitEnabled) {
                // AUTO-SPLIT: Split by speaking rate
                const language = document.getElementById('language').value;
                const wps = SPEAKING_RATES[language] || 2.5;
                
                // Use custom words per line if set
                const customWords = parseInt(document.getElementById('wordsPerLine')?.value) || 0;
                const targetWords = customWords > 0 ? customWords : Math.round(wps * 6);
                const minWords = Math.round(targetWords * 0.7);
                const maxWords = Math.round(targetWords * 1.3);
                
                // Combine all text first (remove existing line breaks), then split
                const combinedText = fullText
                    .split('\n')
                    .map(l => {
                        // Remove line numbers if present
                        const match = l.match(/^\d+\|(.*)$/);
                        return match ? match[1].trim() : l.trim();
                    })
                    .filter(l => l)
                    .join(' ');
                
                lines = smartSplitText(combinedText, minWords, targetWords, maxWords);
            } else {
                // MANUAL: Each line in dialogueInput = 1 clip (don't re-split)
                lines = fullText
                    .split('\n')
                    .map(l => {
                        // Remove line numbers if present
                        const match = l.match(/^\d+\|(.*)$/);
                        return match ? match[1].trim() : l.trim();
                    })
                    .filter(l => l);
            }
            
            // Use the shared render function
            renderStoryboardWithLines(lines);
        }
        
        // Render storyboard with pre-split lines (doesn't re-split)
        function renderStoryboardWithLines(lines){
            const editor = document.getElementById('richEditor');
            const sidebar = document.getElementById('storyboardSidebar');
            const numImages = uploadedFilesData.length;
            const numLines = lines.length;
            
            // Update dialogueInput with properly formatted lines
            const formattedLines = lines.map((line, i) => `${i + 1}|${line}`);
            document.getElementById('dialogueInput').value = formattedLines.join('\n');
            
            // Render the styled editor (don't set innerText - let the render function handle it)
            if(editorMode === 'auto'){
                renderAutoCycleMode(sidebar, editor, lines, numImages);
            } else {
                renderStoryboardMode(sidebar, editor, lines, numImages);
            }
            
            updateStoryboardSummary();
        }
        
        function renderAutoCycleMode(sidebar, editor, lines, numImages){
            const numLines = lines.length;
            
            // Sidebar: Show images with cycle indicators
            let sidebarHtml = '';
            uploadedFilesData.forEach((img, i) => {
                // Calculate which lines this image covers in the cycle
                const cycleLines = [];
                for(let j = i; j < numLines; j += numImages){
                    cycleLines.push(j + 1);
                }
                const rangeText = cycleLines.length > 0 ? `#${cycleLines.join(', #')}` : '';
                const shortRange = cycleLines.length > 3 ? `#${cycleLines[0]}, #${cycleLines[1]}...` : rangeText;
                
                sidebarHtml += `
                    <div class="storyboard-sidebar-image" title="${img.name}\nClips: ${rangeText}">
                        <img src="${img.dataUrl}">
                        <div class="img-index">${i + 1}</div>
                        <div class="img-range">${shortRange}</div>
                        <div class="img-remove" onclick="removeImage(${i})">✕</div>
                    </div>
                `;
            });
            sidebarHtml += `<div class="storyboard-sidebar-add" onclick="document.getElementById('fileInput').click()" title="Add image">+</div>`;
            sidebar.innerHTML = sidebarHtml;
            
            // Editor: Clean text with line numbers, small image indicator on each line
            let htmlContent = '';
            
            if(numLines > 0 && numImages > 0){
                lines.forEach((line, lineIdx) => {
                    const imgIndex = lineIdx % numImages;
                    const lineNum = lineIdx + 1;
                    htmlContent += `<div class="scene-line" data-line="${lineNum}" data-img="🖼${imgIndex + 1}">${line}</div>`;
                });
            } else if(numLines > 0){
                lines.forEach((line, lineIdx) => {
                    htmlContent += `<div class="scene-line" data-line="${lineIdx + 1}">${line}</div>`;
                });
            } else {
                htmlContent = `<div class="scene-line placeholder-line" data-line="" contenteditable="true"></div>`;
            }
            
            editor.innerHTML = `<div class="scene-text-block">${htmlContent}</div>`;
            
            // Calculate transition points for auto-cycle (round-robin)
            transitionPoints = [];
            // In auto-cycle, each line uses next image, so transition after every line
            // But for backend we don't need explicit transitions - it will cycle automatically
        }
        
        function renderStoryboardMode(sidebar, editor, lines, numImages){
            const numLines = lines.length;
            
            // Validate scene breaks
            sceneBreaks = sceneBreaks.filter(sb => sb.imgIndex < numImages);
            if(numLines > 0){
                sceneBreaks = sceneBreaks.filter(sb => sb.lineIndex < numLines);
            }
            if(sceneBreaks.length === 0 && numImages > 0){
                sceneBreaks = [{ lineIndex: 0, imgIndex: 0, clipMode: 'blend' }];
            }
            
            // Sort scene breaks by line index
            sceneBreaks.sort((a, b) => a.lineIndex - b.lineIndex);
            
            // CRITICAL: Remove duplicate lineIndex entries (keep the first one)
            const seenLineIndices = new Set();
            sceneBreaks = sceneBreaks.filter(sb => {
                if(seenLineIndices.has(sb.lineIndex)){
                    console.log(`[renderStoryboard] Removing duplicate scene at lineIndex ${sb.lineIndex}`);
                    return false;
                }
                seenLineIndices.add(sb.lineIndex);
                return true;
            });
            
            // Ensure all scenes have clipMode
            sceneBreaks.forEach((sb, idx) => {
                if(!sb.clipMode){
                    sb.clipMode = 'blend';
                    console.log(`[renderStoryboard] Set default clipMode for scene ${idx}`);
                }
            });
            
            // Ensure first scene starts at line 0
            if(sceneBreaks.length > 0 && sceneBreaks[0].lineIndex !== 0){
                sceneBreaks[0].lineIndex = 0;
            }
            
            // Calculate which clips each image covers
            const imageClipRanges = {};
            sceneBreaks.forEach((scene, sceneIdx) => {
                const nextScene = sceneBreaks[sceneIdx + 1];
                const startClip = scene.lineIndex + 1; // 1-indexed for display
                const endClip = nextScene ? nextScene.lineIndex : numLines;
                
                if(!imageClipRanges[scene.imgIndex]){
                    imageClipRanges[scene.imgIndex] = [];
                }
                if(endClip > scene.lineIndex){
                    if(startClip === endClip){
                        imageClipRanges[scene.imgIndex].push(`#${startClip}`);
                    } else {
                        imageClipRanges[scene.imgIndex].push(`#${startClip}-${endClip}`);
                    }
                }
            });
            
            // Also check if image is used as Last Frame
            if(lastFrameIndex !== null){
                if(!imageClipRanges[lastFrameIndex]){
                    imageClipRanges[lastFrameIndex] = [];
                }
                imageClipRanges[lastFrameIndex].push('End');
            }
            
            // Sidebar: Draggable images
            let sidebarHtml = '';
            uploadedFilesData.forEach((img, i) => {
                const clips = imageClipRanges[i];
                const usageText = clips && clips.length > 0 
                    ? clips.join(', ')
                    : 'drag to use';
                
                sidebarHtml += `
                    <div class="storyboard-sidebar-image draggable" 
                         onmousedown="handleImageMouseDown(event, ${i})"
                         title="${img.name}">
                        <img src="${img.dataUrl}" draggable="false">
                        <div class="img-index">${i + 1}</div>
                        <div class="img-range">${usageText}</div>
                        <div class="img-remove" onclick="event.stopPropagation();removeImage(${i})">✕</div>
                    </div>
                `;
            });
            sidebarHtml += `<div class="storyboard-sidebar-add" onclick="document.getElementById('fileInput').click()" title="Add image">+</div>`;
            sidebar.innerHTML = sidebarHtml;
            
            // Editor: Scene dividers (draggable) with text sections
            let htmlContent = '';
            
            if(numLines > 0){
                sceneBreaks.forEach((scene, sceneIdx) => {
                    const img = uploadedFilesData[scene.imgIndex];
                    if(!img) return;
                    
                    const nextScene = sceneBreaks[sceneIdx + 1];
                    const endLine = nextScene ? nextScene.lineIndex : numLines;
                    const sceneLines = lines.slice(scene.lineIndex, endLine);
                    
                    // Scene divider - draggable (except first one which stays at top)
                    const isDraggable = sceneIdx > 0;
                    const isFirstScene = sceneIdx === 0;
                    
                    // Scene transition (Blend to / Cut to) - how we arrive FROM previous scene
                    const hasBlendTransition = scene.transition !== 'cut'; // Default to blend
                    
                    // Clip mode (blend/continue/fresh) - how clips transition within this scene
                    const clipMode = scene.clipMode || 'blend'; // Default to blend
                    console.log(`[renderStoryboard] Scene ${sceneIdx}: clipMode=${clipMode}, scene.clipMode=${scene.clipMode}, typeof=${typeof scene.clipMode}`);
                    
                    htmlContent += `<div class="scene-divider-wrapper">`;
                    
                    // Scene transition toggle (only for non-first scenes)
                    if(!isFirstScene){
                        htmlContent += `
                            <div class="scene-transition-toggle ${hasBlendTransition ? 'blend' : ''}" 
                                 onclick="toggleSceneTransition(${sceneIdx})"
                                 title="${hasBlendTransition ? 'Blend: Previous scene morphs into this one' : 'Cut: Hard cut from previous scene'}">
                                <span class="trans-icon">${hasBlendTransition ? '🔄' : '✂️'}</span>
                                <span class="trans-label">${hasBlendTransition ? 'Blend to' : 'Cut to'}</span>
                            </div>
                        `;
                    }
                    
                    // Scene box - with drop support to replace image
                    htmlContent += `
                        <div class="scene-divider" 
                             contenteditable="false" 
                             data-scene-idx="${sceneIdx}"
                             ${isDraggable ? `onmousedown="handleSceneMouseDown(event, ${sceneIdx})"` : ''}>
                            <img class="scene-divider-img" src="${img.dataUrl}" draggable="false">
                            <div class="clip-mode-toggle">
                                <button class="clip-mode-btn blend-btn ${clipMode === 'blend' ? 'active' : ''}" 
                                        onmousedown="event.stopPropagation()"
                                        onclick="event.stopPropagation();setClipMode(${sceneIdx}, 'blend')"
                                        title="Blend: Original image → transitions to next scene">Blend</button>
                                <button class="clip-mode-btn continue-btn ${clipMode === 'continue' ? 'active' : ''}" 
                                        onmousedown="event.stopPropagation()"
                                        onclick="event.stopPropagation();setClipMode(${sceneIdx}, 'continue')"
                                        title="Continue: Uses previous clip's last frame → transitions to next">Continue</button>
                                <button class="clip-mode-btn fresh-btn ${clipMode === 'fresh' ? 'active' : ''}" 
                                        onmousedown="event.stopPropagation()"
                                        onclick="event.stopPropagation();setClipMode(${sceneIdx}, 'fresh')"
                                        title="Fresh: Original image only, no transitions (standalone clips)">Fresh</button>
                            </div>
                            <div class="scene-divider-info">
                                <span class="scene-divider-label">Scene ${sceneIdx + 1} (Image ${scene.imgIndex + 1})</span>
                                <span class="scene-divider-hint">Clips #${scene.lineIndex + 1}${endLine > scene.lineIndex + 1 ? '-' + endLine : ''}</span>
                            </div>
                            <div class="scene-divider-actions">
                                ${isDraggable ? `<button class="scene-divider-remove" onmousedown="event.stopPropagation()" onclick="event.stopPropagation();removeSceneBreak(${sceneIdx})">✕</button>` : ''}
                            </div>
                        </div>
                    </div>`;
                    
                    // Lines for this scene
                    sceneLines.forEach((line, i) => {
                        const lineNum = scene.lineIndex + i + 1;
                        htmlContent += `<div class="scene-line" data-line="${lineNum}" data-line-idx="${scene.lineIndex + i}">${line}</div>`;
                    });
                });
                
                // Add compact Last Frame indicator (only if set)
                if(lastFrameIndex !== null && uploadedFilesData[lastFrameIndex]){
                    const lastFrameImg = uploadedFilesData[lastFrameIndex];
                    htmlContent += `
                        <div class="last-frame-indicator">
                            <span class="end-frame-blend-badge" title="End frame always blends from the last clip">🎬 BLEND TO</span>
                            <img class="last-frame-thumb" src="${lastFrameImg.dataUrl}">
                            <span class="last-frame-text">🏁 End Frame (Image ${lastFrameIndex + 1})</span>
                            <button class="last-frame-remove-btn" onclick="removeLastFrame()">✕</button>
                        </div>
                    `;
                }
            } else {
                // No text yet - show the first scene's assigned image (might have been changed by drag & drop)
                if(numImages > 0){
                    // Use sceneBreaks[0].imgIndex if available, otherwise default to 0
                    const firstSceneImgIdx = (sceneBreaks.length > 0 && sceneBreaks[0].imgIndex < numImages) 
                        ? sceneBreaks[0].imgIndex 
                        : 0;
                    const img = uploadedFilesData[firstSceneImgIdx];
                    const clipMode = (sceneBreaks.length > 0 && sceneBreaks[0].clipMode) || 'blend';
                    
                    htmlContent += `
                        <div class="scene-divider-wrapper">
                            <div class="scene-divider" contenteditable="false" data-scene-idx="0">
                                <img class="scene-divider-img" src="${img.dataUrl}" draggable="false">
                                <div class="clip-mode-toggle">
                                    <button class="clip-mode-btn blend-btn ${clipMode === 'blend' ? 'active' : ''}" 
                                            onmousedown="event.stopPropagation()"
                                            onclick="event.stopPropagation();setClipMode(0, 'blend')" 
                                            title="Blend: Original image → transitions to next scene">Blend</button>
                                    <button class="clip-mode-btn continue-btn ${clipMode === 'continue' ? 'active' : ''}" 
                                            onmousedown="event.stopPropagation()"
                                            onclick="event.stopPropagation();setClipMode(0, 'continue')" 
                                            title="Continue: Uses previous clip's last frame → transitions to next">Continue</button>
                                    <button class="clip-mode-btn fresh-btn ${clipMode === 'fresh' ? 'active' : ''}" 
                                            onmousedown="event.stopPropagation()"
                                            onclick="event.stopPropagation();setClipMode(0, 'fresh')" 
                                            title="Fresh: Original image only, no transitions (standalone clips)">Fresh</button>
                                </div>
                                <div class="scene-divider-info">
                                    <span class="scene-divider-label">Scene 1 (Image ${firstSceneImgIdx + 1})</span>
                                    <span class="scene-divider-hint">Paste your script below</span>
                                </div>
                            </div>
                        </div>
                    `;
                }
                htmlContent += `<div class="scene-line placeholder-line" data-line="" contenteditable="true"></div>`;
            }
            
            editor.innerHTML = `<div class="scene-text-block">${htmlContent}</div>`;
            
            // Calculate transition points for backend
            transitionPoints = sceneBreaks.slice(1).map(sb => sb.lineIndex - 1).filter(t => t >= 0);
        }
        
        function removeSceneBreak(sceneIdx){
            if(sceneIdx > 0 && sceneIdx < sceneBreaks.length){
                sceneBreaks.splice(sceneIdx, 1);
                renderStoryboard();
            }
        }
        
        function toggleSceneTransition(sceneIdx){
            // Toggle between blend and cut for scene transition
            if(sceneIdx > 0 && sceneIdx < sceneBreaks.length){
                sceneBreaks[sceneIdx].transition = sceneBreaks[sceneIdx].transition === 'cut' ? 'blend' : 'cut';
                renderStoryboard();
            }
        }
        
        function setClipMode(sceneIdx, mode){
            // Set clip mode for a scene: 'blend', 'continue', or 'fresh'
            console.log(`[setClipMode] Called with sceneIdx=${sceneIdx}, mode=${mode}`);
            console.log(`[setClipMode] sceneBreaks.length=${sceneBreaks.length}`);
            console.log(`[setClipMode] sceneBreaks=`, JSON.stringify(sceneBreaks));
            
            if(sceneIdx >= 0 && sceneIdx < sceneBreaks.length){
                sceneBreaks[sceneIdx].clipMode = mode;
                console.log(`[setClipMode] Updated sceneBreaks[${sceneIdx}].clipMode to ${mode}`);
                renderStoryboard();
            } else {
                console.log(`[setClipMode] Invalid sceneIdx: ${sceneIdx} not in range [0, ${sceneBreaks.length})`);
            }
        }
        
        // Scene divider drop handlers - to replace image of a scene
        function handleSceneDividerDragOver(e, sceneIdx){
            if(draggedImageIndex === null) return;
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('drop-target');
            e.dataTransfer.dropEffect = 'copy';
        }
        
        function handleSceneDividerDragLeave(e){
            e.currentTarget.classList.remove('drop-target');
        }
        
        function handleSceneDividerDrop(e, sceneIdx){
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drop-target');
            document.querySelectorAll('.drop-indicator-line').forEach(el => el.remove());
            
            if(draggedImageIndex !== null && sceneIdx >= 0 && sceneIdx < sceneBreaks.length){
                // Replace this scene's image
                sceneBreaks[sceneIdx].imgIndex = draggedImageIndex;
                draggedImageIndex = null;
                renderStoryboard();
            }
        }
        
        // Last Frame drop zone handlers
        function handleLastFrameDragOver(e){
            e.preventDefault();
            e.stopPropagation();
            if(draggedImageIndex !== null){
                e.currentTarget.classList.add('drag-over');
                e.dataTransfer.dropEffect = 'copy';
            }
        }
        
        function handleLastFrameDragLeave(e){
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
        }
        
        function handleLastFrameDrop(e){
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
            
            if(draggedImageIndex !== null){
                lastFrameIndex = draggedImageIndex;
                draggedImageIndex = null;
                renderStoryboard();
            }
        }
        
        function removeLastFrame(){
            lastFrameIndex = null;
            renderStoryboard();
        }
        
        function syncFromRichEditor(){
            const editor = document.getElementById('richEditor');
            
            // Skip if we're currently handling a paste
            if(editor.dataset.pasting === 'true') return;
            
            if(editorMode === 'storyboard'){
                // In storyboard mode, read scene structure from DOM
                syncStoryboardFromDOM();
            } else {
                // In auto-cycle mode, just collect text
                syncAutoCycleFromDOM();
            }
        }
        
        function handleRichEditorPaste(e){
            e.preventDefault();
            
            const editor = document.getElementById('richEditor');
            const clipboardData = e.clipboardData || window.clipboardData;
            const pastedText = clipboardData.getData('text/plain');
            
            if(!pastedText) return;
            
            // Mark that we're handling a paste to prevent duplicate processing
            editor.dataset.pasting = 'true';
            
            const autoSplitEnabled = isAutoSplitEnabled();
            let newLines;
            
            if(autoSplitEnabled) {
                // AUTO-SPLIT: Combine all pasted lines into one text, then split properly
                const combinedText = pastedText
                    .split('\n')
                    .map(l => l.trim())
                    .filter(l => l)
                    .join(' ');
                
                const language = document.getElementById('language').value;
                const wps = SPEAKING_RATES[language] || 2.5;
                const targetWords = Math.round(wps * 6);
                const minWords = Math.round(targetWords * 0.7);
                const maxWords = Math.round(targetWords * 1.3);
                newLines = smartSplitText(combinedText, minWords, targetWords, maxWords);
            } else {
                // MANUAL: Each line in pasted text = 1 clip
                newLines = pastedText.split('\n').map(l => l.trim()).filter(l => l);
            }
            
            // Update dialogueInput with numbered lines
            document.getElementById('dialogueInput').value = newLines.map((l, i) => `${i + 1}|${l}`).join('\n');
            
            // Preserve the first scene's image assignment if it exists
            const firstSceneImgIdx = (sceneBreaks.length > 0) ? sceneBreaks[0].imgIndex : 0;
            const firstSceneClipMode = (sceneBreaks.length > 0) ? sceneBreaks[0].clipMode : 'blend';
            
            // Reset scene breaks for fresh paste, but keep the first scene's image
            sceneBreaks = [{ lineIndex: 0, imgIndex: firstSceneImgIdx, clipMode: firstSceneClipMode }];
            
            // Re-render the storyboard
            renderStoryboard();
            
            // Show status
            const status = document.getElementById('splitStatus');
            if(status && newLines.length > 0){
                status.style.display = 'block';
                status.textContent = autoSplitEnabled 
                    ? `✓ Re-split into ${newLines.length} clips`
                    : `✓ Added ${newLines.length} lines (1 line = 1 clip)`;
                status.style.color = 'var(--success)';
                setTimeout(() => { status.style.display = 'none'; }, 3000);
            }
            
            // Clear the pasting flag after a short delay
            setTimeout(() => {
                editor.dataset.pasting = 'false';
            }, 100);
        }
        
        function syncAutoCycleFromDOM(){
            const editor = document.getElementById('richEditor');
            const lineElements = editor.querySelectorAll('.scene-line');
            let allLines = [];
            
            lineElements.forEach(el => {
                const text = el.textContent.trim();
                if(text && !el.classList.contains('placeholder-line')) allLines.push(text);
            });
            
            if(allLines.length === 0){
                const rawText = editor.textContent.trim();
                if(rawText){
                    allLines = [rawText];
                }
            }
            
            const autoSplitEnabled = isAutoSplitEnabled();
            
            if(autoSplitEnabled) {
                // Join all text - will be re-split by renderStoryboard
                document.getElementById('dialogueInput').value = allLines.join(' ');
                
                clearTimeout(window.storyboardUpdateTimeout);
                window.storyboardUpdateTimeout = setTimeout(() => {
                    renderStoryboard();
                }, 600);
            } else {
                // Keep each line separate - just update hidden input, DON'T re-render
                document.getElementById('dialogueInput').value = allLines.map((l, i) => `${i + 1}|${l}`).join('\n');
                
                // Only update line numbers in place without replacing content
                clearTimeout(window.storyboardUpdateTimeout);
                window.storyboardUpdateTimeout = setTimeout(() => {
                    updateAutoCycleLineNumbers();
                    updateStoryboardSummary();
                }, 600);
            }
        }
        
        // Update line numbers without re-rendering (preserves cursor)
        function updateAutoCycleLineNumbers(){
            const editor = document.getElementById('richEditor');
            const lineElements = editor.querySelectorAll('.scene-line');
            const numImages = uploadedFilesData.length;
            
            lineElements.forEach((el, idx) => {
                el.setAttribute('data-line', idx + 1);
                if(numImages > 0){
                    el.setAttribute('data-img', `🖼${(idx % numImages) + 1}`);
                }
                // Remove placeholder class if has content
                if(el.textContent.trim()){
                    el.classList.remove('placeholder-line');
                }
            });
        }
        
        function syncStoryboardFromDOM(){
            const editor = document.getElementById('richEditor');
            
            // Walk through DOM and collect scenes with their text
            // Structure: [scene-divider, scene-line, scene-line, scene-divider, scene-line, ...]
            let newSceneBreaks = [];
            let allTextSegments = [];
            let currentSceneImgIndex = 0;
            let textBeforeFirstDivider = [];
            let foundFirstDivider = false;
            
            const textBlock = editor.querySelector('.scene-text-block');
            if(!textBlock) return;
            
            for(const node of textBlock.childNodes){
                if(node.classList && node.classList.contains('scene-divider')){
                    // This is a scene divider
                    const sceneIdx = parseInt(node.dataset.sceneIdx);
                    if(!isNaN(sceneIdx) && sceneIdx < sceneBreaks.length){
                        currentSceneImgIndex = sceneBreaks[sceneIdx].imgIndex;
                    }
                    
                    // Mark where this scene starts (will be set after we count lines)
                    newSceneBreaks.push({
                        imgIndex: currentSceneImgIndex,
                        textStartIdx: allTextSegments.length
                    });
                    foundFirstDivider = true;
                    
                } else if(node.classList && node.classList.contains('scene-line')){
                    const text = node.textContent.trim();
                    if(text && !node.classList.contains('placeholder-line')){
                        allTextSegments.push(text);
                    }
                }
            }
            
            const autoSplitEnabled = isAutoSplitEnabled();
            let newLines;
            
            if(autoSplitEnabled) {
                // AUTO-SPLIT: Combine all text and re-split
                const fullText = allTextSegments.join(' ');
                document.getElementById('dialogueInput').value = fullText;
                
                const language = document.getElementById('language').value;
                const wps = SPEAKING_RATES[language] || 2.5;
                const targetWords = Math.round(wps * 6);
                const minWords = Math.round(targetWords * 0.7);
                const maxWords = Math.round(targetWords * 1.3);
                newLines = smartSplitText(fullText, minWords, targetWords, maxWords);
                
                // Distribute scene breaks proportionally based on text position
                if(newSceneBreaks.length > 0 && allTextSegments.length > 0 && newLines.length > 0){
                    const totalOldSegments = allTextSegments.length;
                    
                    sceneBreaks = newSceneBreaks.map((sb, idx) => {
                        if(idx === 0){
                            return { lineIndex: 0, imgIndex: sb.imgIndex };
                        }
                        const proportion = sb.textStartIdx / totalOldSegments;
                        const newLineIdx = Math.min(Math.floor(proportion * newLines.length), newLines.length - 1);
                        return { lineIndex: Math.max(1, newLineIdx), imgIndex: sb.imgIndex };
                    });
                    
                    // Remove duplicates and ensure first is at 0
                    sceneBreaks[0].lineIndex = 0;
                    const seen = new Set([0]);
                    sceneBreaks = sceneBreaks.filter((sb, idx) => {
                        if(idx === 0) return true;
                        if(seen.has(sb.lineIndex)){
                            while(seen.has(sb.lineIndex) && sb.lineIndex < newLines.length - 1){
                                sb.lineIndex++;
                            }
                            if(seen.has(sb.lineIndex)) return false;
                        }
                        seen.add(sb.lineIndex);
                        return true;
                    });
                }
            } else {
                // MANUAL: Keep each line as-is, no re-splitting
                newLines = allTextSegments;
                document.getElementById('dialogueInput').value = newLines.map((l, i) => `${i + 1}|${l}`).join('\n');
                
                // Keep scene breaks as they are (adjust to current line count)
                if(newSceneBreaks.length > 0){
                    sceneBreaks = newSceneBreaks.map((sb, idx) => ({
                        lineIndex: Math.min(sb.textStartIdx, Math.max(0, newLines.length - 1)),
                        imgIndex: sb.imgIndex,
                        clipMode: sceneBreaks[idx]?.clipMode || 'blend'
                    }));
                    if(sceneBreaks.length > 0) sceneBreaks[0].lineIndex = 0;
                    
                    // Filter out scene breaks that would be out of bounds
                    sceneBreaks = sceneBreaks.filter((sb, idx) => idx === 0 || sb.lineIndex < newLines.length);
                }
                
                // Re-render to update clip range labels (Clips #1-X)
                // Use debounce to avoid cursor jumping during typing
                clearTimeout(window.storyboardUpdateTimeout);
                window.storyboardUpdateTimeout = setTimeout(() => {
                    renderStoryboard();
                }, 600);
                return;
            }
            
            clearTimeout(window.storyboardUpdateTimeout);
            window.storyboardUpdateTimeout = setTimeout(() => {
                renderStoryboard();
            }, 600);
        }
        
        // Drag and drop handlers for storyboard mode - using mouse events instead of native drag
        let draggedSceneIdx = null;
        let isDragging = false;
        let dragStartY = 0;
        
        function handleImageMouseDown(e, imgIndex){
            console.log('[handleImageMouseDown] Called with imgIndex:', imgIndex, 'editorMode:', editorMode);
            if(editorMode !== 'storyboard') {
                console.log('[handleImageMouseDown] Returning early - not in storyboard mode');
                return;
            }
            e.preventDefault();
            
            draggedImageIndex = imgIndex;
            draggedSceneIdx = null;
            isDragging = true;
            dragStartY = e.clientY;
            console.log('[handleImageMouseDown] Started drag for image', imgIndex);
            
            // Add dragging class to body to change cursor
            document.body.classList.add('is-dragging-image');
            
            // Highlight the source image
            const sourceImg = e.target.closest('.storyboard-sidebar-image');
            if(sourceImg) sourceImg.classList.add('being-dragged');
        }
        
        function handleSceneMouseDown(e, sceneIdx){
            if(editorMode !== 'storyboard') return;
            if(sceneIdx === 0) return; // Can't drag first scene
            e.preventDefault();
            
            draggedSceneIdx = sceneIdx;
            draggedImageIndex = null;
            isDragging = true;
            dragStartY = e.clientY;
            
            document.body.classList.add('is-dragging-image');
            e.target.closest('.scene-divider').classList.add('being-dragged');
        }
        
        // Global mouse move handler
        document.addEventListener('mousemove', function(e){
            if(!isDragging) return;
            if(draggedImageIndex === null && draggedSceneIdx === null) return;
            
            // Remove existing indicators and highlights
            document.querySelectorAll('.drop-indicator-line').forEach(el => el.remove());
            document.querySelectorAll('.scene-divider.drop-target').forEach(el => el.classList.remove('drop-target'));
            
            // Check if over a scene-divider (for replacing image)
            const sceneDivider = document.elementFromPoint(e.clientX, e.clientY)?.closest('.scene-divider');
            if(sceneDivider && draggedImageIndex !== null){
                sceneDivider.classList.add('drop-target');
                return; // Don't show line indicator if over scene-divider
            }
            
            // Show drop indicator between lines
            const editor = document.getElementById('richEditor');
            if(!editor) return;
            
            const editorRect = editor.getBoundingClientRect();
            const isOverEditor = e.clientX >= editorRect.left && e.clientX <= editorRect.right &&
                                 e.clientY >= editorRect.top && e.clientY <= editorRect.bottom;
            
            if(isOverEditor){
                const lines = document.querySelectorAll('.scene-line');
                const numLines = lines.length;
                const dropY = e.clientY;
                
                let insertAfterLineIdx = -1;
                let insertAfterLine = null;
                
                lines.forEach((line) => {
                    const rect = line.getBoundingClientRect();
                    const lineMiddle = rect.top + rect.height / 2;
                    const lineIdx = parseInt(line.dataset.lineIdx);
                    
                    if(!isNaN(lineIdx) && dropY > lineMiddle) {
                        insertAfterLineIdx = lineIdx;
                        insertAfterLine = line;
                    }
                });
                
                if(insertAfterLine) {
                    const targetLineIndex = insertAfterLineIdx + 1;
                    const isEndFrame = targetLineIndex >= numLines && (draggedImageIndex !== null || draggedSceneIdx !== null);
                    
                    let indicator = document.createElement('div');
                    indicator.className = 'drop-indicator-line' + (isEndFrame ? ' end-frame' : '');
                    if(isEndFrame){
                        indicator.textContent = draggedSceneIdx !== null ? '🏁 Convert to End Frame' : '🏁 Set as End Frame';
                    } else {
                        indicator.textContent = draggedSceneIdx !== null ? '↕ Move scene here' : '◆ Insert scene here';
                    }
                    
                    insertAfterLine.parentNode.insertBefore(indicator, insertAfterLine.nextSibling);
                }
            }
        });
        
        // Global mouse up handler
        document.addEventListener('mouseup', function(e){
            if(!isDragging) return;
            
            document.body.classList.remove('is-dragging-image');
            document.querySelectorAll('.being-dragged').forEach(el => el.classList.remove('being-dragged'));
            document.querySelectorAll('.drop-indicator-line').forEach(el => el.remove());
            document.querySelectorAll('.scene-divider.drop-target').forEach(el => el.classList.remove('drop-target'));
            
            // Check if dropped on editor
            const editor = document.getElementById('richEditor');
            if(!editor){
                resetDragState();
                return;
            }
            
            const editorRect = editor.getBoundingClientRect();
            const isOverEditor = e.clientX >= editorRect.left && e.clientX <= editorRect.right &&
                                 e.clientY >= editorRect.top && e.clientY <= editorRect.bottom;
            
            // First check if dropped on a scene divider (to replace its image)
            const sceneDivider = document.elementFromPoint(e.clientX, e.clientY)?.closest('.scene-divider');
            if(sceneDivider && draggedImageIndex !== null){
                const sceneIdx = parseInt(sceneDivider.dataset.sceneIdx);
                if(!isNaN(sceneIdx) && sceneIdx >= 0 && sceneIdx < sceneBreaks.length){
                    sceneBreaks[sceneIdx].imgIndex = draggedImageIndex;
                    renderStoryboard();
                    resetDragState();
                    return;
                }
            }
            
            // Then check if dropped between lines in the editor
            if(isOverEditor){
                // Find drop target
                const lines = document.querySelectorAll('.scene-line');
                const numLines = lines.length;
                const dropY = e.clientY;
                
                let targetLineIndex = 0;
                lines.forEach((line) => {
                    const rect = line.getBoundingClientRect();
                    const lineMiddle = rect.top + rect.height / 2;
                    const lineIdx = parseInt(line.dataset.lineIdx);
                    
                    if(!isNaN(lineIdx) && dropY > lineMiddle) {
                        targetLineIndex = lineIdx + 1;
                    }
                });
                
                // Handle the drop
                if(draggedImageIndex !== null){
                    if(targetLineIndex >= numLines && numLines > 0){
                        // Set as End Frame
                        lastFrameIndex = draggedImageIndex;
                    } else if(targetLineIndex > 0){
                        // Create/update scene break
                        const existingBreakIdx = sceneBreaks.findIndex(sb => sb.lineIndex === targetLineIndex);
                        if(existingBreakIdx !== -1){
                            // Update existing scene's image, preserve clipMode
                            sceneBreaks[existingBreakIdx].imgIndex = draggedImageIndex;
                            // Ensure clipMode exists
                            if(!sceneBreaks[existingBreakIdx].clipMode){
                                sceneBreaks[existingBreakIdx].clipMode = 'blend';
                            }
                        } else {
                            sceneBreaks.push({ 
                                lineIndex: targetLineIndex, 
                                imgIndex: draggedImageIndex, 
                                clipMode: 'blend',
                                transition: 'blend'
                            });
                        }
                    }
                } else if(draggedSceneIdx !== null){
                    if(draggedSceneIdx > 0 && draggedSceneIdx < sceneBreaks.length){
                        if(targetLineIndex >= numLines && numLines > 0){
                            // Dropped below last line - set scene's image as End Frame and remove scene
                            lastFrameIndex = sceneBreaks[draggedSceneIdx].imgIndex;
                            sceneBreaks.splice(draggedSceneIdx, 1);
                        } else if(targetLineIndex > 0 && targetLineIndex < numLines){
                            // Normal move within valid range
                            if(targetLineIndex !== sceneBreaks[draggedSceneIdx].lineIndex){
                                sceneBreaks[draggedSceneIdx].lineIndex = targetLineIndex;
                            }
                        }
                    }
                }
                
                renderStoryboard();
            }
            
            resetDragState();
        });
        
        function resetDragState(){
            isDragging = false;
            draggedImageIndex = null;
            draggedSceneIdx = null;
        }
        
        // Keep old handlers for compatibility but they won't be used
        function handleImageDragStart(e, imgIndex){ e.preventDefault(); }
        function handleSceneDragStart(e, sceneIdx){ e.preventDefault(); }
        
        function handleEditorDragOver(e){
            if(editorMode !== 'storyboard') return;
            if(draggedImageIndex === null && draggedSceneIdx === null) return;
            
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = draggedSceneIdx !== null ? 'move' : 'copy';
            
            // Get all lines
            const lines = document.querySelectorAll('.scene-line');
            const numLines = lines.length;
            const dropY = e.clientY;
            
            // Remove all existing indicators
            document.querySelectorAll('.drop-indicator-line').forEach(el => el.remove());
            
            // Find which line we're after
            let insertAfterLineIdx = -1;
            let insertAfterLine = null;
            
            lines.forEach((line) => {
                const rect = line.getBoundingClientRect();
                const lineMiddle = rect.top + rect.height / 2;
                const lineIdx = parseInt(line.dataset.lineIdx);
                
                if(!isNaN(lineIdx) && dropY > lineMiddle) {
                    insertAfterLineIdx = lineIdx;
                    insertAfterLine = line;
                }
            });
            
            // Create indicator and insert it after the target line
            if(insertAfterLine) {
                const targetLineIndex = insertAfterLineIdx + 1;
                const isEndFrame = targetLineIndex >= numLines && draggedImageIndex !== null;
                
                let indicator = document.createElement('div');
                indicator.className = 'drop-indicator-line' + (isEndFrame ? ' end-frame' : '');
                indicator.textContent = isEndFrame ? '🏁 Set as End Frame' : '◆ Insert scene here';
                
                // Insert after the target line
                insertAfterLine.parentNode.insertBefore(indicator, insertAfterLine.nextSibling);
            }
        }
        
        function handleEditorDragLeave(e){
            // Only remove if actually leaving the editor (not entering a child)
            const editor = document.getElementById('richEditor');
            const rect = editor.getBoundingClientRect();
            if(e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom){
                document.querySelectorAll('.drop-indicator-line').forEach(el => el.remove());
            }
        }
        
        function handleEditorDrop(e){
            e.preventDefault();
            document.querySelectorAll('.drop-indicator-line').forEach(el => el.remove());
            document.querySelectorAll('.scene-divider.dragging').forEach(el => el.classList.remove('dragging'));
            
            if(editorMode !== 'storyboard') return;
            if(draggedImageIndex === null && draggedSceneIdx === null) return;
            
            // Find which line we're dropping AFTER (insert point between lines)
            const editor = document.getElementById('richEditor');
            const lines = editor.querySelectorAll('.scene-line');
            const numLines = lines.length;
            let targetLineIndex = 0;
            
            const dropY = e.clientY;
            lines.forEach((line) => {
                const rect = line.getBoundingClientRect();
                const lineMiddle = rect.top + rect.height / 2;
                const lineIdx = parseInt(line.dataset.lineIdx);
                
                // If we're past the middle of this line, insert after it
                if(!isNaN(lineIdx) && dropY > lineMiddle){
                    targetLineIndex = lineIdx + 1; // Insert AFTER this line
                }
            });
            
            if(draggedSceneIdx !== null){
                // Moving an existing scene divider
                if(draggedSceneIdx > 0 && draggedSceneIdx < sceneBreaks.length && targetLineIndex > 0 && targetLineIndex < numLines){
                    // Can't move to line 0 (first scene is fixed there)
                    // Can't move beyond last line
                    if(targetLineIndex !== sceneBreaks[draggedSceneIdx].lineIndex){
                        sceneBreaks[draggedSceneIdx].lineIndex = targetLineIndex;
                    }
                }
                draggedSceneIdx = null;
            } else if(draggedImageIndex !== null){
                // Dropping image from sidebar
                
                // Check if dropping AFTER the last line - this sets the Last Frame
                if(targetLineIndex >= numLines && numLines > 0){
                    lastFrameIndex = draggedImageIndex;
                    console.log('Set Last Frame to image', draggedImageIndex);
                } 
                // Dropping between lines - creates/updates scene break
                else if(targetLineIndex > 0){
                    const existingBreakIdx = sceneBreaks.findIndex(sb => sb.lineIndex === targetLineIndex);
                    if(existingBreakIdx !== -1){
                        // Update existing scene's image, preserve clipMode
                        sceneBreaks[existingBreakIdx].imgIndex = draggedImageIndex;
                        // Ensure clipMode exists
                        if(!sceneBreaks[existingBreakIdx].clipMode){
                            sceneBreaks[existingBreakIdx].clipMode = 'blend';
                        }
                    } else {
                        // Add new scene break
                        sceneBreaks.push({ 
                            lineIndex: targetLineIndex, 
                            imgIndex: draggedImageIndex, 
                            clipMode: 'blend',
                            transition: 'blend'
                        });
                    }
                }
                // targetLineIndex === 0 means drop before first line - ignore
                
                draggedImageIndex = null;
            }
            
            renderStoryboard();
        }
        
        function updateStoryboardSummary(){
            const summary = document.getElementById('storyboardSummary');
            if(!summary) return;
            
            const dialogueLines = getDialogueLines();
            const numClips = dialogueLines.length;
            const numImages = uploadedFilesData.length;
            
            let summaryHtml = `
                <div class="summary-item"><strong>${numImages}</strong> images</div>
                <div class="summary-item"><strong>${numClips}</strong> clips</div>
            `;
            
            if(numClips === 0){
                summaryHtml += `<div class="summary-item warn">⚠️ Add dialogue</div>`;
            } else if(editorMode === 'auto'){
                summaryHtml += `<div class="summary-item ok">✓ Auto-cycle: images repeat every ${numImages} clips</div>`;
            } else if(sceneBreaks.length > 1){
                summaryHtml += `<div class="summary-item ok">✓ ${sceneBreaks.length} scenes defined</div>`;
            } else {
                summaryHtml += `<div class="summary-item ok">✓ Ready</div>`;
            }
            
            summary.innerHTML = summaryHtml;
        }
        
        function truncateName(name, maxLen){
            if(name.length <= maxLen) return name;
            const ext = name.split('.').pop();
            const base = name.substring(0, name.length - ext.length - 1);
            const availableLen = maxLen - ext.length - 4;
            return base.substring(0, availableLen) + '...' + ext;
        }
        
        // Legacy handlers (unused but kept for compatibility)
        function handleDragStart(e, index){ e.preventDefault(); }
        function handleDragOver(e){ e.preventDefault(); }
        function handleDrop(e, targetIndex){ e.preventDefault(); }
        function handleDragEnd(e){ draggedImageIndex = null; }
        
        function addImageToStoryboard(){
            document.getElementById('fileInput').click();
        }
        
        document.querySelectorAll('.toggle').forEach(t=>{
            // Skip autosplit toggles - they have their own handler
            if(t.id === 'autoSplitToggle' || t.id === 'autoSplitToggleStoryboard') return;
            t.onclick=()=>{t.classList.toggle('active');t.dataset.value=t.classList.contains('active')};
        });
        // AI Prompts seg handler
        document.querySelectorAll('#aiSeg button').forEach(btn => {
            btn.addEventListener('click', function(){
                const isAIEnabled = this.dataset.value==='true';
                document.getElementById('customPromptSection').style.display=isAIEnabled?'none':'block';
                document.getElementById('contextSection').style.display=isAIEnabled?'block':'none';
            });
        });
        // Interpolation seg handler
        document.querySelectorAll('#interpSeg button').forEach(btn => {
            btn.addEventListener('click', function(){
                if(isStoryboardMode()) renderStoryboard();
                else validateDialogueLines();
            });
        });
        
        // Update storyboard when dialogue changes
        document.getElementById('dialogueInput').addEventListener('input', function(){
            if(isStoryboardMode()){
                clearTimeout(window.storyboardUpdateTimeout);
                window.storyboardUpdateTimeout = setTimeout(renderStoryboard, 300);
            } else {
                // In simple mode, auto-split if text doesn't have line numbers
                clearTimeout(window.validateTimeout);
                window.validateTimeout = setTimeout(() => {
                    autoSplitIfNeeded();
                    validateDialogueLines();
                }, 500);
            }
        });
        
        // Auto-split on paste in simple mode
        document.getElementById('dialogueInput').addEventListener('paste', function(){
            if(!isStoryboardMode()){
                setTimeout(() => {
                    autoSplitIfNeeded();
                    validateDialogueLines();
                }, 100);
            }
        });
        
        function autoSplitIfNeeded(){
            const input = document.getElementById('dialogueInput');
            const text = input.value.trim();
            if(!text) return;
            
            // Check if text already has line numbers (1|, 2|, etc.)
            const lines = text.split('\n').filter(l => l.trim());
            const hasLineNumbers = lines.every(l => /^\d+\|/.test(l.trim()));
            
            // Check if auto-split is enabled
            const autoSplitEnabled = isAutoSplitEnabled();
            
            if(!hasLineNumbers && text.length > 50){
                if(autoSplitEnabled) {
                    // AUTO-SPLIT ON: Split the raw text into clips based on speaking rate
                    const language = document.getElementById('language').value;
                    const wps = SPEAKING_RATES[language] || 2.5;
                    
                    // Use custom words per line if set, otherwise calculate from speaking rate
                    const customWords = parseInt(document.getElementById('wordsPerLine')?.value) || 0;
                    const targetWords = customWords > 0 ? customWords : Math.round(wps * 6);
                    const minWords = Math.round(targetWords * 0.7);
                    const maxWords = Math.round(targetWords * 1.3);
                    
                    const splitLines = smartSplitText(text, minWords, targetWords, maxWords);
                    const formatted = splitLines.map((line, i) => `${i + 1}|${line}`).join('\n');
                    input.value = formatted;
                    
                    // Show brief status
                    const status = document.getElementById('splitStatus');
                    if(status){
                        status.style.display = 'block';
                        status.textContent = `✓ Auto-split into ${splitLines.length} clips`;
                        status.style.color = 'var(--success)';
                        setTimeout(() => { status.style.display = 'none'; }, 3000);
                    }
                } else {
                    // AUTO-SPLIT OFF: Each line in input = 1 clip (just add line numbers)
                    const manualLines = text.split('\n').map(l => l.trim()).filter(l => l);
                    const formatted = manualLines.map((line, i) => `${i + 1}|${line}`).join('\n');
                    input.value = formatted;
                    
                    // Show brief status
                    const status = document.getElementById('splitStatus');
                    if(status){
                        status.style.display = 'block';
                        status.textContent = `✓ ${manualLines.length} lines (1 line = 1 clip)`;
                        status.style.color = 'var(--accent)';
                        setTimeout(() => { status.style.display = 'none'; }, 3000);
                    }
                }
            }
        }
        
        // Legacy function kept for compatibility
        function autoSplitScript(){
            autoSplitIfNeeded();
            validateDialogueLines();
        }
        
        function validateDialogueLines(){
            const input=document.getElementById('dialogueInput').value.trim(),container=document.getElementById('lineValidation'),language=document.getElementById('language').value;
            const lines=input.split('\n').filter(l=>l.trim()),formattedLines=lines.filter(l=>/^\d+\|/.test(l.trim()));
            if(!formattedLines.length){container.style.display='none';return;}
            
            // Use custom words per line if set
            const wps=SPEAKING_RATES[language]||2.5;
            const customWords = parseInt(document.getElementById('wordsPerLine')?.value) || 0;
            const targetWords = customWords > 0 ? customWords : Math.round(wps*6);
            const minWords=Math.max(8,targetWords-5),maxWords=targetWords+8;
            
            // Calculate image assignments
            const numImages=uploadedImages.length;
            const useInterpolation=(document.querySelector('#interpSeg button.active')?.dataset.value||'true')==='true';
            const numPairs=useInterpolation?(numImages>1?numImages-1:1):numImages;
            const singleImageMode=numImages===1;
            
            const totalLines = formattedLines.length;
            let html='',issues=0,okCount=0;
            formattedLines.forEach((line,idx)=>{
                const parts=line.split('|');if(parts.length<2)return;
                const lineNum=parts[0].trim(),text=parts.slice(1).join('|').trim(),wordCount=text.split(/\s+/).filter(w=>w).length,duration=(wordCount/wps).toFixed(1);
                const isLastLine = idx === totalLines - 1;
                let sc,st,si;
                
                if(isLastLine){
                    // LAST LINE: Always OK - can be 4-8 seconds, pick best duration dynamically
                    const estDuration = wordCount / wps;
                    const bestDuration = estDuration <= 4 ? 4 : (estDuration <= 6 ? 6 : 8);
                    sc='line-ok';st='✓ OK';si=`Last clip: ${bestDuration}s`;okCount++;
                } else if(wordCount<minWords){
                    sc='line-short';st='⚠️ Too short';si=`Need ${minWords-wordCount}+ more`;issues++;
                } else if(wordCount>maxWords){
                    sc='line-long';st='⚠️ Too long';si=`${wordCount-maxWords} over`;issues++;
                } else {
                    sc='line-ok';st='✓ OK';si='';okCount++;
                }
                
                // Calculate which images this clip will use
                let imageInfo='';
                if(numImages>0){
                    if(singleImageMode){
                        imageInfo=`<span class="line-images" title="Using single image for all clips">🖼 Image 1</span>`;
                    }else{
                        const pairIdx=idx%numPairs;
                        if(useInterpolation){
                            const startImg=pairIdx+1;
                            const endImg=pairIdx+2>numImages?1:pairIdx+2;
                            imageInfo=`<span class="line-images" title="Start: Image ${startImg}, End: Image ${endImg}">🖼 ${startImg} → ${endImg}</span>`;
                        }else{
                            const imgNum=pairIdx+1;
                            imageInfo=`<span class="line-images" title="Using Image ${imgNum}">🖼 Image ${imgNum}</span>`;
                        }
                    }
                }
                
                html+=`<div class="line-check ${sc}"><span class="line-num">#${lineNum}</span><span class="line-status">${st}</span>${imageInfo}<span class="line-info">${wordCount} words → ~${duration}s ${si?'('+si+')':''}</span></div>`;
            });
            container.innerHTML=(issues===0?`<div class="validation-summary all-ok">✓ All ${okCount} lines ready (last clip: dynamic 4-8s)</div>`:`<div class="validation-summary has-issues">⚠️ ${issues} line${issues>1?'s':''} need adjustment</div>`)+'<div class="line-validation">'+html+'</div>';
            container.style.display='block';
        }
        document.getElementById('language').addEventListener('change', function(){
            if(isStoryboardMode()){
                // Re-split and re-render storyboard
                resplitDialogueText();
                renderStoryboard();
            } else {
                // Re-split and re-render simple editor
                resplitDialogueText();
                renderSimpleEditor();
                validateDialogueLines();
            }
        });
        
        function resplitDialogueText(){
            const dialogueInput = document.getElementById('dialogueInput');
            const text = dialogueInput.value.trim();
            if(!text) return;
            
            // Check if auto-split is enabled
            const autoSplitEnabled = isAutoSplitEnabled();
            
            if(!autoSplitEnabled) {
                // AUTO-SPLIT OFF: Don't resplit, just show a message
                const status = document.getElementById('splitStatus');
                if(status){
                    status.style.display = 'block';
                    status.textContent = `ℹ️ Auto-split is OFF - lines unchanged`;
                    status.style.color = 'var(--accent)';
                    setTimeout(() => { status.style.display = 'none'; }, 3000);
                }
                return;
            }
            
            // Get all text content (remove line numbers if present)
            const rawText = text.split('\n')
                .map(line => line.replace(/^\d+\|/, '').trim())
                .filter(line => line)
                .join(' ');
            
            if(!rawText) return;
            
            // Re-split with new language settings
            const language = document.getElementById('language').value;
            const wps = SPEAKING_RATES[language] || 2.5;
            const targetWords = Math.round(wps * 6);
            const minWords = Math.round(targetWords * 0.7);
            const maxWords = Math.round(targetWords * 1.3);
            
            const newLines = smartSplitText(rawText, minWords, targetWords, maxWords);
            
            // Update dialogueInput with new splits
            dialogueInput.value = newLines.map((l, i) => `${i + 1}|${l}`).join('\n');
            
            // Show status
            const status = document.getElementById('splitStatus');
            if(status && newLines.length > 0){
                status.style.display = 'block';
                status.textContent = `✓ Re-split for ${language}: ${newLines.length} clips (~${Math.round(targetWords)} words each)`;
                status.style.color = 'var(--success)';
                setTimeout(() => { status.style.display = 'none'; }, 3000);
            }
        }
        
        // Estimate speech duration for a line of text
        function estimateSpeechDuration(text, language){
            const wps = SPEAKING_RATES[language] || 2.5;
            const words = text.trim().split(/\s+/).filter(w => w).length;
            return words / wps;
        }
        
        // Validate all lines are within acceptable duration
        function validateLineDurations(lines, language, maxDuration = 6.5){
            const warnings = [];
            const errors = [];
            
            lines.forEach((line, idx) => {
                // Extract text (remove line number prefix if present)
                let text = line;
                const parts = line.split('|');
                if(parts.length >= 2){
                    text = parts.slice(1).join('|').trim();
                }
                
                const duration = estimateSpeechDuration(text, language);
                const wordCount = text.trim().split(/\s+/).filter(w => w).length;
                
                if(duration > 7.5){
                    errors.push({
                        lineNum: idx + 1,
                        text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
                        duration: duration.toFixed(1),
                        words: wordCount,
                        severity: 'error'
                    });
                } else if(duration > maxDuration){
                    warnings.push({
                        lineNum: idx + 1,
                        text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
                        duration: duration.toFixed(1),
                        words: wordCount,
                        severity: 'warning'
                    });
                }
            });
            
            return { warnings, errors, hasErrors: errors.length > 0 };
        }
        
        async function createJob(){
            const btn=document.getElementById('startBtn');btn.disabled=true;btn.innerHTML='⏳ Starting...';
            try{
                const numImages = uploadedImages.length;
                const linesList = document.getElementById('dialogueInput').value.trim().split('\n').filter(l=>l.trim());
                const numClips = linesList.length;
                const language = document.getElementById('language').value;
                
                // Validate line durations BEFORE sending (just log, don't block)
                const validation = validateLineDurations(linesList, language, 6.5);
                
                if(validation.hasErrors){
                    // Log warning but don't block
                    console.warn('[Validation] Some lines may be long:', validation.errors);
                }
                
                if(validation.warnings.length > 0){
                    // Log warnings but don't block
                    console.warn('[Validation] Borderline lines:', validation.warnings);
                }
                
                // DEBUG: Log current state
                console.log('=== CREATE JOB DEBUG ===');
                console.log('Editor mode:', editorMode);
                console.log('Num images:', numImages);
                console.log('Num clips:', numClips);
                console.log('Scene breaks:', JSON.stringify(sceneBreaks));
                
                // Build scenes array for backend (Storyboard mode only)
                let scenesPayload = null;
                if(editorMode === 'storyboard' && sceneBreaks.length > 0){
                    scenesPayload = sceneBreaks.map((scene, idx) => {
                        const nextScene = sceneBreaks[idx + 1];
                        const endLine = nextScene ? nextScene.lineIndex : numClips;
                        const clipIndices = [];
                        for(let c = scene.lineIndex; c < endLine; c++) clipIndices.push(c);
                        
                        // CRITICAL: Map local array index to server's file index
                        const serverImageIndex = uploadedFilesData[scene.imgIndex]?.index ?? scene.imgIndex;
                        
                        return {
                            sceneIndex: idx,
                            imageIndex: serverImageIndex,
                            clipMode: scene.clipMode || 'blend',      // 'blend' | 'continue' | 'fresh'
                            transition: idx === 0 ? null : (scene.transition || 'blend'),  // 'blend' | 'cut' | null for first
                            clips: clipIndices
                        };
                    });
                    console.log('Scenes payload:', JSON.stringify(scenesPayload, null, 2));
                }
                
                // Prepare the lines payload with image assignments
                const lines = linesList.map((l, i) => {
                    // Parse ID|Text
                    let id, text;
                    const p = l.split('|');
                    if (p.length >= 2) {
                        id = parseInt(p[0]) || i + 1;
                        text = p.slice(1).join('|').trim();
                    } else {
                        id = i + 1;
                        text = l.trim();
                    }
                    
                    // Determine which scene this line belongs to
                    let imageIdx = 0;
                    let sceneIdx = 0;
                    let clipMode = 'blend';
                    let sceneTransition = 'blend';
                    
                    if(numImages > 1){
                        if(editorMode === 'storyboard' && sceneBreaks.length > 0){
                            // === STORYBOARD MODE: Use sceneBreaks directly ===
                            for(let s = sceneBreaks.length - 1; s >= 0; s--){
                                if(i >= sceneBreaks[s].lineIndex){
                                    // CRITICAL: Map local array index to server's file index
                                    const localIdx = sceneBreaks[s].imgIndex;
                                    imageIdx = uploadedFilesData[localIdx]?.index ?? localIdx;
                                    sceneIdx = s;
                                    clipMode = sceneBreaks[s].clipMode || 'blend';
                                    sceneTransition = s > 0 ? (sceneBreaks[s].transition || 'blend') : null;
                                    break;
                                }
                            }
                        } else {
                            // === AUTO-CYCLE MODE: Round-robin ===
                            // CRITICAL: Map local array index to server's file index
                            const localIdx = i % numImages;
                            imageIdx = uploadedFilesData[localIdx]?.index ?? localIdx;
                        }
                    }
                    
                    console.log(`Line ${i}: scene=${sceneIdx}, image=${imageIdx}, clipMode=${clipMode}, transition=${sceneTransition}`);
                    
                    return {
                        id: id,
                        text: text,
                        start_image_idx: imageIdx,
                        scene_index: sceneIdx,
                        clip_mode: clipMode,           // 'blend' | 'continue' | 'fresh'
                        scene_transition: sceneTransition  // 'blend' | 'cut' | null
                    };
                }).filter(l => l.text);
                
                console.log('Final lines payload:', JSON.stringify(lines, null, 2));
                
                if(!lines.length)throw new Error('Add dialogue lines');
                if(!uploadedImages.length)throw new Error('Upload at least 1 reference image');
                const useAI=(document.querySelector('#aiSeg button.active')?.dataset.value||'true')==='true',customPrompt=document.getElementById('customPrompt')?.value?.trim()||'',contextInput=document.getElementById('contextInput')?.value?.trim()||'';
                if(!useAI&&!customPrompt)throw new Error('Enter a custom prompt or enable AI Prompts');
                
                // In storyboard mode, use_interpolation is always true (managed per-scene)
                const useInterpolation = editorMode === 'storyboard' ? true : (document.querySelector('#interpSeg button.active')?.dataset.value||'true')==='true';
                
                // Generation mode logic:
                // - 1 image: always 'parallel' (no frame chaining needed)
                // - Storyboard: always 'parallel' (has its own frame logic via scenes_data)
                // - Auto-cycle 2+ images: user's dropdown choice
                let generationMode = 'parallel';
                if (numImages > 1 && editorMode === 'auto') {
                    generationMode = document.getElementById('generationMode')?.value || 'staggered';
                }
                
                const selectedBackend = document.querySelector('#backendToggle button.active')?.dataset.value || 'auto';
                const cfg={aspect_ratio:getSelectedAspect(),resolution:getSelectedResolution(),duration:document.getElementById('duration').value,language:document.getElementById('language').value,use_interpolation:useInterpolation,use_openai_prompt_tuning:useAI,use_frame_vision:useAI,custom_prompt:useAI?'':customPrompt,user_context:useAI?contextInput:'',single_image_mode:uploadedImages.length===1,max_retries_per_clip:5,parallel_clips:1,storyboard_mode:editorMode==='storyboard',generation_mode:generationMode,backend_preference:selectedBackend,flow_variants_count:getFlowVariantsCount()};
                
                const payload = {config:cfg, dialogue_lines:lines, api_keys:{gemini_keys:[],openai_key:null}, job_id:uploadJobId};
                if(scenesPayload) payload.scenes = scenesPayload;
                // CRITICAL: Map local lastFrameIndex to server's file index
                if(lastFrameIndex !== null) {
                    payload.last_frame_index = uploadedFilesData[lastFrameIndex]?.index ?? lastFrameIndex;
                }
                
                console.log('Last frame index (local):', lastFrameIndex, '→ (server):', payload.last_frame_index);
                
                const r=await fetch(`${API}/jobs`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
                if(!r.ok){const e=await r.json();throw new Error(e.detail?.errors?.join(', ')||e.detail||'Failed');}
                const job=await r.json();
                uploadJobId=null;uploadedImages=[];
                document.getElementById('lineValidation').style.display='none';document.getElementById('splitStatus').style.display='none';
                setActiveState();hasJobs=true;await refreshJobsList();selectedJobId=null;selectJob(job.id);
                btn.innerHTML='✓ Started!';setTimeout(()=>{btn.innerHTML='🚀 Start Generation';},2000);
            }catch(e){alert(e.message);btn.innerHTML='🚀 Start Generation';}
            btn.disabled=false;
        }
        
        async function refreshJobs(){try{const r=await fetch(`${API}/jobs`);const jobs=await r.json();if(jobs.length>0){hasJobs=true;setActiveState();}await refreshJobsList();}catch(e){}}
        async function refreshJobsList(){
            try{const r=await fetch(`${API}/jobs`);const jobs=await r.json();const c=document.getElementById('jobsList');
            if(!jobs.length){c.innerHTML='<div class="empty"><h3>No jobs yet</h3></div>';return;}
            c.innerHTML=jobs.map(j=>`<div class="job-item ${selectedJobId===j.id?'selected':''}" onclick="selectJob('${j.id}')"><div class="job-header"><span class="badge badge-${j.status}">${j.status}</span><span class="job-id">${j.id.slice(0,8)}</span></div><div class="progress-bar"><div class="progress-fill" style="width:${j.progress_percent}%"></div></div><div class="progress-text"><span>${j.progress_percent.toFixed(0)}%</span><span>${j.completed_clips}/${j.total_clips}</span></div></div>`).join('');}catch(e){}
        }
        
        // Global jobs list refresh timer (updates all jobs periodically)
        let globalJobsRefreshTimer = null;
        function startGlobalJobsRefresh(){
            if(globalJobsRefreshTimer) return; // Already running
            globalJobsRefreshTimer = setInterval(()=>{
                refreshJobsList();
            }, 30000); // Refresh every 30 seconds
        }
        function stopGlobalJobsRefresh(){
            if(globalJobsRefreshTimer){
                clearInterval(globalJobsRefreshTimer);
                globalJobsRefreshTimer = null;
            }
        }
        // Start global refresh when page loads
        startGlobalJobsRefresh();
        
        // Track last redo request time globally - keep polling for 90s after redo
        let lastRedoRequestTime = 0;
        const REDO_GRACE_PERIOD_MS = 90000; // 90 seconds grace period after redo
        
        function selectJob(id){
            if(selectedJobId===id)return;selectedJobId=id;lastLogId=0;clipStates={};
            setActiveState(); // Reopen Review panel when selecting a job
            document.getElementById('noJob').style.display='none';document.getElementById('jobDetails').style.display='block';
            document.getElementById('jobInfo').innerHTML='<div style="color:var(--text-muted)">Loading...</div>';
            document.getElementById('clipsList').innerHTML='<div style="color:var(--text-muted);text-align:center;padding:20px">Loading...</div>';
            document.getElementById('logs').innerHTML='';
            document.querySelectorAll('.job-item').forEach(el=>el.classList.remove('selected'));
            const item=document.querySelector(`.job-item[onclick*="${id}"]`);if(item)item.classList.add('selected');
            loadJob(id);loadClips(id);loadLogs(id);
            let pollTimer=null;
            let lastJobStatus = null;
            let previousClipStates = {}; // Track clip states to detect changes
            (function startPolling(){
                if(pollTimer)clearInterval(pollTimer);
                window._completionGraceStart = null; // Reset grace period for new job
                // Poll every 5 seconds
                pollTimer=setInterval(async()=>{
                    if(selectedJobId!==id){clearInterval(pollTimer);return;}
                    const jr=await fetch(`${API}/jobs/${id}`).catch(()=>null);if(!jr)return;const job=await jr.json();
                    
                    // Update job info panel
                    const skippedStatPoll=job.skipped_clips>0?`<div class="stat"><div class="stat-val" style="color:#f59e0b">${job.skipped_clips}</div><div class="stat-lbl">Skipped</div></div>`:'';
                    document.getElementById('jobInfo').innerHTML=`<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px"><span class="badge badge-${job.status}">${job.status}</span><span class="job-id">${job.id}</span></div><div class="progress-bar" style="height:6px"><div class="progress-fill ${job.status==='running'||job.status==='processing'?'generating':''}" style="width:${job.progress_percent}%"></div></div><div class="stats-row"><div class="stat"><div class="stat-val">${job.total_clips}</div><div class="stat-lbl">Total</div></div><div class="stat"><div class="stat-val" style="color:var(--success)">${job.completed_clips}</div><div class="stat-lbl">Done</div></div><div class="stat"><div class="stat-val" style="color:var(--error)">${job.failed_clips}</div><div class="stat-lbl">Failed</div></div>${skippedStatPoll}</div>`;
                    const missingClipsBtnPoll=job.skipped_clips>0?`<button class="btn btn-warning btn-sm" onclick="downloadMissingClips('${job.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;background:#f59e0b;color:#000;" title="Download Excel with skipped clip details">📋 Missing Clips</button>`:'';
                    document.getElementById('jobActions').innerHTML=`<div style="display:flex;gap:6px;align-items:center;">${job.status==='running'?`<button class="btn btn-danger btn-sm" onclick="cancelJob('${job.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">⏹ Stop</button>`:''}${job.status==='paused'?`<button class="btn btn-success btn-sm" onclick="resumeJob('${job.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">▶️ Resume</button>`:''}${job.status==='completed'?`<button class="btn btn-primary btn-sm" onclick="downloadAll('${job.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">📥 Download</button>`:''}<button class="btn btn-secondary btn-sm" onclick="cloneJob('${job.id}')" title="Clone settings" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">📋 Clone</button>${missingClipsBtnPoll}<button class="btn btn-secondary btn-sm" onclick="deleteJob('${job.id}')" title="Delete job" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">🗑</button></div>`;
                    
                    // Only reload clips if job is actively running OR status changed
                    const statusChanged = lastJobStatus !== job.status;
                    lastJobStatus = job.status;
                    
                    // Reload clips while job is active
                    if(job.status === 'running' || job.status === 'pending' || job.status === 'processing') {
                        loadClips(id);
                    }
                    // On status change to completed/failed, clear cache and reload
                    if(statusChanged && (job.status === 'completed' || job.status === 'failed')) {
                        console.log('[Polling] Status changed to ' + job.status + ' — refreshing all clips');
                        clipStates = {};
                        loadClips(id);
                        // Delayed retry in case DB hasn't fully committed
                        setTimeout(() => { clipStates = {}; loadClips(id); }, 3000);
                    }
                    
                    // Always update logs
                    loadLogs(id);
                    
                    // Update job list less frequently (only on status change)
                    if(statusChanged) {
                        refreshJobsList();
                    }
                    
                    // Stop polling if job is completed/failed/cancelled
                    if(job.status === 'completed' || job.status === 'failed' || job.status === 'cancelled') {
                        // Check if we're in the redo grace period (90 seconds after a redo request)
                        const inRedoGracePeriod = (Date.now() - lastRedoRequestTime) < REDO_GRACE_PERIOD_MS;
                        
                        if (inRedoGracePeriod) {
                            // Keep polling during redo grace period — clips might change
                            loadClips(id);
                        } else if (!window._completionGraceStart) {
                            // Job just completed — start a 10s grace period to catch trailing variant uploads
                            window._completionGraceStart = Date.now();
                            console.log('[Polling] Job done, entering grace period...');
                            loadClips(id);
                            refreshJobsList();
                        } else if ((Date.now() - window._completionGraceStart) < 10000) {
                            // Still in grace period — poll for late updates (incremental diff handles changes)
                            loadClips(id);
                        } else {
                            // Grace period over — stop polling
                            console.log('[Polling] Grace period over, stopping polling');
                            window._completionGraceStart = null;
                            clearInterval(pollTimer);
                        }
                    }
                },5000);
            })();
        }
        
        async function loadJob(id){if(id !== selectedJobId)return;try{const r=await fetch(`${API}/jobs/${id}`);if(id !== selectedJobId)return;if(!r.ok)return;const j=await r.json();const skippedStat=j.skipped_clips>0?`<div class="stat"><div class="stat-val" style="color:#f59e0b">${j.skipped_clips}</div><div class="stat-lbl">Skipped</div></div>`:'';document.getElementById('jobInfo').innerHTML=`<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px"><span class="badge badge-${j.status}">${j.status}</span><span class="job-id">${j.id}</span></div><div class="progress-bar" style="height:6px"><div class="progress-fill ${j.status==='running'||j.status==='processing'?'generating':''}" style="width:${j.progress_percent}%"></div></div><div class="stats-row"><div class="stat"><div class="stat-val">${j.total_clips}</div><div class="stat-lbl">Total</div></div><div class="stat"><div class="stat-val" style="color:var(--success)">${j.completed_clips}</div><div class="stat-lbl">Done</div></div><div class="stat"><div class="stat-val" style="color:var(--error)">${j.failed_clips}</div><div class="stat-lbl">Failed</div></div>${skippedStat}</div>`;const missingClipsBtn=j.skipped_clips>0?`<button class="btn btn-warning btn-sm" onclick="downloadMissingClips('${j.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;background:#f59e0b;color:#000;" title="Download Excel with skipped clip details">📋 Missing Clips</button>`:'';document.getElementById('jobActions').innerHTML=`<div style="display:flex;gap:6px;align-items:center;">${j.status==='running'?`<button class="btn btn-danger btn-sm" onclick="cancelJob('${j.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">⏹ Stop</button>`:''}${j.status==='paused'?`<button class="btn btn-success btn-sm" onclick="resumeJob('${j.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">▶️ Resume</button>`:''}${j.status==='completed'?`<button class="btn btn-primary btn-sm" onclick="downloadAll('${j.id}')" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">📥 Download</button>`:''}<button class="btn btn-secondary btn-sm" onclick="cloneJob('${j.id}')" title="Clone settings" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">📋 Clone</button>${missingClipsBtn}<button class="btn btn-secondary btn-sm" onclick="deleteJob('${j.id}')" title="Delete job" style="padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;">🗑</button></div>`;}catch(e){}}
        
        let _loadClipsGeneration = 0; // Monotonic counter to discard stale responses
        async function loadClips(id){
            // GUARD: Only load clips if this is still the selected job
            // This prevents race conditions when switching between jobs
            if(id !== selectedJobId) {
                console.log(`[loadClips] Skipping load for job ${id} - current job is ${selectedJobId}`);
                return;
            }
            const myGen = ++_loadClipsGeneration; // Capture generation BEFORE fetch
            try{const r=await fetch(`${API}/jobs/${id}/clips`);
            // Double-check after async call - job might have changed while fetching
            if(id !== selectedJobId) {
                console.log(`[loadClips] Job changed during fetch, discarding results for ${id}`);
                return;
            }
            // Discard stale responses: if another loadClips was called after us, our data is outdated
            if(myGen !== _loadClipsGeneration) {
                console.log(`[loadClips] Discarding stale response (gen ${myGen} < ${_loadClipsGeneration})`);
                return;
            }
            if(!r.ok)return;const clips=await r.json();const c=document.getElementById('clipsList');
            cachedClipsData = clips; cachedJobId = id;
            if(!clips.length){c.innerHTML='<p style="color:var(--text-muted);text-align:center;padding:10px">Starting...</p>';return;}
            let container=c.querySelector('.clips-grid');
            if(!container){
                const hasCompleted=clips.some(x=>x.status==='completed'),generating=clips.filter(x=>x.status==='generating'||x.status==='pending'||x.status==='redo_queued'||x.status==='flow_redo_queued');
                let bannerHtml='';
                if(generating.length>0){const done=clips.filter(x=>x.status==='completed'||x.status==='failed').length,total=clips.length;bannerHtml=`<div class="generation-progress"><div class="gen-status">🎬 Generating clip ${done+1} of ${total}...</div><div class="gen-bar"><div class="gen-bar-fill" style="width:${(done/total)*100}%"></div></div></div>`;}
                else if(hasCompleted){try{const rs=await fetch(`${API}/jobs/${id}/review-status`).then(r=>r.json());if(myGen !== _loadClipsGeneration) return; // Stale after review-status fetch
                const reviewKey=`${rs.all_approved}|${rs.can_export}|${rs.approved}|${rs.pending_review}|${rs.failed}`;if(rs.all_approved)bannerHtml=`<div class="review-banner" data-review-key="${reviewKey}" style="background:var(--success)"><h3>✅ All Approved</h3><div style="display:flex;gap:8px"><button class="btn btn-secondary btn-sm" onclick="downloadAll('${id}')" title="Download all approved clips">📥 Download</button><button class="btn btn-primary btn-sm" onclick="exportFinalVideo('${id}')" title="Combine clips into final video">🎬 Export Final</button></div></div>`;else if(rs.can_export){const failedNote=rs.failed>0?`<span style="font-size:11px;opacity:0.8;margin-left:8px">(${rs.failed} failed)</span>`:'';bannerHtml=`<div class="review-banner" data-review-key="${reviewKey}" style="background:#22c55e"><h3>✅ ${rs.approved} Clips Ready${failedNote}</h3><div style="display:flex;gap:8px"><button class="btn btn-secondary btn-sm" onclick="downloadAll('${id}')" title="Download approved clips">📥 Download</button><button class="btn btn-primary btn-sm" onclick="exportFinalVideo('${id}')" title="Export approved clips">🎬 Export Final</button></div></div>`;}else if(rs.pending_review>0)bannerHtml=`<div class="review-banner" data-review-key="${reviewKey}"><h3>📋 Review</h3><div class="review-stats"><div class="review-stat"><div class="review-stat-val">${rs.approved}</div><div class="review-stat-lbl">OK</div></div><div class="review-stat"><div class="review-stat-val">${rs.pending_review}</div><div class="review-stat-lbl">Pending</div></div></div></div>`;}catch(e){}}
                const hasAnyVariants = clips.some(x => (x.total_variants || (x.versions||[]).length || 1) > 1);
                const expandBtn = hasAnyVariants ? `<div style="display:flex;justify-content:flex-end;margin-bottom:8px;"><button id="expandToggleBtn" class="expand-toggle" onclick="toggleVariantsExpanded()">${variantsExpanded ? '⊟ Collapse' : '⊞ Expand'}</button></div>` : '';
                c.innerHTML=bannerHtml+expandBtn+`<div class="clips-grid ${variantsExpanded ? 'expanded-mode' : ''}" data-exports-loaded="true">${clips.map(x=>renderClip(x,id)).join('')}</div>`;
                clips.forEach(clip=>{clipStates[clip.clip_index]=getClipStateKey(clip);});loadExistingExports(id);
                // Preload variant videos for instant switching
                clips.forEach(clip => preloadClipVariants(clip, id));
                // Update voice clip button states for this job
                setTimeout(() => updateClipVoiceButtons(id), 100);
                return;
            }
            clips.forEach((clip) => {
                const newState = getClipStateKey(clip);
                const oldState = clipStates[clip.clip_index];
                if (newState !== oldState) {
                    // Re-query cards each time since outerHTML replacement invalidates NodeList references
                    const freshCards = container.querySelectorAll('.clip-card');
                    if (freshCards[clip.clip_index]) {
                        freshCards[clip.clip_index].outerHTML = renderClip(clip, id);
                    }
                    clipStates[clip.clip_index] = newState;
                    preloadClipVariants(clip, id);
                }
            });
            // Ensure expand button appears/disappears as variants become available
            const hasAnyV = clips.some(x => (x.total_variants || (x.versions||[]).length || 1) > 1);
            const existingBtn = document.getElementById('expandToggleBtn');
            if(hasAnyV && !existingBtn){
                const btnHtml = `<div style="display:flex;justify-content:flex-end;margin-bottom:8px;"><button id="expandToggleBtn" class="expand-toggle" onclick="toggleVariantsExpanded()">${variantsExpanded ? '⊟ Collapse' : '⊞ Expand'}</button></div>`;
                container.insertAdjacentHTML('beforebegin', btnHtml);
            } else if(!hasAnyV && existingBtn){
                existingBtn.parentElement.remove();
            }
            updateBanner(id,clips);
            // Load existing exports after clips are rendered (only on first load)
            if(!container.dataset.exportsLoaded){container.dataset.exportsLoaded='true';loadExistingExports(id);}
            }catch(e){}
        }
        function getClipStateKey(clip){return `${clip.status}|${clip.approval_status}|${clip.output_filename||''}|${clip.generation_attempt}|${clip.selected_variant||1}|${clip.total_variants||0}`;}
        
        async function updateBanner(jobId,clips){
            // Guard against updating banner for wrong job
            if(jobId !== selectedJobId) return;
            const c=document.getElementById('clipsList'),hasCompleted=clips.some(x=>x.status==='completed'),generating=clips.filter(x=>x.status==='generating'||x.status==='pending'||x.status==='redo_queued'||x.status==='flow_redo_queued');
            const oldProgress=c.querySelector('.generation-progress');
            
            if(generating.length>0){
                const done=clips.filter(x=>x.status==='completed'||x.status==='failed').length,total=clips.length;
                const newContent=`🎬 Generating clip ${done+1} of ${total}...`;
                const bannerHtml=`<div class="generation-progress"><div class="gen-status">${newContent}</div><div class="gen-bar"><div class="gen-bar-fill" style="width:${(done/total)*100}%"></div></div></div>`;
                
                // Remove any review banners when generating
                c.querySelectorAll('.review-banner').forEach(b => b.remove());
                
                // Only update if content changed
                if(oldProgress){
                    const oldContent=oldProgress.querySelector('.gen-status')?.textContent||'';
                    if(oldContent!==newContent) oldProgress.outerHTML=bannerHtml;
                } else {
                    c.insertAdjacentHTML('afterbegin',bannerHtml);
                }
            }
            else if(hasCompleted){
                if(oldProgress)oldProgress.remove();
                try{
                    const rs=await fetch(`${API}/jobs/${jobId}/review-status`).then(r=>r.json());
                    // Guard after async call
                    if(jobId !== selectedJobId) return;
                    
                    // Build new banner key to compare
                    const newKey=`${rs.all_approved}|${rs.can_export}|${rs.approved}|${rs.pending_review}|${rs.failed}`;
                    
                    // Check if we already have a banner with this exact state
                    const existingBanner = c.querySelector(`.review-banner[data-review-key="${newKey}"]`);
                    if(existingBanner) return; // Already showing correct state
                    
                    // Remove ALL review banners (there might be duplicates)
                    c.querySelectorAll('.review-banner').forEach(b => b.remove());
                    
                    let bannerHtml='';
                    if(rs.all_approved || rs.can_export){
                        // Add all-approved class to show buttons on all clips
                        c.classList.add('all-approved');
                    } else {
                        c.classList.remove('all-approved');
                    }
                    
                    if(rs.all_approved){
                        bannerHtml=`<div class="review-banner" data-review-key="${newKey}" style="background:var(--success)"><h3>✅ All Approved</h3><div style="display:flex;gap:8px"><button class="btn btn-secondary btn-sm" onclick="downloadAll('${jobId}')" title="Download all approved clips">📥 Download</button><button class="btn btn-primary btn-sm" onclick="exportFinalVideo('${jobId}')" title="Combine clips into final video">🎬 Export Final</button></div></div>`;
                    } else if(rs.can_export){
                        // Some clips approved, some may have failed - can still export
                        const failedNote = rs.failed > 0 ? `<span style="font-size:11px;opacity:0.8;margin-left:8px">(${rs.failed} failed)</span>` : '';
                        bannerHtml=`<div class="review-banner" data-review-key="${newKey}" style="background:#22c55e"><h3>✅ ${rs.approved} Clips Ready${failedNote}</h3><div style="display:flex;gap:8px"><button class="btn btn-secondary btn-sm" onclick="downloadAll('${jobId}')" title="Download approved clips">📥 Download</button><button class="btn btn-primary btn-sm" onclick="exportFinalVideo('${jobId}')" title="Export approved clips">🎬 Export Final</button></div></div>`;
                    } else if(rs.pending_review>0){
                        const failedNote = rs.failed > 0 ? ` • <span style="color:var(--error)">${rs.failed} Failed</span>` : '';
                        bannerHtml=`<div class="review-banner" data-review-key="${newKey}"><h3>📋 Review</h3><div class="review-stats"><div class="review-stat"><div class="review-stat-val">${rs.approved}</div><div class="review-stat-lbl">OK</div></div><div class="review-stat"><div class="review-stat-val">${rs.pending_review}</div><div class="review-stat-lbl">Pending</div></div></div></div>`;
                    }
                    if(bannerHtml){
                        const exportBanner=c.querySelector('.export-progress');
                        if(exportBanner)exportBanner.insertAdjacentHTML('afterend',bannerHtml);
                        else c.insertAdjacentHTML('afterbegin',bannerHtml);
                    }
                }catch(e){}
            } else {
                // No generation, no completed - remove all banners
                if(oldProgress)oldProgress.remove();
                c.querySelectorAll('.review-banner').forEach(b => b.remove());
            }
        }
        
        function renderClip(c,jid){
            const approved=c.approval_status==='approved',rejected=c.approval_status==='rejected',maxed=c.approval_status==='max_attempts',generating=c.status==='generating',pending=c.status==='pending',failed=c.status==='failed',skipped=c.status==='skipped',redoQueued=c.status==='redo_queued'||c.status==='flow_redo_queued',waitingApproval=c.status==='waiting_approval',isRegenerating=generating||redoQueued,canReview=c.status==='completed'&&!approved&&!maxed&&!rejected;
            const isCelebritySkipped = skipped && c.error_code === 'CELEBRITY_FILTER';
            // Use total_variants from backend (actual successful versions count)
            const totalVariants = c.total_variants || (c.versions||[]).length || 1;
            const selectedVariant=c.selected_variant||totalVariants,hasMultipleVariants=totalVariants>1;
            // Get current version's attempt.variant for display
            const versions = c.versions || [];
            const currentVersion = selectedVariant > 0 && selectedVariant <= versions.length ? versions[selectedVariant - 1] : null;
            const versionLabel = currentVersion && currentVersion.version_key ? currentVersion.version_key : (currentVersion ? `${currentVersion.attempt||1}.${currentVersion.variant||1}` : `${c.generation_attempt||1}.1`);
            let vid='';
            if(redoQueued)vid=`<div class="generating-state"><div class="generating-spinner">🔄</div><div class="generating-text">Redo queued...</div></div>`;else if(generating)vid=`<div class="generating-state"><div class="generating-spinner">🎬</div><div class="generating-text">Generating...</div></div>`;
            else if(waitingApproval)vid=`<div class="pending-state"><div class="pending-icon">⏸️</div><div class="pending-text">Awaiting<br>Approval</div></div>`;
            else if(pending)vid=`<div class="pending-state"><div class="pending-icon">⏳</div><div class="pending-text">Waiting...</div></div>`;
            else if(skipped)vid=`<div class="failed-state"><div class="failed-icon">⚠️</div><div class="failed-text">Skipped</div></div>`;
            else if(c.output_filename)vid=`<div class="video-container"><video controls preload="auto" playsinline><source src="${API}/jobs/${jid}/outputs/${c.output_filename}?t=${Date.now()}" type="video/mp4"></video><button class="video-voice-btn" data-clip="${c.output_filename}" onclick="event.stopPropagation();useClipVoice('${jid}','${c.output_filename}',${c.clip_index})" title="Select for voice reference (2-3 clips recommended)">🎤</button><button class="video-download-btn" onclick="event.stopPropagation();downloadClip('${API}/jobs/${jid}/outputs/${c.output_filename}','clip_${c.clip_index+1}.mp4')" title="Download clip">📥</button></div>`;
            else if(failed)vid=`<div class="failed-state"><div class="failed-icon">❌</div><div class="failed-text">Failed</div></div>`;
            else vid='<div style="color:var(--text-muted);font-size:10px">🎬</div>';
            let variantNav='';
            if(hasMultipleVariants&&c.output_filename&&!isRegenerating)variantNav=`<div class="variant-nav"><button class="variant-btn" onclick="switchVariant(${c.id},${selectedVariant-1})" ${selectedVariant<=1?'disabled':''}>◀</button><span class="variant-indicator">${versionLabel} (${selectedVariant}/${totalVariants})</span><button class="variant-btn" onclick="switchVariant(${c.id},${selectedVariant+1})" ${selectedVariant>=totalVariants?'disabled':''}>▶</button></div>`;
            let status=c.status,badgeClass=c.status;
            if(redoQueued){status='redo queued';badgeClass='redo_queued';}else if(generating){status='generating';badgeClass='running';}else if(skipped){status='skipped';badgeClass='skipped';}else if(failed){status='failed';badgeClass='failed';}else if(approved){status='approved';badgeClass='approved';}else if(rejected){status='rejected';badgeClass='rejected';}else if(waitingApproval){status='waiting approval';badgeClass='waiting_approval';}else if(pending){status='pending';badgeClass='running';}else if(c.status==='completed'){status=c.approval_status||'pending_review';badgeClass=status;}
            let acts='';const clipId=c.id||0;
            if(isRegenerating)acts=`<div class="clip-progress"><div class="clip-progress-bar"></div></div><div style="color:var(--text-muted);text-align:center;font-size:10px;margin-top:4px">v${c.generation_attempt} in progress...</div>`;
            else if(approved)acts=`<div style="display:flex;align-items:center;justify-content:center;gap:8px">${hasMultipleVariants?`<button class="variant-btn" onclick="switchVariant(${c.id},${selectedVariant-1})" ${selectedVariant<=1?'disabled':''}>◀</button>`:''}<span style="color:var(--success);font-size:14px">✓ Approved${hasMultipleVariants?' ('+versionLabel+')':''}</span>${hasMultipleVariants?`<button class="variant-btn" onclick="switchVariant(${c.id},${selectedVariant+1})" ${selectedVariant>=totalVariants?'disabled':''}>▶</button>`:''}<button class="btn btn-secondary btn-sm" style="padding:4px 8px;font-size:11px" onclick="downloadClip('${API}/jobs/${jid}/outputs/${c.output_filename}','clip_${c.clip_index+1}.mp4')" title="Download clip">📥</button></div>`;
            else if(rejected&&!redoQueued)acts=`<div class="rejected-notice"><span>❌ Rejected</span>${c.attempts_remaining>0&&clipId?`<button class="btn btn-redo btn-sm" onclick="redoModal(${clipId},${c.attempts_remaining},${c.clip_index})">↻ Redo (${c.attempts_remaining})</button>`:'<span>No redos</span>'}</div>`;
            else if(maxed)acts='<div class="max-notice">⚠️ Max attempts</div>';
            else if(waitingApproval)acts=`<div style="color:#f59e0b;text-align:center;font-size:10px">⏸️ Approve clip #${c.clip_index} first</div>`;
            else if(pending)acts='<div style="color:var(--text-muted);text-align:center;font-size:10px">In queue</div>';
            else if(skipped){
                let skipMsg = 'Skipped';
                if(c.error_code === 'CELEBRITY_FILTER') skipMsg = 'Celebrity filter - eligible for reimbursement';
                else if(c.error_code === 'PREVIOUS_CLIP_SKIPPED') skipMsg = 'Previous clip was skipped';
                else if(c.error_code === 'PREVIOUS_CLIP_FAILED') skipMsg = 'Previous clip failed';
                acts=`<div style="text-align:center"><div style="color:#f59e0b;font-size:10px;margin-bottom:6px">${skipMsg}</div></div>`;
            }
            else if(failed)acts=`<div style="text-align:center"><div style="color:var(--error);font-size:10px;margin-bottom:6px">${c.error_message||'Failed'}</div>${c.attempts_remaining>0&&clipId?`<button class="btn btn-redo btn-sm" onclick="redoModal(${clipId},${c.attempts_remaining},${c.clip_index})">↻ Retry (${c.attempts_remaining} left)</button>`:''}</div>`;
            else if(canReview&&clipId)acts=`<div class="clip-actions"><button class="btn btn-approve" onclick="approve(${clipId})">✓</button><button class="btn btn-reject" onclick="confirmDelete(${clipId},${c.clip_index})">🗑</button><button class="btn btn-redo" onclick="redoModal(${clipId},${c.attempts_remaining},${c.clip_index})" ${c.attempts_remaining<=0?'disabled':''}>↻${c.attempts_remaining}</button></div>`;
            // Frame info display
            let frameInfo='';
            if(c.start_frame){
                const startName=c.start_frame.length>15?c.start_frame.substring(0,12)+'...':c.start_frame;
                const endName=c.end_frame?(c.end_frame.length>15?c.end_frame.substring(0,12)+'...':c.end_frame):'';
                frameInfo=`<div class="clip-frames" title="Start: ${c.start_frame}${c.end_frame?' → End: '+c.end_frame:''}"><span class="frame-icon">🖼</span><span class="frame-names">${startName}${endName?' → '+endName:''}</span></div>`;
            }
            // DUAL VIEW: render both collapsed and expanded views, CSS toggles visibility
            let expandedVid = '';
            let expandedActs = '';
            if(hasMultipleVariants && c.output_filename && !isRegenerating && !failed && !pending && !skipped) {
                // Group versions by attempt for clear organization
                const attemptGroups = {};
                versions.forEach((v, vi) => {
                    const attempt = v.attempt || 1;
                    if (!attemptGroups[attempt]) attemptGroups[attempt] = [];
                    attemptGroups[attempt].push({...v, globalIdx: vi});
                });
                const attemptKeys = Object.keys(attemptGroups).sort((a,b) => a-b);
                const needsGroupHeaders = attemptKeys.length > 1;
                
                let gridHtml = '';
                attemptKeys.forEach(attemptNum => {
                    const group = attemptGroups[attemptNum];
                    if (needsGroupHeaders) {
                        const label = parseInt(attemptNum) === 1 ? 'Original' : `Redo #${parseInt(attemptNum) - 1}`;
                        gridHtml += `<div class="variant-group-header">${label} <span class="variant-group-count">${group.length} variant${group.length>1?'s':''}</span></div>`;
                    }
                    gridHtml += `<div class="variants-grid">${group.map(v => {
                        const vNum = v.globalIdx + 1;
                        const isSelected = vNum === selectedVariant;
                        const vLabel = v.version_key || (v.attempt + '.' + (v.variant || 1));
                        const vFile = v.filename;
                        if(!vFile) return '';
                        return `<div class="variant-card ${isSelected ? 'variant-selected' : ''}" onclick="selectAndApprove(${c.id}, ${vNum})">
                            <video preload="auto" playsinline loop onmouseenter="document.querySelectorAll('.clip-video-expanded video').forEach(v=>{if(v!==this){v.pause();v.currentTime=0}});this.play().catch(()=>{})" onmouseleave="this.pause();this.currentTime=0"><source src="${API}/jobs/${jid}/outputs/${vFile}" type="video/mp4"></video>
                            <span class="variant-label">v${vLabel}</span>
                            <button class="variant-select-btn" onclick="event.stopPropagation();selectAndApprove(${c.id}, ${vNum})">${isSelected && approved ? '\u2605 Selected' : '\u2606 Select'}</button>
                        </div>`;
                    }).join('')}</div>`;
                });
                expandedVid = gridHtml;
                
                if(approved) expandedActs = `<div style="display:flex;align-items:center;justify-content:center;gap:8px"><span style="color:var(--success);font-size:13px">\u2713 Approved (v${versionLabel})</span><button class="btn btn-secondary btn-sm" style="padding:4px 8px;font-size:11px" onclick="downloadClip('${API}/jobs/${selectedJobId}/outputs/${c.output_filename}','clip_${c.clip_index+1}.mp4')" title="Download clip">\ud83d\udce5</button></div>`;
                else if(canReview) expandedActs = `<div style="display:flex;align-items:center;justify-content:center;gap:6px"><span style="color:var(--text-muted);font-size:11px">Click a variant to select & approve</span><button class="btn btn-reject btn-sm" style="padding:4px 10px;font-size:11px" onclick="confirmDelete(${clipId},${c.clip_index})" title="Delete clip">\ud83d\uddd1</button><button class="btn btn-redo btn-sm" style="padding:4px 10px;font-size:11px" onclick="redoModal(${clipId},${c.attempts_remaining},${c.clip_index})" ${c.attempts_remaining<=0?'disabled':''}>\u21bb Redo (${c.attempts_remaining})</button></div>`;
                else expandedActs = acts;
            } else if(c.output_filename && !isRegenerating && !failed && !pending && !skipped) {
                // Single variant — show it as a card in expanded mode too
                expandedVid = `<div class="variants-grid"><div class="variant-card variant-selected">
                    <video preload="auto" playsinline loop onmouseenter="this.play().catch(()=>{})" onmouseleave="this.pause();this.currentTime=0"><source src="${API}/jobs/${jid}/outputs/${c.output_filename}" type="video/mp4"></video>
                    <span class="variant-label">v${versionLabel}</span>
                </div></div>`;
                if(approved) expandedActs = `<div style="display:flex;align-items:center;justify-content:center;gap:8px"><span style="color:var(--success);font-size:13px">\u2713 Approved</span><button class="btn btn-secondary btn-sm" style="padding:4px 8px;font-size:11px" onclick="downloadClip('${API}/jobs/${selectedJobId}/outputs/${c.output_filename}','clip_${c.clip_index+1}.mp4')">\ud83d\udce5</button></div>`;
                else expandedActs = acts;
            } else {
                // No video yet — show status placeholder in expanded mode
                let statusIcon = '⏳', statusText = 'Waiting...', statusColor = 'var(--text-muted)';
                if(generating) { statusIcon = '🎬'; statusText = 'Generating...'; statusColor = 'var(--accent)'; }
                else if(redoQueued) { statusIcon = '🔄'; statusText = 'Redo queued...'; statusColor = '#f59e0b'; }
                else if(failed) { statusIcon = '❌'; statusText = 'Failed'; statusColor = 'var(--error)'; }
                else if(skipped) { statusIcon = '⚠️'; statusText = 'Skipped'; statusColor = '#f59e0b'; }
                else if(waitingApproval) { statusIcon = '⏸️'; statusText = 'Awaiting approval'; statusColor = 'var(--text-muted)'; }
                expandedVid = `<div class="expanded-status-placeholder" style="display:flex;align-items:center;justify-content:center;aspect-ratio:9/16;max-height:300px;background:rgba(0,0,0,0.3);border-radius:var(--radius-sm);margin:8px;">
                    <div style="text-align:center"><div style="font-size:32px;margin-bottom:8px">${statusIcon}</div><div style="font-size:13px;font-weight:600;color:${statusColor}">${statusText}</div></div>
                </div>`;
                expandedActs = acts;
            }
            
            return `<div class="clip-card ${rejected&&!redoQueued?'clip-rejected':''} ${approved?'clip-approved':''} ${generating?'clip-generating':''} ${redoQueued?'clip-redo_queued':''} ${pending||waitingApproval?'clip-pending':''} ${skipped?'clip-skipped':''}"><div class="clip-video-collapsed"><div class="clip-video">${vid}${variantNav}</div></div><div class="clip-video-expanded">${expandedVid}</div><div class="clip-content"><div class="clip-header"><span class="clip-idx">#${c.clip_index+1}</span><span class="badge badge-${badgeClass}">${status.replace('_',' ')}</span></div>${frameInfo}<div class="clip-text">${c.dialogue_text}</div><div class="clip-actions-collapsed">${acts}</div><div class="clip-actions-expanded">${expandedActs}</div></div></div>`;

        }
        
        async function loadLogs(id){if(id !== selectedJobId)return;try{const isInitial=lastLogId===0,url=isInitial?`${API}/jobs/${id}/logs?limit=100`:`${API}/jobs/${id}/logs?since_id=${lastLogId}&limit=30`;const r=await fetch(url);if(id !== selectedJobId)return;if(!r.ok)return;const logs=await r.json();if(!logs.length)return;lastLogId=logs[logs.length-1].id;const c=document.getElementById('logs');const logsHtml=logs.map(l=>`<div class="log"><span class="log-time">${new Date(l.created_at).toLocaleTimeString()}</span><span class="log-msg">${l.message}</span></div>`).join('');if(isInitial)c.innerHTML=logsHtml;else c.innerHTML+=logsHtml;c.scrollTop=c.scrollHeight;}catch(e){}}
        
        function approve(cid){
            const btn=event.target;
            const card=btn.closest('.clip-card');
            const clipIdx = Array.from(document.querySelectorAll('.clip-card')).indexOf(card);
            
            // Optimistic UI update - no reload needed
            card.classList.remove('clip-rejected');
            card.classList.add('clip-approved');
            card.querySelector('.badge').className='badge badge-approved';
            card.querySelector('.badge').textContent='approved';
            const actionsEl = btn.closest('.clip-actions');
            if (actionsEl) actionsEl.innerHTML='<div style="color:var(--success);text-align:center;font-size:14px">✓ Approved</div>';
            
            // Update clipStates to prevent polling from reverting the optimistic UI
            // Use cachedClipsData for accurate state key (has correct total_variants etc)
            if(clipIdx >= 0) {
                const clipData = cachedClipsData?.find(c => c.clip_index === clipIdx);
                if(clipData) {
                    clipData.approval_status = 'approved';
                    clipStates[clipIdx] = getClipStateKey(clipData);
                } else if(clipStates[clipIdx]) {
                    const parts = clipStates[clipIdx].split('|');
                    clipStates[clipIdx] = `completed|approved|${parts[2]||''}|${parts[3]||'1'}|${parts[4]||'1'}|${parts[5]||'0'}`;
                }
            }
            
            // Make the API call in background - no need to wait
            fetch(`${API}/clips/${cid}/approve`,{method:'POST'})
                .then(r => {
                    if(!r.ok) throw new Error('Approve failed');
                    return r.json();
                })
                .then(() => {
                    // Update banner without touching clips
                    if(selectedJobId) updateReviewBannerOnly(selectedJobId);
                })
                .catch(e => {
                    console.error('Approve error:', e);
                    loadClips(selectedJobId);
                });
        }
        
        // Lightweight banner update - doesn't touch clips
        async function updateReviewBannerOnly(jobId) {
            try {
                const rs = await fetch(`${API}/jobs/${jobId}/review-status`).then(r=>r.json());
                const container = document.querySelector('.clips-container') || document.getElementById('clipsList');
                if(!container) return;
                
                const newKey = `${rs.all_approved}|${rs.approved}|${rs.pending_review}`;
                
                // Check if we already have a banner with this exact state
                const existingBanner = container.querySelector(`.review-banner[data-review-key="${newKey}"]`);
                if(existingBanner) return; // Already showing correct state
                
                // Remove ALL review banners (there might be duplicates)
                container.querySelectorAll('.review-banner').forEach(b => b.remove());
                
                let bannerHtml = '';
                
                if(rs.all_approved) {
                    bannerHtml = `<div class="review-banner" data-review-key="${newKey}" style="background:var(--success)"><h3>✅ All Approved</h3><div style="display:flex;gap:8px"><button class="btn btn-secondary btn-sm" onclick="downloadAll('${jobId}')" title="Download all approved clips">📥 Download</button><button class="btn btn-primary btn-sm" onclick="exportFinalVideo('${jobId}')" title="Combine clips into final video">🎬 Export Final</button></div></div>`;
                } else if(rs.pending_review > 0) {
                    bannerHtml = `<div class="review-banner" data-review-key="${newKey}"><h3>📋 Review</h3><div class="review-stats"><div class="review-stat"><div class="review-stat-val">${rs.approved}</div><div class="review-stat-lbl">OK</div></div><div class="review-stat"><div class="review-stat-val">${rs.pending_review}</div><div class="review-stat-lbl">Pending</div></div></div></div>`;
                }
                
                if(bannerHtml) {
                    // Insert after export-progress if it exists, otherwise at the beginning
                    const exportBanner = container.querySelector('.export-progress');
                    if(exportBanner) {
                        exportBanner.insertAdjacentHTML('afterend', bannerHtml);
                    } else {
                        container.insertAdjacentHTML('afterbegin', bannerHtml);
                    }
                }
            } catch(e) {
                console.error('Failed to update review banner:', e);
            }
        }
        
        // Keep the old function for backwards compatibility
        async function updateReviewBanner(jobId) {
            return updateReviewBannerOnly(jobId);
        }
        function confirmDelete(cid,clipIdx){if(confirm(`Delete Clip #${clipIdx+1}?`))deleteClip(cid,clipIdx);}
        function deleteClip(cid,clipIdx){const card=document.querySelectorAll('.clip-card')[clipIdx];if(card){card.style.opacity='0.5';card.style.pointerEvents='none';}fetch(`${API}/clips/${cid}`,{method:'DELETE'}).then(r=>{if(!r.ok)throw new Error();return r.json();}).then(()=>{if(card)card.remove();clipStates={};loadClips(selectedJobId);}).catch(e=>{if(card){card.style.opacity='1';card.style.pointerEvents='auto';}alert('Failed');});}
        async function switchVariant(clipId, variantNum) {
            if (variantNum < 1) return;
            
            if (!window._variantBlobCache) window._variantBlobCache = {};
            const cacheKey = `variant_${clipId}_${variantNum}`;
            const cards = document.querySelectorAll('.clip-card');
            
            // Find clip card and video element
            // We need clipIndex — find it from the card's data or iterate
            let card = null, clipIdx = -1;
            cards.forEach((c, i) => {
                const nav = c.querySelector('.variant-nav');
                if (nav && nav.innerHTML.includes(`switchVariant(${clipId},`)) { card = c; clipIdx = i; }
            });
            if (!card) card = cards[clipIdx] || null;
            
            const video = card ? card.querySelector('.clip-video-collapsed video') || card.querySelector('video') : null;
            
            // === INSTANT: swap video from blob cache before any API call ===
            if (video && window._variantBlobCache[cacheKey]) {
                const source = video.querySelector('source');
                if (source) source.src = window._variantBlobCache[cacheKey];
                else video.src = window._variantBlobCache[cacheKey];
                video.load();
            }
            
            // === INSTANT: update nav buttons optimistically ===
            if (card) {
                const btns = card.querySelectorAll('.variant-btn');
                if (btns.length >= 2) {
                    btns[0].disabled = variantNum <= 1;
                    btns[0].setAttribute('onclick', `switchVariant(${clipId},${variantNum-1})`);
                    btns[1].setAttribute('onclick', `switchVariant(${clipId},${variantNum+1})`);
                    // Don't disable next yet — we don't know totalVariants until API returns
                }
                const indicator = card.querySelector('.variant-indicator');
                if (indicator) {
                    // Update the number part immediately, keep the label format
                    const text = indicator.textContent;
                    const match = text.match(/\((\d+)\/(\d+)\)/);
                    if (match) {
                        indicator.textContent = text.replace(/\(\d+\/\d+\)/, `(${variantNum}/${match[2]})`);
                    }
                }
            }
            
            // === BACKGROUND: persist to server + get full clip data ===
            try {
                const r = await fetch(`${API}/clips/${clipId}/select-variant/${variantNum}`, {method: 'POST'});
                if (!r.ok) {
                    const err = await r.json().catch(() => ({}));
                    throw new Error(err.detail || 'Unknown error');
                }
                const result = await r.json();
                
                const clipData = result.clip;
                if (clipData && selectedJobId && card) {
                    const newFilename = clipData.output_filename;
                    
                    // If we didn't have a cached blob, now swap the video from the server URL
                    if (video && newFilename && !window._variantBlobCache[cacheKey]) {
                        const newUrl = `${API}/jobs/${selectedJobId}/outputs/${newFilename}`;
                        const source = video.querySelector('source');
                        if (source) source.src = newUrl;
                        else video.src = newUrl;
                        video.load();
                        // Cache for next time
                        fetch(newUrl).then(r => r.blob()).then(blob => {
                            if (blob) window._variantBlobCache[cacheKey] = URL.createObjectURL(blob);
                        }).catch(() => {});
                    }
                    
                    // Update nav with accurate server data
                    const versions = clipData.versions || [];
                    const totalVariants = clipData.total_variants || versions.length || 1;
                    const currentVersion = variantNum > 0 && variantNum <= versions.length ? versions[variantNum - 1] : null;
                    const versionLabel = currentVersion && currentVersion.version_key ? currentVersion.version_key : (currentVersion ? `${currentVersion.attempt||1}.${currentVersion.variant||1}` : `${clipData.generation_attempt||1}.1`);
                    
                    const indicator = card.querySelector('.variant-indicator');
                    if (indicator) indicator.textContent = `${versionLabel} (${variantNum}/${totalVariants})`;
                    
                    // Now we know totalVariants — update next button
                    const btns = card.querySelectorAll('.variant-btn');
                    if (btns.length >= 2) {
                        btns[0].disabled = variantNum <= 1;
                        btns[0].setAttribute('onclick', `switchVariant(${clipId},${variantNum-1})`);
                        btns[1].disabled = variantNum >= totalVariants;
                        btns[1].setAttribute('onclick', `switchVariant(${clipId},${variantNum+1})`);
                    }
                    
                    // Update download button
                    const dlBtn = card.querySelector('.video-download-btn');
                    if (dlBtn && newFilename) dlBtn.setAttribute('onclick', `event.stopPropagation();downloadClip('${API}/jobs/${selectedJobId}/outputs/${newFilename}','clip_${clipData.clip_index+1}.mp4')`);
                    
                    // Update voice button
                    const voiceBtn = card.querySelector('.video-voice-btn');
                    if (voiceBtn && newFilename) voiceBtn.setAttribute('data-clip', newFilename);
                    
                    // Update state to prevent polling from reverting
                    clipStates[clipData.clip_index] = getClipStateKey(clipData);
                }
            } catch(e) {
                console.error('Failed to switch variant:', e);
                alert('Failed to switch variant: ' + e.message);
            }
        }
        
        // Preload all variant videos for a clip as blob URLs for instant switching
        function preloadClipVariants(clip, jobId) {
            if (!clip.versions || clip.versions.length <= 1) return;
            if (!window._variantBlobCache) window._variantBlobCache = {};
            
            clip.versions.forEach((v, idx) => {
                const variantNum = idx + 1;
                const cacheKey = `variant_${clip.id}_${variantNum}`;
                if (window._variantBlobCache[cacheKey]) return; // Already cached
                
                const filename = v.filename;
                if (!filename) return;
                
                const url = `${API}/jobs/${jobId}/outputs/${filename}`;
                fetch(url).then(r => {
                    if (!r.ok) return;
                    return r.blob();
                }).then(blob => {
                    if (blob) window._variantBlobCache[cacheKey] = URL.createObjectURL(blob);
                }).catch(() => {});
            });
        }
        
        let variantsExpanded = false;
        let cachedClipsData = null;
        let cachedJobId = null;
        function toggleVariantsExpanded() {
            variantsExpanded = !variantsExpanded;
            // Instant toggle: just flip CSS class, no DOM rebuild
            const grid = document.querySelector('.clips-grid');
            if(grid) grid.classList.toggle('expanded-mode', variantsExpanded);
            const btn = document.getElementById('expandToggleBtn');
            if(btn) btn.innerHTML = variantsExpanded ? '⊟ Collapse' : '⊞ Expand';
        }
        
        async function selectAndApprove(clipId, variantNum) {
            try {
                // Optimistic UI: update the card visually BEFORE API calls
                const allCards = document.querySelectorAll('.clip-card');
                let targetCard = null;
                // Find the variant cards in the expanded view and update them
                allCards.forEach(card => {
                    const variantCards = card.querySelectorAll('.variant-card');
                    variantCards.forEach((vc, vi) => {
                        // Check if this variant card triggered the click
                        const btn = vc.querySelector('.variant-select-btn');
                        if(vi + 1 === variantNum) {
                            // Check if this is the right clip by seeing if any onclick matches
                            const onclick = vc.getAttribute('onclick') || '';
                            if(onclick.includes(clipId)) {
                                targetCard = card;
                                // Mark this variant as selected
                                variantCards.forEach(v => v.classList.remove('variant-selected'));
                                vc.classList.add('variant-selected');
                                if(btn) btn.innerHTML = '★ Selected';
                                // Update other buttons
                                variantCards.forEach((v2, vi2) => {
                                    if(vi2 !== vi) {
                                        const b2 = v2.querySelector('.variant-select-btn');
                                        if(b2) b2.innerHTML = '☆ Select';
                                    }
                                });
                            }
                        }
                    });
                });
                // Update badge and actions
                if(targetCard) {
                    targetCard.classList.add('clip-approved');
                    targetCard.classList.remove('clip-rejected');
                    const badge = targetCard.querySelector('.badge');
                    if(badge) { badge.className = 'badge badge-approved'; badge.textContent = 'approved'; }
                    const expandedActs = targetCard.querySelector('.clip-actions-expanded');
                    if(expandedActs) expandedActs.innerHTML = `<div style="display:flex;align-items:center;justify-content:center;gap:8px"><span style="color:var(--success);font-size:13px">✓ Approved</span></div>`;
                    const collapsedActs = targetCard.querySelector('.clip-actions-collapsed');
                    if(collapsedActs) collapsedActs.innerHTML = `<div style="color:var(--success);text-align:center;font-size:14px">✓ Approved</div>`;
                }
                
                // API calls in background — no loadClips needed
                const r = await fetch(`${API}/clips/${clipId}/select-variant/${variantNum}`, {method: 'POST'});
                if (!r.ok) throw new Error('Failed to select variant');
                const r2 = await fetch(`${API}/clips/${clipId}/approve`, {method: 'POST'});
                if (!r2.ok) throw new Error('Failed to approve');
                
                // Update clipStates to prevent polling from reverting
                const clipData = cachedClipsData?.find(c => c.id === clipId);
                if(clipData) {
                    clipData.approval_status = 'approved';
                    clipData.selected_variant = variantNum;
                    clipStates[clipData.clip_index] = getClipStateKey(clipData);
                }
                // Update banner without rebuilding clips
                if(selectedJobId) updateReviewBannerOnly(selectedJobId);
            } catch(e) {
                console.error('Select & approve error:', e);
                // On failure, reload to get correct state
                if(selectedJobId) loadClips(selectedJobId);
            }
        }
        
        let redoClip=null,redoClipIndex=null,redoOriginalDialogue=null;
        async function redoModal(cid,rem,clipIdx){
            if(rem<=0)return alert('No redos left');
            redoClip=cid;
            redoClipIndex=clipIdx;
            
            // Fetch current clip dialogue
            let currentDialogue = '';
            try {
                const r = await fetch(`${API}/clips/${cid}`);
                if (r.ok) {
                    const clip = await r.json();
                    currentDialogue = clip.dialogue_text || '';
                    redoOriginalDialogue = currentDialogue;
                }
            } catch(e) { console.warn('Could not fetch clip dialogue:', e); }
            
            const m=document.createElement('div');
            m.className='modal';
            m.id='modal';
            m.innerHTML=`
                <div class="modal-box" style="max-width:500px;">
                    <h3>🔄 Redo Clip #${clipIdx + 1}</h3>
                    <p style="font-size:11px;color:var(--text-secondary);margin-bottom:12px">Edit dialogue and/or provide feedback for regeneration</p>
                    
                    <label style="display:block;margin-bottom:4px;font-weight:500;">Dialogue</label>
                    <textarea id="redoDialogue" placeholder="Enter the dialogue for this clip..." style="min-height:80px;margin-bottom:12px;font-size:13px;">${currentDialogue}</textarea>
                    
                    <label style="display:block;margin-bottom:4px;font-weight:500;">Feedback <span style="font-weight:normal;color:var(--text-muted)">(optional)</span></label>
                    <textarea id="redoReason" placeholder="e.g., More natural expression, different camera angle..." style="min-height:50px;font-size:13px;"></textarea>
                    
                    <div class="modal-actions" style="margin-top:16px;">
                        <button class="btn btn-secondary btn-sm" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-redo btn-sm" onclick="submitRedo()">↻ Regenerate (${rem-1} left)</button>
                    </div>
                </div>
            `;
            document.body.appendChild(m);
        }
        function closeModal(){document.getElementById('modal')?.remove();redoClip=null;redoClipIndex=null;redoOriginalDialogue=null;}
        function submitRedo(){
            if(!redoClip)return;
            const clipId=redoClip,clipIdx=redoClipIndex;
            const reason=document.getElementById('redoReason')?.value||'';
            const newDialogue=document.getElementById('redoDialogue')?.value||'';
            
            // Check if dialogue changed
            const dialogueChanged = newDialogue !== redoOriginalDialogue;
            
            if(clipIdx!==null)markClipRegenerating(clipIdx);
            closeModal();
            
            // Track redo request time for grace period polling
            lastRedoRequestTime = Date.now();
            console.log('[Redo] Request time set, grace period active for 90s');
            
            const body = {reason};
            if(dialogueChanged && newDialogue.trim()) {
                body.new_dialogue = newDialogue.trim();
            }
            
            fetch(`${API}/clips/${clipId}/redo`,{
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body:JSON.stringify(body)
            }).then(r=>{
                if(!r.ok) return r.json().then(err => { throw new Error(err.detail || 'Redo failed'); });
                return r.json();
            }).then(()=>{
                console.log('[Redo] Queued, will refresh when complete');
                // Re-select job to restart polling (since it stops when job is completed)
                if(selectedJobId) {
                    const jobId = selectedJobId;
                    selectedJobId = null; // Force re-select
                    selectJob(jobId);
                }
            }).catch(e=>{
                console.error('[Redo] Error:', e);
                alert('Redo failed: ' + e.message);
                loadClips(selectedJobId);
            });
        }
        function markClipRegenerating(clipIdx){const container=document.querySelector('.clips-grid');if(container){const cards=container.querySelectorAll('.clip-card');if(cards[clipIdx]){cards[clipIdx].classList.remove('clip-rejected','clip-failed');cards[clipIdx].classList.add('clip-redo_queued');const badge=cards[clipIdx].querySelector('.badge');if(badge){badge.className='badge badge-redo_queued';badge.textContent='redo queued';}const video=cards[clipIdx].querySelector('.clip-video');if(video)video.innerHTML='<div class="generating-state"><div class="generating-spinner">🔄</div><div class="generating-text">Redo queued...</div></div>';}}}
        
        function cancelJob(id){if(!confirm('Cancel?'))return;fetch(`${API}/jobs/${id}/cancel`,{method:'POST'}).then(()=>{loadJob(id);refreshJobsList();});}
        
        async function resumeJob(id){
            try {
                const res = await fetch(`${API}/jobs/${id}/resume`, {method:'POST'});
                if(res.ok) {
                    loadJob(id);
                    refreshJobsList();
                    selectJob(id); // Re-select to start polling
                } else {
                    const err = await res.json();
                    alert(err.detail || 'Failed to resume job');
                }
            } catch(e) {
                alert('Failed to resume job');
            }
        }
        function deleteJob(id){if(!confirm('Delete?'))return;document.getElementById('jobDetails').style.display='none';document.getElementById('noJob').style.display='block';selectedJobId=null;fetch(`${API}/jobs/${id}`,{method:'DELETE'}).then(()=>refreshJobsList());}
        async function downloadAll(id){
            try {
                const r = await fetch(`${API}/jobs/${id}/outputs?approved_only=true`);
                if(!r.ok) throw new Error('Failed to get outputs list');
                
                const d = await r.json();
                if(d.videos.length === 0) {
                    alert('No approved clips to download');
                    return;
                }
                
                // Show progress
                const status = document.getElementById('splitStatus');
                if(status) {
                    status.style.display = 'block';
                    status.textContent = `Downloading ${d.videos.length} clips...`;
                    status.style.color = 'var(--accent)';
                }
                
                // Download each video with delay
                for(let i = 0; i < d.videos.length; i++) {
                    const v = d.videos[i];
                    await new Promise(resolve => setTimeout(resolve, i * 600));
                    await downloadClip(v.url, v.filename);
                }
                
                if(status) {
                    status.textContent = `✓ Downloaded ${d.videos.length} clips`;
                    status.style.color = 'var(--success)';
                    setTimeout(() => { status.style.display = 'none'; }, 3000);
                }
            } catch(e) {
                console.error('Download error:', e);
                alert('Download failed: ' + e.message);
            }
        }
        
        // Download a single clip by URL - using direct link for speed on Render free tier
        function downloadClip(url, filename) {
            // Direct download (no second fetch request - fastest approach)
            // This starts the download immediately
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'clip.mp4';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Return resolved promise for compatibility with downloadAll's await
            return Promise.resolve();
        }
        
        // Download missing clips Excel file
        function downloadMissingClips(jobId) {
            const url = `${API}/jobs/${jobId}/missing-clips`;
            const a = document.createElement('a');
            a.href = url;
            a.download = 'missing_clips.xlsx';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // ============ Export Final Video ============
        let isExporting = false; // Prevent multiple concurrent exports
        
        async function exportFinalVideo(jobId) {
            if (isExporting) {
                alert('Export already in progress');
                return;
            }
            
            // Fire and forget: warm up voice clone server while user configures export
            fetch(`${API}/voice-clone-warmup`, { method: 'POST' }).catch(() => {});
            
            // Get current export settings
            const currentSettings = getExportSettings();
            
            // Build toggle position based on smart_trim setting
            const togglePosition = currentSettings.smart_trim ? 'right:2px' : 'left:2px';
            const toggleBg = currentSettings.smart_trim ? 'var(--accent)' : 'var(--bg-elevated)';
            const toggleClass = currentSettings.smart_trim ? 'active' : '';
            
            // Show settings confirmation modal
            const modalHtml = `
                <div id="exportSettingsModal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:#0F172A;display:flex;align-items:center;justify-content:center;z-index:10000;">
                    <div style="background:var(--bg-card);border-radius:var(--radius-lg);padding:24px;max-width:400px;width:90%;box-shadow:0 20px 40px rgba(0,0,0,0.6);">
                        <h3 style="margin:0 0 16px;font-size:16px;display:flex;align-items:center;gap:8px;">
                            ✂️ Export Settings
                        </h3>
                        
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px;">
                            <div>
                                <label style="font-size:10px;color:var(--text-muted);margin-bottom:4px;display:block;">Trim Start Frames</label>
                                <input type="number" id="modalFramesStart" value="${currentSettings.frames_to_cut_start}" min="0" max="30" 
                                    style="width:100%;padding:10px;background:var(--bg-input);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);font-size:14px;">
                            </div>
                            <div>
                                <label style="font-size:10px;color:var(--text-muted);margin-bottom:4px;display:block;">Trim End Frames</label>
                                <input type="number" id="modalFramesEnd" value="${currentSettings.frames_to_cut_end}" min="0" max="30"
                                    style="width:100%;padding:10px;background:var(--bg-input);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);font-size:14px;">
                            </div>
                        </div>
                        
                        <div style="padding:12px;background:var(--bg-input);border-radius:var(--radius-sm);margin-bottom:16px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;">
                                <span style="font-size:12px;">
                                    Smart Trim <span style="color:var(--success);font-size:10px;">✓ Recommended</span>
                                    <span style="font-size:10px;color:var(--text-muted);display:block;">Skip first clip & scene cuts</span>
                                </span>
                                <div class="toggle ${toggleClass}" id="modalSmartTrim"></div>
                            </div>
                        </div>
                        
                        <div style="padding:12px;background:var(--bg-input);border-radius:var(--radius-sm);margin-bottom:16px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                                <span style="font-size:12px;font-weight:600;">
                                    🔊 Audio Enhancement
                                </span>
                            </div>
                            
                            <!-- Toggle 1: Laughter Removal -->
                            <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid var(--border-color);">
                                <span style="font-size:11px;">
                                    😂 Remove Laughter
                                    <span style="font-size:9px;color:var(--text-muted);display:block;">noisereduce (treats laughter as noise)</span>
                                </span>
                                <div class="toggle active" id="modalRemoveLaughter"></div>
                            </div>
                            
                            <!-- Strength Slider (only for laughter removal) -->
                            <div id="laughterStrengthSection" style="padding:8px 0;border-bottom:1px solid var(--border-color);">
                                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                                    <span style="font-size:10px;color:var(--text-secondary);margin-left:20px;">Strength</span>
                                    <span id="denoiseStrengthValue" style="font-size:10px;color:var(--text-muted);">75%</span>
                                </div>
                                <input type="range" id="modalDenoiseStrength" min="50" max="100" value="75" 
                                    style="width:calc(100% - 20px);margin-left:20px;height:4px;border-radius:2px;background:var(--bg-elevated);cursor:pointer;accent-color:var(--accent);"
                                    oninput="document.getElementById('denoiseStrengthValue').textContent=this.value+'%'">
                            </div>
                            
                            <!-- Toggle 2: DeepFilterNet -->
                            <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid var(--border-color);">
                                <span style="font-size:11px;">
                                    🎛️ DeepFilterNet
                                    <span style="font-size:9px;color:var(--text-muted);display:block;">AI removes hiss/static (preserves voice)</span>
                                </span>
                                <div class="toggle active" id="modalDeepFilter"></div>
                            </div>
                            
                            <!-- Toggle 3: Voice Filter -->
                            <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid var(--border-color);">
                                <span style="font-size:11px;">
                                    🎚️ Voice Filter
                                    <span style="font-size:9px;color:var(--text-muted);display:block;">Compressor, gate, limiter (can sound robotic)</span>
                                </span>
                                <div class="toggle" id="modalVoiceFilter"></div>
                            </div>
                            
                            <!-- Toggle 4: Loudnorm -->
                            <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;">
                                <span style="font-size:11px;">
                                    📊 Loudness Norm
                                    <span style="font-size:9px;color:var(--text-muted);display:block;">EBU R128 -16 LUFS (consistent volume)</span>
                                </span>
                                <div class="toggle active" id="modalLoudnorm"></div>
                            </div>
                        </div>
                        
                        <p style="font-size:11px;color:var(--text-muted);margin:0 0 16px;padding:8px;background:var(--bg-elevated);border-radius:var(--radius-sm);">
                            💡 Trimming removes frames from clip ends for smoother playback. Default: 7 frames from end (~0.3s at 24fps).
                        </p>
                        
                        <div style="display:flex;gap:8px;justify-content:flex-end;">
                            <button onclick="document.getElementById('exportSettingsModal').remove()" 
                                style="padding:10px 20px;background:var(--bg-elevated);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);cursor:pointer;">
                                Cancel
                            </button>
                            <button id="confirmExportBtn" 
                                style="padding:10px 20px;background:var(--accent);border:none;border-radius:var(--radius-sm);color:white;cursor:pointer;font-weight:600;">
                                🎬 Export
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // Setup toggle click handlers
            document.getElementById('modalSmartTrim').onclick = function() { this.classList.toggle('active'); };
            document.getElementById('modalRemoveLaughter').onclick = function() { 
                this.classList.toggle('active');
                // Show/hide strength slider
                const strengthSection = document.getElementById('laughterStrengthSection');
                if (strengthSection) strengthSection.style.display = this.classList.contains('active') ? 'block' : 'none';
            };
            document.getElementById('modalDeepFilter').onclick = function() { this.classList.toggle('active'); };
            document.getElementById('modalVoiceFilter').onclick = function() { this.classList.toggle('active'); };
            document.getElementById('modalLoudnorm').onclick = function() { this.classList.toggle('active'); };
            
            // Wait for user confirmation
            return new Promise((resolve) => {
                document.getElementById('confirmExportBtn').onclick = async () => {
                    // Get settings from modal
                    const startVal = parseInt(document.getElementById('modalFramesStart').value);
                    const endVal = parseInt(document.getElementById('modalFramesEnd').value);
                    const strengthVal = parseInt(document.getElementById('modalDenoiseStrength')?.value || 75);
                    
                    const modalSettings = {
                        frames_to_cut_start: isNaN(startVal) ? 0 : startVal,
                        frames_to_cut_end: isNaN(endVal) ? 7 : endVal,
                        smart_trim: document.getElementById('modalSmartTrim').classList.contains('active'),
                        // Individual audio enhancement toggles
                        remove_laughter: document.getElementById('modalRemoveLaughter').classList.contains('active'),
                        denoise_strength: strengthVal / 100,
                        apply_deepfilter: document.getElementById('modalDeepFilter').classList.contains('active'),
                        apply_voice_filter: document.getElementById('modalVoiceFilter').classList.contains('active'),
                        apply_loudnorm: document.getElementById('modalLoudnorm').classList.contains('active'),
                        // Legacy field for backwards compatibility
                        enhance_audio: document.getElementById('modalRemoveLaughter').classList.contains('active') ||
                                       document.getElementById('modalDeepFilter').classList.contains('active') ||
                                       document.getElementById('modalVoiceFilter').classList.contains('active') ||
                                       document.getElementById('modalLoudnorm').classList.contains('active')
                    };
                    
                    console.log('[Export] Modal settings:', modalSettings);
                    
                    // Remove modal
                    document.getElementById('exportSettingsModal').remove();
                    
                    // Proceed with export
                    await doExport(jobId, modalSettings);
                    resolve();
                };
            });
        }
        
        // Helper: Ensure exports section exists in clipsList
        function ensureExportsSection(jobId) {
            const container = document.getElementById('clipsList');
            if (!container) return;
            
            let section = container.querySelector('.exports-section');
            if (!section) {
                const sectionHtml = `
                    <div class="exports-section" data-job-id="${jobId}" style="margin-bottom:16px;">
                        <div class="exports-header" style="display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:var(--bg-elevated);border-radius:var(--radius-md) var(--radius-md) 0 0;border-bottom:1px solid var(--border-color);">
                            <h4 style="margin:0;font-size:13px;color:var(--text-primary);display:flex;align-items:center;gap:6px;">
                                📦 Exports
                            </h4>
                            <button onclick="openVoiceSwap('${jobId}')" style="padding:6px 12px;background:linear-gradient(90deg, #9333ea 0%, #6366f1 100%);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;font-weight:500;" title="Clone voice - select any export below">
                                🎤 Voice Clone
                            </button>
                        </div>
                        <div class="voice-instructions" style="padding:8px 12px;background:rgba(147, 51, 234, 0.1);border-bottom:1px solid var(--border-color);font-size:11px;color:var(--text-secondary);">
                            <span style="color:#a855f7;font-weight:500;">Voice Clone:</span> Select 2-3 clips above using 🎤 button, or upload your own voice sample
                        </div>
                        <div class="exports-content" style="background:var(--bg-card);border-radius:0 0 var(--radius-md) var(--radius-md);padding:8px;"></div>
                    </div>
                `;
                // Insert after review banner if exists, otherwise at beginning
                const reviewBanner = container.querySelector('.review-banner');
                if (reviewBanner) {
                    reviewBanner.insertAdjacentHTML('afterend', sectionHtml);
                } else {
                    container.insertAdjacentHTML('afterbegin', sectionHtml);
                }
            }
            return container.querySelector('.exports-section');
        }
        
        // Load existing exports when switching jobs
        async function loadExistingExports(jobId) {
            try {
                const response = await fetch(`${API}/jobs/${jobId}/list-outputs`);
                if (!response.ok) return;
                
                const data = await response.json();
                const files = data.files || [];
                
                // Filter for export files (final_export_ and voice_cloned_)
                const exportFiles = files.filter(f => 
                    f.endsWith('.mp4') && 
                    (f.startsWith('final_export_') || f.startsWith('voice_cloned'))
                );
                
                if (exportFiles.length === 0) return;
                
                // Ensure exports section exists
                const section = ensureExportsSection(jobId);
                if (!section) return;
                
                const content = section.querySelector('.exports-content');
                if (!content) return;
                
                // Clear any existing cards (except progress cards)
                const existingCards = content.querySelectorAll('.export-complete, .voice-swap-complete');
                existingCards.forEach(card => card.remove());
                
                // Add cards for each export file
                for (const filename of exportFiles) {
                    const url = `${API}/jobs/${jobId}/outputs/${filename}`;
                    
                    // Try to load saved metadata
                    const metadata = getExportMetadata(filename);
                    
                    if (filename.startsWith('final_export_')) {
                        // Build subtitle from saved metadata or default
                        let subtitle = 'Final export';
                        if (metadata) {
                            const audioIcons = [];
                            if (metadata.remove_laughter) audioIcons.push('😂');
                            if (metadata.apply_deepfilter) audioIcons.push('🎛️');
                            if (metadata.apply_voice_filter) audioIcons.push('🎚️');
                            if (metadata.apply_loudnorm) audioIcons.push('📊');
                            const audioLabel = audioIcons.length > 0 ? ` • ${audioIcons.join('')}` : '';
                            subtitle = `${metadata.duration || '?'}s • ${metadata.clips || '?'} clips • trim ${metadata.trimStart || 0}/${metadata.trimEnd || 7}${audioLabel}`;
                        }
                        
                        const cardHtml = `
                            <div class="export-complete" data-filename="${filename}" style="background:linear-gradient(90deg, #10b981 0%, #059669 100%);padding:12px 16px;border-radius:var(--radius-md);margin-bottom:8px;">
                                <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                                    <div style="flex:1;min-width:0;">
                                        <h3 style="margin:0;font-size:13px;color:white;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">✅ ${filename}</h3>
                                        <p style="margin:4px 0 0;font-size:11px;opacity:0.9;color:white;">${subtitle}</p>
                                    </div>
                                    <div style="display:flex;gap:6px;align-items:center;margin-left:12px;">
                                        <button onclick="openVoiceSwapForFile('${jobId}', '${filename}')" style="padding:6px 10px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;" title="Clone voice">🎤 <span>Voice</span></button>
                                        <button onclick="downloadClip('${url}','${filename}')" style="padding:6px 10px;background:white;color:#059669;border:none;border-radius:var(--radius-sm);font-size:11px;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:4px;">📥 <span>Download</span></button>
                                        <button onclick="this.closest('.export-complete').remove()" style="padding:6px 8px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;" title="Remove">✕</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        content.insertAdjacentHTML('beforeend', cardHtml);
                    } else if (filename.startsWith('voice_cloned')) {
                        // Voice clone card
                        const isElevenLabs = filename.includes('_el_');
                        const provider = isElevenLabs ? 'ElevenLabs' : 'OpenVoice';
                        
                        // Build subtitle from saved metadata or default
                        let subtitle = `${provider} voice clone`;
                        if (metadata) {
                            if (isElevenLabs) {
                                subtitle = `ElevenLabs • stab=${metadata.stability || '?'} • sim=${metadata.similarity || '?'}`;
                            } else {
                                const pitchLabel = metadata.pitch ? ` • pitch=${metadata.pitch}` : '';
                                subtitle = `OpenVoice • tau=${metadata.tau || '?'} • 🎤 ${metadata.voiceRef || '?'}${pitchLabel}`;
                            }
                        }
                        
                        const cardHtml = `
                            <div class="voice-swap-complete" data-filename="${filename}" style="background:linear-gradient(90deg, #9333ea 0%, #6366f1 100%);padding:12px 16px;border-radius:var(--radius-md);margin-bottom:8px;">
                                <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                                    <div style="flex:1;min-width:0;">
                                        <h3 style="margin:0;font-size:13px;color:white;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">✅ ${filename}</h3>
                                        <p style="margin:4px 0 0;font-size:11px;opacity:0.9;color:white;">${subtitle}</p>
                                    </div>
                                    <div style="display:flex;gap:6px;align-items:center;margin-left:12px;">
                                        <button onclick="openVoiceSwapForFile('${jobId}', '${filename}')" style="padding:6px 10px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;" title="Re-clone">🎤 <span>Voice</span></button>
                                        <button onclick="downloadClip('${url}','${filename}')" style="padding:6px 10px;background:white;color:#9333ea;border:none;border-radius:var(--radius-sm);font-size:11px;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:4px;">📥 <span>Download</span></button>
                                        <button onclick="this.closest('.voice-swap-complete').remove()" style="padding:6px 8px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;" title="Remove">✕</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        content.insertAdjacentHTML('beforeend', cardHtml);
                    }
                }
                
                console.log(`[Exports] Loaded ${exportFiles.length} existing exports for job ${jobId}`);
            } catch (e) {
                console.error('[Exports] Failed to load existing exports:', e);
            }
        }
        
        // Open voice swap modal for a specific file
        async function openVoiceSwapForFile(jobId, filename) {
            // Store the preselected filename
            window.preselectedVoiceFile = filename;
            await openVoiceSwap(jobId);
        }
        
        async function doExport(jobId, exportSettings) {
            isExporting = true; // Set lock
            
            // Fire and forget: warm up voice clone server during export
            fetch(`${API}/voice-clone-warmup`, { method: 'POST' }).catch(() => {});
            
            // Create export progress banner - ADD it, don't replace the existing banner
            const container = document.getElementById('clipsList');
            
            // Ensure exports section exists
            ensureExportsSection(jobId);
            const exportsSection = container.querySelector('.exports-section');
            
            // Remove any existing export progress banner
            const oldExportBanner = exportsSection?.querySelector('.export-progress');
            if (oldExportBanner) oldExportBanner.remove();
            
            // Add progress indicator at the top of exports section
            const progressHtml = `
                <div class="export-progress" style="background:linear-gradient(90deg, var(--accent) 0%, #6366f1 100%);padding:12px 16px;border-radius:var(--radius-md);margin-bottom:12px;">
                    <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                        <div style="display:flex;align-items:center;gap:12px">
                            <div class="export-spinner"></div>
                            <div>
                                <h3 style="margin:0;font-size:14px;color:white;">🎬 Exporting Final Video...</h3>
                                <p id="exportStatusText" style="margin:4px 0 0;font-size:11px;opacity:0.9;color:white;">Preparing clips... (Trim: ${exportSettings.frames_to_cut_start}/${exportSettings.frames_to_cut_end}, Audio: ${[exportSettings.remove_laughter ? '😂' : '', exportSettings.apply_deepfilter ? '🎛️' : '', exportSettings.apply_voice_filter ? '🎚️' : '', exportSettings.apply_loudnorm ? '📊' : ''].filter(Boolean).join('') || 'OFF'})</p>
                            </div>
                        </div>
                        <div id="exportTimer" style="font-size:12px;opacity:0.8;color:white;">0:00</div>
                    </div>
                    <div style="width:100%;height:4px;background:rgba(255,255,255,0.2);border-radius:2px;margin-top:10px;overflow:hidden">
                        <div id="exportProgressBar" style="width:5%;height:100%;background:rgba(255,255,255,0.8);border-radius:2px;transition:width 0.3s"></div>
                    </div>
                </div>
                <style>
                    .export-spinner {
                        width: 24px;
                        height: 24px;
                        border: 3px solid rgba(255,255,255,0.3);
                        border-top-color: white;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                    }
                    @keyframes spin {
                        to { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            const exportsContent = exportsSection?.querySelector('.exports-content');
            if (exportsContent) {
                exportsContent.insertAdjacentHTML('afterbegin', progressHtml);
            } else {
                container.insertAdjacentHTML('afterbegin', progressHtml);
            }
            
            // Start timer
            const startTime = Date.now();
            const timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const mins = Math.floor(elapsed / 60);
                const secs = elapsed % 60;
                const timerEl = document.getElementById('exportTimer');
                if (timerEl) timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            }, 1000);
            
            // Progress stages
            const stages = [
                { progress: 10, text: "Trimming clips..." },
                { progress: 30, text: "Processing video frames..." },
                { progress: 50, text: "Concatenating clips..." },
                { progress: 70, text: "Encoding final video..." },
                { progress: 85, text: exportSettings.enhance_audio ? "Enhancing audio..." : "Finalizing..." }
            ];
            
            let stageIndex = 0;
            const stageInterval = setInterval(() => {
                if (stageIndex < stages.length) {
                    const stage = stages[stageIndex];
                    const statusEl = document.getElementById('exportStatusText');
                    const progressBar = document.getElementById('exportProgressBar');
                    if (statusEl) statusEl.textContent = stage.text;
                    if (progressBar) progressBar.style.width = stage.progress + '%';
                    stageIndex++;
                }
            }, 2000);
            
            try {
                // Use the settings passed from modal
                const settings = {
                    frames_to_cut_start: exportSettings.frames_to_cut_start,
                    frames_to_cut_end: exportSettings.frames_to_cut_end,
                    smart_trim: exportSettings.smart_trim,
                    remove_silence: false,
                    // Individual audio enhancement toggles
                    remove_laughter: exportSettings.remove_laughter ?? false,
                    denoise_strength: exportSettings.denoise_strength || 0.75,
                    apply_deepfilter: exportSettings.apply_deepfilter ?? false,
                    apply_voice_filter: exportSettings.apply_voice_filter ?? false,
                    apply_loudnorm: exportSettings.apply_loudnorm ?? false,
                    // Legacy
                    enhance_audio: exportSettings.enhance_audio ?? false
                };
                
                console.log('[Export] Sending request with settings:', settings);
                
                // Create AbortController for timeout (5 minutes max)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 300000); // 5 min timeout
                
                let response;
                try {
                    response = await fetch(`${API}/jobs/${jobId}/export-final`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(settings),
                        signal: controller.signal
                    });
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    // Check if it was an abort (timeout)
                    if (fetchError.name === 'AbortError') {
                        throw new Error('Export timed out after 5 minutes. The video might still be processing on the server. Try refreshing and downloading manually.');
                    }
                    // Network error
                    throw new Error(`Network error: ${fetchError.message}. Check if the server is running.`);
                }
                clearTimeout(timeoutId);
                
                clearInterval(timerInterval);
                clearInterval(stageInterval);
                
                if (!response.ok) {
                    let errMsg = 'Export failed';
                    try {
                        const err = await response.json();
                        errMsg = err.detail || errMsg;
                    } catch(parseErr) {
                        errMsg = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    throw new Error(errMsg);
                }
                
                const result = await response.json();
                console.log('[Export] Success:', result);
                
                // IMMEDIATELY trigger download before server might shut down
                // Don't wait - Render free tier can shut down any moment after response
                downloadClip(result.download_url, result.filename);
                
                // Build params display
                const duration = result.stats?.final_duration?.toFixed(1) || '?';
                const clips = result.stats?.clips_processed || '?';
                const trimStart = exportSettings.frames_to_cut_start ?? 0;
                const trimEnd = exportSettings.frames_to_cut_end ?? 7;
                
                // Build audio label from individual toggles
                const audioIcons = [];
                if (exportSettings.remove_laughter) audioIcons.push('😂');
                if (exportSettings.apply_deepfilter) audioIcons.push('🎛️');
                if (exportSettings.apply_voice_filter) audioIcons.push('🎚️');
                if (exportSettings.apply_loudnorm) audioIcons.push('📊');
                const audioLabel = audioIcons.length > 0 ? ` • ${audioIcons.join('')}` : '';
                
                // Save metadata for persistence after refresh
                saveExportMetadata(result.filename, {
                    duration,
                    clips,
                    trimStart,
                    trimEnd,
                    remove_laughter: exportSettings.remove_laughter,
                    apply_deepfilter: exportSettings.apply_deepfilter,
                    apply_voice_filter: exportSettings.apply_voice_filter,
                    apply_loudnorm: exportSettings.apply_loudnorm
                });
                
                // Show success UI (download already started above)
                const progressBanner = container.querySelector('.export-progress');
                if (progressBanner) {
                    progressBanner.className = 'export-complete'; // Change class so it won't be removed on next export
                    progressBanner.style.background = 'linear-gradient(90deg, #10b981 0%, #059669 100%)';
                    progressBanner.dataset.filename = result.filename;
                    progressBanner.dataset.downloadUrl = result.download_url;
                    progressBanner.dataset.type = 'export';
                    
                    progressBanner.innerHTML = `
                        <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                            <div style="flex:1;min-width:0;">
                                <h3 style="margin:0;font-size:13px;color:white;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">✅ ${result.filename}</h3>
                                <p style="margin:4px 0 0;font-size:11px;opacity:0.9;color:white;">${duration}s • ${clips} clips • trim ${trimStart}/${trimEnd}${audioLabel}</p>
                            </div>
                            <div style="display:flex;gap:6px;align-items:center;margin-left:12px;">
                                <button onclick="openVoiceSwapForFile('${jobId}', '${result.filename}')" style="padding:6px 10px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;" title="Clone voice">🎤 <span>Voice</span></button>
                                <button onclick="downloadClip('${result.download_url}','${result.filename}')" style="padding:6px 10px;background:white;color:#059669;border:none;border-radius:var(--radius-sm);font-size:11px;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:4px;">📥 <span>Download</span></button>
                                <button onclick="this.closest('.export-complete').remove()" style="padding:6px 8px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;" title="Remove">✕</button>
                            </div>
                        </div>
                    `;
                }
                
            } catch (e) {
                clearInterval(timerInterval);
                clearInterval(stageInterval);
                
                // Check if export actually succeeded despite network error
                // by trying to find the exported file
                let exportSucceeded = false;
                try {
                    const checkResponse = await fetch(`${API}/jobs/${jobId}/outputs?approved_only=false`);
                    if (checkResponse.ok) {
                        const outputs = await checkResponse.json();
                        const exportedFile = outputs.videos?.find(v => v.filename?.startsWith('final_export_'));
                        if (exportedFile) {
                            exportSucceeded = true;
                            // Show success with download link
                            const progressBanner = container.querySelector('.export-progress');
                            if (progressBanner) {
                                progressBanner.style.background = 'var(--success)';
                                progressBanner.innerHTML = `
                                    <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                                        <div>
                                            <h3 style="margin:0;font-size:14px;color:white;">✅ Export Complete!</h3>
                                            <p style="margin:4px 0 0;font-size:11px;opacity:0.9;color:white;">
                                                Network hiccup, but export succeeded. Click to download.
                                            </p>
                                        </div>
                                        <button class="btn btn-secondary btn-sm" onclick="downloadClip('${exportedFile.url}','${exportedFile.filename}')" style="background:rgba(255,255,255,0.2);border:none;color:white;">
                                            📥 Download
                                        </button>
                                    </div>
                                `;
                            }
                        }
                    }
                } catch (checkErr) {
                    console.log('[Export] Could not check for exported file:', checkErr);
                }
                
                if (!exportSucceeded) {
                    const progressBanner = container.querySelector('.export-progress');
                    if (progressBanner) {
                        progressBanner.style.background = 'var(--error)';
                        progressBanner.innerHTML = `
                            <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                                <div>
                                    <h3 style="margin:0;font-size:14px;color:white;">❌ Export Failed</h3>
                                    <p style="margin:4px 0 0;font-size:11px;opacity:0.9;color:white;">Network error: ${e.message}. Check if the server is running.</p>
                                </div>
                                <button class="btn btn-secondary btn-sm" onclick="this.parentElement.parentElement.remove();exportFinalVideo('${jobId}')" style="background:rgba(255,255,255,0.2);border:none;color:white;">
                                    Retry
                                </button>
                            </div>
                        `;
                    }
                }
            } finally {
                isExporting = false; // Always release lock
            }
        }
        
        // ============ Voice Swap (Replicate/OpenVoice) ============
        let isVoiceSwapping = false;
        
        // Helper to get/init voice clips for a job
        function getVoiceClipsForJob(jobId) {
            if (!selectedVoiceClipsPerJob[jobId]) {
                selectedVoiceClipsPerJob[jobId] = [];
            }
            return selectedVoiceClipsPerJob[jobId];
        }
        
        // Toggle clip voice selection (multi-select, 1-4 clips) - PER JOB
        function useClipVoice(jobId, clipFilename, clipIndex) {
            const clips = getVoiceClipsForJob(jobId);
            const clipRef = { jobId, filename: clipFilename, index: clipIndex };
            const existingIdx = clips.findIndex(c => c.filename === clipFilename);
            
            if (existingIdx >= 0) {
                // Deselect
                clips.splice(existingIdx, 1);
            } else {
                // Select (max 4)
                if (clips.length >= 4) {
                    showToast('⚠️ Max 4 clips. Deselect one first.', 'var(--warning)');
                    return;
                }
                clips.push(clipRef);
                preUploadedVoiceSample = null; // Clear file upload
            }
            
            // Update status display
            updateVoiceStatus(jobId);
            
            // Update clip visual states
            updateClipVoiceButtons(jobId);
        }
        
        function updateVoiceStatus(jobId) {
            const statusEl = document.getElementById('voiceSampleStatus');
            if (!statusEl) return;
            
            const clips = getVoiceClipsForJob(jobId);
            if (clips.length === 0) {
                statusEl.textContent = 'Not selected';
                statusEl.style.color = 'var(--text-muted)';
            } else {
                const clipNums = clips.map(c => `#${c.index + 1}`).join(', ');
                const quality = clips.length >= 2 ? '✓✓' : '✓';
                statusEl.textContent = `${quality} Clips ${clipNums}`;
                statusEl.style.color = 'var(--success)';
            }
        }
        
        function updateClipVoiceButtons(jobId) {
            // Add/remove selected state from voice buttons for this job
            const clips = getVoiceClipsForJob(jobId);
            document.querySelectorAll('.video-voice-btn').forEach(btn => {
                const isSelected = clips.some(c => btn.dataset.clip === c.filename);
                btn.style.background = isSelected ? 'var(--success)' : 'rgba(147, 51, 234, 0.8)';
                btn.textContent = isSelected ? '✓' : '🎤';
                if (isSelected) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }
        
        function showToast(message, bgColor = 'var(--success)') {
            const toast = document.createElement('div');
            toast.style.cssText = `position:fixed;bottom:20px;right:20px;background:${bgColor};color:white;padding:12px 20px;border-radius:8px;z-index:10000;font-size:13px;`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }
        
        async function openVoiceSwap(jobId) {
            if (isVoiceSwapping) {
                alert('Voice swap already in progress');
                return;
            }
            
            // Remove any existing modal first (prevents duplicates)
            document.getElementById('voiceSwapModal')?.remove();
            
            // Get list of exported videos first (fast, needed for UI)
            let exportedFiles = [];
            let voiceClonedFiles = [];
            try {
                const files = await fetch(`${API}/jobs/${jobId}/list-outputs`).then(r => r.json());
                exportedFiles = (files.files || []).filter(f => f.endsWith('.mp4') && f.includes('final_export'));
                voiceClonedFiles = (files.files || []).filter(f => f.endsWith('.mp4') && f.includes('voice_cloned'));
            } catch(e) {}
            
            const allFiles = [...exportedFiles, ...voiceClonedFiles];
            
            if (allFiles.length === 0) {
                alert('Please export a final video first using "Export Final" button.');
                return;
            }
            
            // Determine default selection
            const preselected = window.preselectedVoiceFile || null;
            window.preselectedVoiceFile = null; // Clear after use
            const defaultFile = preselected && allFiles.includes(preselected) ? preselected : allFiles[allFiles.length - 1];
            
            // Build file options HTML
            const fileOptionsHtml = allFiles.map(f => {
                const isVoiceCloned = f.includes('voice_cloned');
                const label = isVoiceCloned ? `${f} (voice cloned)` : f;
                const selected = f === defaultFile ? 'selected' : '';
                return `<option value="${f}" ${selected}>${label}</option>`;
            }).join('');
            
            // Check for pre-uploaded voice or selected clips
            const hasPreUpload = preUploadedVoiceSample !== null;
            const jobClips = getVoiceClipsForJob(jobId);
            const hasClipVoices = jobClips.length > 0;
            const clipCount = jobClips.length;
            const qualityLabel = clipCount >= 3 ? '⭐⭐⭐ Excellent' : clipCount === 2 ? '⭐⭐ Good' : clipCount === 1 ? '⭐ Basic' : '';
            
            const voiceSourceText = hasPreUpload 
                ? `✓ ${preUploadedVoiceSample.name}` 
                : hasClipVoices 
                    ? `✓ ${clipCount} clip${clipCount > 1 ? 's' : ''} selected (${qualityLabel})`
                    : 'No voice selected';
            const voiceSourceColor = (hasPreUpload || hasClipVoices) ? 'var(--success)' : 'var(--text-muted)';
            
            // Load saved ElevenLabs credentials
            const savedELKey = localStorage.getItem('elevenlabs_api_key') || '';
            const savedELVoiceId = localStorage.getItem('elevenlabs_voice_id') || '';
            
            // Show modal IMMEDIATELY
            const modalHtml = `
                <div id="voiceSwapModal" style="position:fixed;top:0;left:0;right:0;bottom:0;background:#0F172A;display:flex;align-items:center;justify-content:center;z-index:10000;">
                    <div style="background:var(--bg-card);border-radius:var(--radius-lg);padding:24px;max-width:480px;width:90%;box-shadow:0 20px 40px rgba(0,0,0,0.6);max-height:90vh;overflow-y:auto;">
                        <h3 style="margin:0 0 16px;font-size:16px;display:flex;align-items:center;gap:8px;">
                            🎤 Voice Clone
                        </h3>
                        
                        <!-- Provider Tabs -->
                        <div style="display:flex;gap:4px;margin-bottom:16px;background:var(--bg-input);padding:4px;border-radius:var(--radius-sm);">
                            <button id="tabOpenVoice" class="voice-tab active" onclick="switchVoiceTab('openvoice')" 
                                style="flex:1;padding:8px 12px;border:none;border-radius:var(--radius-sm);font-size:12px;cursor:pointer;background:var(--accent);color:white;font-weight:500;"
                                title="Self-hosted voice conversion (~$0.01/video)">
                                OpenVoice
                            </button>
                            <button id="tabElevenLabs" class="voice-tab" onclick="switchVoiceTab('elevenlabs')"
                                style="flex:1;padding:8px 12px;border:none;border-radius:var(--radius-sm);font-size:12px;cursor:pointer;background:transparent;color:var(--text-secondary);"
                                title="Premium voice cloning using your ElevenLabs API key">
                                ElevenLabs
                            </button>
                        </div>
                        
                        <!-- Video Selector -->
                        <div style="margin-bottom:16px;">
                            <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;">Select Video</label>
                            <select id="videoSelector" style="width:100%;padding:10px;background:var(--bg-input);border:1px solid var(--border-color);border-radius:var(--radius-sm);font-size:12px;color:var(--text-primary);cursor:pointer;">
                                ${fileOptionsHtml}
                            </select>
                        </div>
                        
                        <!-- OpenVoice Panel -->
                        <div id="panelOpenVoice">
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;">Voice Reference</label>
                                <div style="padding:10px;background:var(--bg-input);border-radius:var(--radius-sm);font-size:12px;color:${voiceSourceColor};display:flex;justify-content:space-between;align-items:center;">
                                    <span id="modalVoiceSource">${voiceSourceText}</span>
                                    <label style="cursor:pointer;color:var(--accent);font-size:11px;">
                                        Upload file
                                        <input type="file" id="voiceSampleInput" accept="audio/*,.mp3,.wav,.m4a,.ogg" style="display:none;">
                                    </label>
                                </div>
                                <p style="font-size:10px;color:var(--text-muted);margin-top:4px;">
                                    💡 Click 🎤 on 2-3 clips for best quality (max 4). More clips = better voice match.
                                </p>
                            </div>
                            
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;" title="Lower values = voice sounds more like the target. Higher = more natural but less similar.">
                                    Voice Similarity (tau): <span id="tauValue">0.3</span>
                                </label>
                                <input type="range" id="tauSlider" min="0.1" max="0.5" step="0.05" value="0.3" 
                                    style="width:100%;accent-color:var(--accent);" title="Lower = more similar to target voice, Higher = more natural">
                                <div style="display:flex;justify-content:space-between;font-size:9px;color:var(--text-muted);margin-top:2px;">
                                    <span>0.1 (More similar)</span>
                                    <span>0.5 (More natural)</span>
                                </div>
                            </div>
                            
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;" title="Reduces pitch variation from the source audio. Higher values create flatter, more monotone output.">
                                    Pitch Normalization: <span id="pitchNormValue">Off</span>
                                </label>
                                <input type="range" id="pitchNormSlider" min="0" max="0.8" step="0.1" value="0" 
                                    style="width:100%;accent-color:var(--accent);" title="Reduce pitch variation from source audio">
                                <div style="display:flex;justify-content:space-between;font-size:9px;color:var(--text-muted);margin-top:2px;">
                                    <span>0 (Off)</span>
                                    <span>0.8 (Flat tone)</span>
                                </div>
                            </div>
                            
                            <div style="margin-bottom:16px;padding:10px;background:var(--bg-elevated);border-radius:var(--radius-sm);border:1px dashed var(--border-color);">
                                <div style="font-size:11px;color:var(--text-muted);">
                                    🎯 <strong>OpenVoice v2</strong>: Self-hosted voice conversion. Preserves timing/prosody.
                                </div>
                            </div>
                        </div>
                        
                        <!-- ElevenLabs Panel (hidden by default) -->
                        <div id="panelElevenLabs" style="display:none;">
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;">ElevenLabs API Key</label>
                                <input type="password" id="elApiKey" value="${savedELKey}" placeholder="xi-xxxxxxxxxxxxxxxx"
                                    style="width:100%;padding:10px;background:var(--bg-input);border:1px solid var(--border-color);border-radius:var(--radius-sm);font-size:12px;color:var(--text-primary);box-sizing:border-box;">
                                <p style="font-size:10px;color:var(--text-muted);margin-top:4px;">
                                    Get your key at <a href="https://elevenlabs.io/app/settings/api-keys" target="_blank" style="color:var(--accent);">elevenlabs.io/app/settings/api-keys</a>
                                </p>
                            </div>
                            
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;">Voice ID</label>
                                <input type="text" id="elVoiceId" value="${savedELVoiceId}" placeholder="Voice ID or name"
                                    style="width:100%;padding:10px;background:var(--bg-input);border:1px solid var(--border-color);border-radius:var(--radius-sm);font-size:12px;color:var(--text-primary);box-sizing:border-box;">
                                <p style="font-size:10px;color:var(--text-muted);margin-top:4px;">
                                    Find voice IDs at <a href="https://elevenlabs.io/app/voice-library" target="_blank" style="color:var(--accent);">elevenlabs.io/app/voice-library</a>
                                </p>
                            </div>
                            
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;" title="Higher stability = more consistent voice, lower = more expressive/variable">
                                    Stability: <span id="elStabilityValue">0.5</span>
                                </label>
                                <input type="range" id="elStability" min="0" max="1" step="0.05" value="0.5" 
                                    style="width:100%;accent-color:var(--accent);" title="Higher = more consistent, Lower = more expressive">
                                <div style="display:flex;justify-content:space-between;font-size:9px;color:var(--text-muted);margin-top:2px;">
                                    <span>More variable</span>
                                    <span>More stable</span>
                                </div>
                            </div>
                            
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;" title="How closely to match the target voice characteristics">
                                    Similarity: <span id="elSimilarityValue">0.75</span>
                                </label>
                                <input type="range" id="elSimilarity" min="0" max="1" step="0.05" value="0.75" 
                                    style="width:100%;accent-color:var(--accent);" title="How closely to match the target voice">
                                <div style="display:flex;justify-content:space-between;font-size:9px;color:var(--text-muted);margin-top:2px;">
                                    <span>Low</span>
                                    <span>High</span>
                                </div>
                            </div>
                            
                            <div style="margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-muted);margin-bottom:4px;display:block;" title="Exaggerate the voice's unique style characteristics">
                                    Style Exaggeration: <span id="elStyleValue">0</span>
                                </label>
                                <input type="range" id="elStyle" min="0" max="1" step="0.05" value="0" 
                                    style="width:100%;accent-color:var(--accent);" title="Exaggerate voice style characteristics">
                                <div style="display:flex;justify-content:space-between;font-size:9px;color:var(--text-muted);margin-top:2px;">
                                    <span>None</span>
                                    <span>Exaggerated</span>
                                </div>
                            </div>
                            
                            <div style="display:flex;gap:16px;margin-bottom:16px;">
                                <label style="font-size:11px;color:var(--text-secondary);display:flex;align-items:center;gap:4px;cursor:pointer;" title="Remove background noise from the audio before conversion">
                                    <input type="checkbox" id="elRemoveNoise" checked style="accent-color:var(--accent);">
                                    Remove background noise
                                </label>
                                <label style="font-size:11px;color:var(--text-secondary);display:flex;align-items:center;gap:4px;cursor:pointer;" title="Boost speaker clarity in the output">
                                    <input type="checkbox" id="elSpeakerBoost" checked style="accent-color:var(--accent);">
                                    Speaker boost
                                </label>
                            </div>
                            
                            <div style="margin-bottom:16px;padding:10px;background:var(--bg-elevated);border-radius:var(--radius-sm);border:1px dashed var(--border-color);">
                                <div style="font-size:11px;color:var(--text-muted);">
                                    🎯 <strong>ElevenLabs</strong>: Premium quality voice-to-voice. Uses your ElevenLabs credits.
                                </div>
                            </div>
                        </div>
                        
                        <div style="display:flex;gap:8px;justify-content:flex-end;">
                            <button onclick="document.getElementById('voiceSwapModal').remove()" 
                                style="padding:10px 20px;background:var(--bg-elevated);border:1px solid var(--border-color);border-radius:var(--radius-sm);color:var(--text-primary);cursor:pointer;">
                                Cancel
                            </button>
                            <button id="confirmVoiceSwapBtn"
                                style="padding:10px 20px;background:linear-gradient(90deg, #9333ea 0%, #6366f1 100%);border:none;border-radius:var(--radius-sm);color:white;cursor:pointer;font-weight:600;">
                                🎤 Clone Voice
                            </button>
                        </div>
                        
                        <!-- Server status indicator -->
                        <div id="serverStatus" style="margin-top:12px;font-size:10px;color:var(--text-muted);text-align:center;">
                            <span class="export-spinner" style="width:12px;height:12px;border-width:2px;display:inline-block;vertical-align:middle;margin-right:6px;"></span>
                            Warming up voice service...
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // Warm up voice service in background
            let serverReady = false;
            fetch(`${API}/voice-clone-available`).then(r => r.json()).then(check => {
                serverReady = check.available;
                const statusEl = document.getElementById('serverStatus');
                if (statusEl) {
                    if (check.available) {
                        statusEl.innerHTML = '<span style="color:var(--success);">✓</span> Voice service ready';
                    } else {
                        statusEl.innerHTML = '<span style="color:var(--warning);">⚠</span> OpenVoice unavailable (use ElevenLabs)';
                    }
                }
            }).catch(() => {
                const statusEl = document.getElementById('serverStatus');
                if (statusEl) {
                    statusEl.innerHTML = '<span style="color:var(--warning);">⚠</span> Could not reach voice service';
                }
            });
            
            // Setup provider switching
            let currentProvider = 'openvoice';
            window.switchVoiceTab = (provider) => {
                currentProvider = provider;
                const tabOV = document.getElementById('tabOpenVoice');
                const tabEL = document.getElementById('tabElevenLabs');
                const panelOV = document.getElementById('panelOpenVoice');
                const panelEL = document.getElementById('panelElevenLabs');
                const btn = document.getElementById('confirmVoiceSwapBtn');
                
                if (provider === 'openvoice') {
                    tabOV.style.background = 'var(--accent)';
                    tabOV.style.color = 'white';
                    tabEL.style.background = 'transparent';
                    tabEL.style.color = 'var(--text-secondary)';
                    panelOV.style.display = 'block';
                    panelEL.style.display = 'none';
                    btn.textContent = '🎤 Clone Voice (OpenVoice)';
                } else {
                    tabEL.style.background = 'var(--accent)';
                    tabEL.style.color = 'white';
                    tabOV.style.background = 'transparent';
                    tabOV.style.color = 'var(--text-secondary)';
                    panelOV.style.display = 'none';
                    panelEL.style.display = 'block';
                    btn.textContent = '🎤 Clone Voice (ElevenLabs)';
                }
            };
            
            // Handle tau slider change
            document.getElementById('tauSlider').addEventListener('input', (e) => {
                document.getElementById('tauValue').textContent = e.target.value;
            });
            
            // Handle pitch normalization slider change
            document.getElementById('pitchNormSlider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('pitchNormValue').textContent = val === 0 ? 'Off' : `${(val * 100).toFixed(0)}%`;
            });
            
            // ElevenLabs slider handlers
            document.getElementById('elStability').addEventListener('input', (e) => {
                document.getElementById('elStabilityValue').textContent = e.target.value;
            });
            document.getElementById('elSimilarity').addEventListener('input', (e) => {
                document.getElementById('elSimilarityValue').textContent = e.target.value;
            });
            document.getElementById('elStyle').addEventListener('input', (e) => {
                document.getElementById('elStyleValue').textContent = e.target.value;
            });
            
            // Handle file input change in modal
            document.getElementById('voiceSampleInput').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    preUploadedVoiceSample = file;
                    selectedVoiceClipsPerJob[jobId] = []; // Clear clip selection if file uploaded
                    document.getElementById('modalVoiceSource').textContent = `✓ ${file.name}`;
                    document.getElementById('modalVoiceSource').style.color = 'var(--success)';
                    updateClipVoiceButtons(jobId);
                }
            });
            
            document.getElementById('confirmVoiceSwapBtn').onclick = async () => {
                const selectedVideo = document.getElementById('videoSelector').value;
                const jobClips = getVoiceClipsForJob(jobId);
                
                if (currentProvider === 'openvoice') {
                    // OpenVoice flow
                    let voiceFile = document.getElementById('voiceSampleInput').files[0] || preUploadedVoiceSample;
                    
                    if (!voiceFile && jobClips.length === 0) {
                        alert('Please select a voice sample file or click 🎤 on 1-4 clips to use their voices');
                        return;
                    }
                    
                    const tau = parseFloat(document.getElementById('tauSlider').value);
                    const pitchNormalize = parseFloat(document.getElementById('pitchNormSlider').value);
                    
                    document.getElementById('voiceSwapModal').remove();
                    
                    await doVoiceSwap(jobId, selectedVideo, voiceFile, jobClips, tau, pitchNormalize);
                    
                } else {
                    // ElevenLabs flow
                    const apiKey = document.getElementById('elApiKey').value.trim();
                    const voiceId = document.getElementById('elVoiceId').value.trim();
                    
                    if (!apiKey || !voiceId) {
                        alert('Please enter your ElevenLabs API Key and Voice ID');
                        return;
                    }
                    
                    // Save credentials
                    localStorage.setItem('elevenlabs_api_key', apiKey);
                    localStorage.setItem('elevenlabs_voice_id', voiceId);
                    
                    const elSettings = {
                        stability: parseFloat(document.getElementById('elStability').value),
                        similarity: parseFloat(document.getElementById('elSimilarity').value),
                        style: parseFloat(document.getElementById('elStyle').value),
                        removeNoise: document.getElementById('elRemoveNoise').checked,
                        speakerBoost: document.getElementById('elSpeakerBoost').checked
                    };
                    
                    document.getElementById('voiceSwapModal').remove();
                    
                    await doVoiceSwapElevenLabs(jobId, selectedVideo, apiKey, voiceId, elSettings);
                }
            };
        }
        
        async function doVoiceSwap(jobId, videoFilename, voiceFile, clipVoiceRefs = [], tau = 0.3, pitchNormalize = 0.0) {
            isVoiceSwapping = true;
            
            const container = document.getElementById('clipsList');
            
            // Ensure exports section exists
            ensureExportsSection(jobId);
            const exportsContent = container.querySelector('.exports-content');
            
            const timeMsg = pitchNormalize > 0 ? 'Processing pitch + voice (60-120 seconds)' : 'Voice conversion takes 30-90 seconds';
            const pitchLabel = pitchNormalize > 0 ? `, pitch=${(pitchNormalize*100).toFixed(0)}%` : '';
            
            // Add progress indicator
            const progressHtml = `
                <div class="voice-swap-progress" style="background:linear-gradient(90deg, #9333ea 0%, #6366f1 100%);padding:12px 16px;border-radius:var(--radius-md);margin-bottom:8px;">
                    <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                        <div style="display:flex;align-items:center;gap:12px">
                            <div class="voice-spinner" style="width:20px;height:20px;border:2px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin 1s linear infinite;"></div>
                            <h3 style="margin:0;font-size:14px;color:white;">🎤 Cloning Voice (OpenVoice, tau=${tau}${pitchLabel})...</h3>
                        </div>
                        <span style="font-size:11px;color:rgba(255,255,255,0.7);">${timeMsg}</span>
                    </div>
                </div>
                <style>.voice-spinner{animation:spin 1s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}</style>
            `;
            if (exportsContent) {
                exportsContent.insertAdjacentHTML('afterbegin', progressHtml);
            } else {
                container.insertAdjacentHTML('afterbegin', progressHtml);
            }
            
            try {
                const formData = new FormData();
                formData.append('video_filename', videoFilename);
                formData.append('tau', tau.toString());
                formData.append('pitch_normalize', pitchNormalize.toString());
                
                // Either upload voice file or reference multiple clips' audio
                if (voiceFile) {
                    formData.append('voice_sample', voiceFile);
                } else if (clipVoiceRefs && clipVoiceRefs.length > 0) {
                    // Send array of clip filenames as JSON
                    formData.append('reference_clips', JSON.stringify(clipVoiceRefs.map(c => c.filename)));
                }
                
                const response = await fetch(
                    `${API}/jobs/${jobId}/voice-swap`,
                    {
                        method: 'POST',
                        body: formData
                    }
                );
                
                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    throw new Error(err.detail || 'Voice swap failed');
                }
                
                const result = await response.json();
                console.log('[VoiceSwap] Success:', result);
                
                // Get voice reference info for display
                const voiceRefName = voiceFile ? voiceFile.name : (clipVoiceRefs.length > 0 ? `${clipVoiceRefs.length} clip(s)` : 'unknown');
                
                // Shorten source filename for display
                const sourceShort = videoFilename.replace('final_export_', '').replace('voice_cloned_', 'vc_').replace('.mp4', '');
                
                // Save metadata for persistence after refresh
                const pitchLabelForSave = pitchNormalize > 0 ? `${(pitchNormalize*100).toFixed(0)}%` : null;
                saveExportMetadata(result.filename, {
                    provider: 'openvoice',
                    tau: tau,
                    voiceRef: voiceRefName,
                    pitch: pitchLabelForSave
                });
                
                // Update progress to success
                const progressEl = container.querySelector('.voice-swap-progress');
                if (progressEl) {
                    const pitchLabel = pitchNormalize > 0 ? ` • pitch=${(pitchNormalize*100).toFixed(0)}%` : '';
                    progressEl.className = 'voice-swap-complete'; // Change class so it won't be removed on next voice swap
                    progressEl.style.background = 'linear-gradient(90deg, #9333ea 0%, #6366f1 100%)';
                    progressEl.dataset.filename = result.filename;
                    progressEl.dataset.downloadUrl = result.download_url;
                    progressEl.dataset.type = 'voice-openvoice';
                    progressEl.innerHTML = `
                        <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                            <div style="flex:1;min-width:0;">
                                <h3 style="margin:0;font-size:13px;color:white;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">✅ ${result.filename}</h3>
                                <p style="margin:4px 0 0;font-size:11px;color:rgba(255,255,255,0.9);">OpenVoice • tau=${tau} • 🎤 ${voiceRefName}${pitchLabel}</p>
                            </div>
                            <div style="display:flex;gap:6px;align-items:center;margin-left:12px;">
                                <button onclick="openVoiceSwapForFile('${jobId}', '${result.filename}')" style="padding:6px 10px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;" title="Re-clone">🎤 <span>Voice</span></button>
                                <button onclick="downloadClip('${result.download_url}','${result.filename}')" style="padding:6px 10px;background:white;color:#9333ea;border:none;border-radius:var(--radius-sm);font-size:11px;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:4px;">📥 <span>Download</span></button>
                                <button onclick="this.closest('.voice-swap-complete').remove()" style="padding:6px 8px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;" title="Remove">✕</button>
                            </div>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('[VoiceSwap] Error:', error);
                
                const progressEl = container.querySelector('.voice-swap-progress');
                if (progressEl) {
                    progressEl.innerHTML = `
                        <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                            <h3 style="margin:0;font-size:14px;color:white;">❌ Voice Clone Failed</h3>
                            <span style="font-size:11px;color:rgba(255,255,255,0.9);">${error.message}</span>
                        </div>
                    `;
                    progressEl.style.background = 'var(--danger)';
                    setTimeout(() => progressEl?.remove(), 5000);
                }
            } finally {
                isVoiceSwapping = false;
            }
        }
        
        async function doVoiceSwapElevenLabs(jobId, videoFilename, apiKey, voiceId, settings = {}) {
            isVoiceSwapping = true;
            
            const container = document.getElementById('clipsList');
            
            // Ensure exports section exists
            ensureExportsSection(jobId);
            const exportsContent = container.querySelector('.exports-content');
            
            // Add progress indicator
            const progressHtml = `
                <div class="voice-swap-progress" style="background:linear-gradient(90deg, #9333ea 0%, #6366f1 100%);padding:12px 16px;border-radius:var(--radius-md);margin-bottom:8px;">
                    <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                        <div style="display:flex;align-items:center;gap:12px">
                            <div class="voice-spinner" style="width:20px;height:20px;border:2px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin 1s linear infinite;"></div>
                            <h3 style="margin:0;font-size:14px;color:white;">🎤 Cloning Voice (ElevenLabs)...</h3>
                        </div>
                        <span style="font-size:11px;color:rgba(255,255,255,0.7);">Voice conversion takes 30-60 seconds</span>
                    </div>
                </div>
                <style>.voice-spinner{animation:spin 1s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}</style>
            `;
            if (exportsContent) {
                exportsContent.insertAdjacentHTML('afterbegin', progressHtml);
            } else {
                container.insertAdjacentHTML('afterbegin', progressHtml);
            }
            
            try {
                const formData = new FormData();
                formData.append('video_filename', videoFilename);
                formData.append('provider', 'elevenlabs');
                formData.append('elevenlabs_api_key', apiKey);
                formData.append('elevenlabs_voice_id', voiceId);
                formData.append('elevenlabs_stability', settings.stability ?? 0.5);
                formData.append('elevenlabs_similarity', settings.similarity ?? 0.75);
                formData.append('elevenlabs_style', settings.style ?? 0);
                formData.append('elevenlabs_remove_noise', settings.removeNoise ?? true);
                formData.append('elevenlabs_speaker_boost', settings.speakerBoost ?? true);
                
                const response = await fetch(
                    `${API}/jobs/${jobId}/voice-swap`,
                    {
                        method: 'POST',
                        body: formData
                    }
                );
                
                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    throw new Error(err.detail || 'Voice swap failed');
                }
                
                const result = await response.json();
                console.log('[VoiceSwap ElevenLabs] Success:', result);
                
                // Shorten source filename for display
                const sourceShort = videoFilename.replace('final_export_', '').replace('voice_cloned_', 'vc_').replace('.mp4', '');
                
                // Save metadata for persistence after refresh
                const stabLabel = (settings.stability ?? 0.5).toFixed(1);
                const simLabel = (settings.similarity ?? 0.75).toFixed(2);
                saveExportMetadata(result.filename, {
                    provider: 'elevenlabs',
                    stability: stabLabel,
                    similarity: simLabel
                });
                
                // Update progress to success
                const progressEl = container.querySelector('.voice-swap-progress');
                if (progressEl) {
                    progressEl.className = 'voice-swap-complete'; // Change class so it won't be removed on next voice swap
                    progressEl.style.background = 'linear-gradient(90deg, #9333ea 0%, #6366f1 100%)';
                    progressEl.dataset.filename = result.filename;
                    progressEl.dataset.downloadUrl = result.download_url;
                    progressEl.dataset.type = 'voice-elevenlabs';
                    progressEl.innerHTML = `
                        <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                            <div style="flex:1;min-width:0;">
                                <h3 style="margin:0;font-size:13px;color:white;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">✅ ${result.filename}</h3>
                                <p style="margin:4px 0 0;font-size:11px;color:rgba(255,255,255,0.9);">ElevenLabs • stab=${stabLabel} • sim=${simLabel}</p>
                            </div>
                            <div style="display:flex;gap:6px;align-items:center;margin-left:12px;">
                                <button onclick="openVoiceSwapForFile('${jobId}', '${result.filename}')" style="padding:6px 10px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;display:flex;align-items:center;gap:4px;" title="Re-clone">🎤 <span>Voice</span></button>
                                <button onclick="downloadClip('${result.download_url}','${result.filename}')" style="padding:6px 10px;background:white;color:#9333ea;border:none;border-radius:var(--radius-sm);font-size:11px;font-weight:600;cursor:pointer;display:flex;align-items:center;gap:4px;">📥 <span>Download</span></button>
                                <button onclick="this.closest('.voice-swap-complete').remove()" style="padding:6px 8px;background:rgba(255,255,255,0.2);color:white;border:none;border-radius:var(--radius-sm);font-size:11px;cursor:pointer;" title="Remove">✕</button>
                            </div>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('[VoiceSwap ElevenLabs] Error:', error);
                
                const progressEl = container.querySelector('.voice-swap-progress');
                if (progressEl) {
                    progressEl.innerHTML = `
                        <div style="display:flex;align-items:center;justify-content:space-between;width:100%">
                            <h3 style="margin:0;font-size:14px;color:white;">❌ Voice Clone Failed</h3>
                            <span style="font-size:11px;color:rgba(255,255,255,0.9);">${error.message}</span>
                        </div>
                    `;
                    progressEl.style.background = 'var(--danger)';
                    setTimeout(() => progressEl?.remove(), 5000);
                }
            } finally {
                isVoiceSwapping = false;
            }
        }
        
        async function cloneJob(id){
            // Show loading overlay
            let overlay = document.getElementById('cloneOverlay');
            if(!overlay){
                overlay = document.createElement('div');
                overlay.id = 'cloneOverlay';
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;backdrop-filter:blur(4px);';
                overlay.innerHTML = `<div style="background:var(--bg-card,#1a1a2e);border:1px solid var(--border,#2a2a3e);border-radius:12px;padding:32px 48px;text-align:center;box-shadow:0 20px 60px rgba(0,0,0,0.5);">
                    <div style="width:40px;height:40px;border:3px solid rgba(255,255,255,0.1);border-top-color:var(--primary,#6366f1);border-radius:50%;animation:cloneSpin 0.8s linear infinite;margin:0 auto 16px;"></div>
                    <div style="color:white;font-size:15px;font-weight:500;" id="cloneStatus">Cloning job...</div>
                    <div style="color:rgba(255,255,255,0.5);font-size:12px;margin-top:8px;" id="cloneDetail">Loading configuration</div>
                </div>`;
                document.body.appendChild(overlay);
                if(!document.getElementById('cloneSpinStyle')){
                    const style = document.createElement('style');
                    style.id = 'cloneSpinStyle';
                    style.textContent = '@keyframes cloneSpin{to{transform:rotate(360deg)}}';
                    document.head.appendChild(style);
                }
            }
            overlay.style.display = 'flex';
            const setStatus = (msg, detail) => {
                const s = document.getElementById('cloneStatus');
                const d = document.getElementById('cloneDetail');
                if(s) s.textContent = msg;
                if(d) d.textContent = detail || '';
            };
            try {
                setStatus('Cloning job...', 'Loading configuration');
                const r = await fetch(`${API}/jobs/${id}/config`);
                if(!r.ok) throw new Error('Failed to load job config');
                const data = await r.json();
                
                // Switch to create mode
                collapseResults();
                
                // Populate config settings
                const cfg = data.config || {};
                
                // Aspect ratio
                document.querySelectorAll('#aspectSeg button').forEach(b => {
                    b.classList.remove('active');
                    if(b.dataset.value === cfg.aspect_ratio) b.classList.add('active');
                });
                
                // Resolution
                document.querySelectorAll('#resSeg button').forEach(b => {
                    b.classList.remove('active');
                    if(b.dataset.value === cfg.resolution) b.classList.add('active');
                });
                
                // Duration
                const durationEl = document.getElementById('duration');
                if(durationEl && cfg.duration) durationEl.value = cfg.duration;
                
                // Language
                const langEl = document.getElementById('language');
                if(langEl && cfg.language) langEl.value = cfg.language;
                
                // AI Prompts seg
                const useAICfg = cfg.use_openai_prompt_tuning !== false;
                document.querySelectorAll('#aiSeg button').forEach(b => {
                    b.classList.toggle('active', b.dataset.value === (useAICfg ? 'true' : 'false'));
                });
                
                // User context
                const contextEl = document.getElementById('contextInput');
                if(contextEl && cfg.user_context) contextEl.value = cfg.user_context;
                
                // Custom prompt
                const customPromptEl = document.getElementById('customPrompt');
                if(customPromptEl && cfg.custom_prompt) customPromptEl.value = cfg.custom_prompt;
                
                // Dialogue lines
                const dialogueLines = data.dialogue_lines || [];
                if(dialogueLines.length > 0) {
                    const formattedLines = dialogueLines.map((l, i) => `${l.id || i+1}|${l.text}`).join('\n');
                    document.getElementById('dialogueInput').value = formattedLines;
                }
                
                // Load images from the job
                if(data.images && data.images.length > 0) {
                    setStatus('Loading images...', `${data.images.length} image${data.images.length>1?'s':''} to clone`);
                    // We need to re-upload the images or reference them
                    // For now, show a message that images need to be re-uploaded
                    uploadedImages = [];
                    uploadedFilesData = [];
                    
                    // Try to load images as dataURLs
                    const imageLoadPromises = data.images.map(async (img, idx) => {
                        try {
                            const imgResponse = await fetch(img.url);
                            const blob = await imgResponse.blob();
                            return new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    resolve({
                                        name: img.filename,
                                        originalName: img.filename,
                                        dataUrl: e.target.result,
                                        index: idx
                                    });
                                };
                                reader.readAsDataURL(blob);
                            });
                        } catch(e) {
                            console.error('Failed to load image:', img.filename, e);
                            return null;
                        }
                    });
                    
                    const loadedImages = (await Promise.all(imageLoadPromises)).filter(img => img !== null);
                    
                    if(loadedImages.length > 0) {
                        // Re-upload images to create new job
                        const fd = new FormData();
                        setStatus('Uploading images...', `${loadedImages.length} image${loadedImages.length>1?'s':''}`);
                        for(const img of loadedImages) {
                            // Convert dataUrl back to blob
                            const response = await fetch(img.dataUrl);
                            const blob = await response.blob();
                            fd.append('files', blob, img.name);
                        }
                        
                        const uploadResponse = await fetch(`${API}/upload`, {method: 'POST', body: fd});
                        const uploadData = await uploadResponse.json();
                        uploadJobId = uploadData.job_id;
                        uploadedImages = uploadData.uploaded;
                        
                        // CRITICAL: Update uploadedFilesData with correct server indices
                        uploadedFilesData = loadedImages.map((img, i) => {
                            const serverInfo = uploadData.uploaded.find(u => u.original_filename === img.name || u.filename === img.name);
                            return {
                                ...img,
                                index: serverInfo ? serverInfo.index : i
                            };
                        });
                        
                        document.getElementById('uploadedCount').textContent = `✓ ${uploadedImages.length} image${uploadedImages.length>1?'s':''} cloned`;
                    }
                }
                
                // Handle scenes/storyboard mode
                if(data.scenes && data.scenes.length > 0 && cfg.storyboard_mode) {
                    sceneBreaks = data.scenes.map(s => ({
                        lineIndex: s.clips[0] || 0,
                        imgIndex: s.imageIndex,
                        clipMode: s.clipMode || 'blend',
                        transition: s.transition || 'blend'
                    }));
                    setEditorMode('storyboard');
                } else {
                    setEditorMode('auto');
                }
                
                // Auto-split OFF for cloned jobs — lines are already split
                const toggle1 = document.getElementById('autoSplitToggle');
                const toggle2 = document.getElementById('autoSplitToggleStoryboard');
                if(toggle1) toggle1.classList.remove('active');
                if(toggle2) toggle2.classList.remove('active');
                
                // Update UI
                setStatus('Finalizing...', 'Setting up editor');
                updateUIMode();
                renderSimpleEditor();
                validateDialogueLines();
                
                document.getElementById('cloneOverlay').style.display = 'none';
                alert('Job settings cloned! Review and click Start Generation when ready.');
                
            } catch(e) {
                console.error('Clone error:', e);
                const ov = document.getElementById('cloneOverlay');
                if(ov) ov.style.display = 'none';
                alert('Failed to clone job: ' + e.message);
            }
        }
        
        function showKeysExhaustedAlert(data){
            removeAlert();
            const alert=document.createElement('div');
            alert.id='keysAlert';
            alert.className='alert-banner';
            alert.innerHTML=`<h4>⚠️ API Keys Exhausted</h4><p>${data.message}</p>`;
            document.querySelector('.results-panel .card')?.prepend(alert);
        }
        function showContactSupportAlert(data){
            removeAlert();
            const alert=document.createElement('div');
            alert.id='keysAlert';
            alert.className='alert-banner';
            alert.innerHTML=`<h4>🚨 Generation Failed - No API Keys</h4><p>${data.message}</p><p style="margin-top:8px"><a href="mailto:support@example.com">Contact Support</a> to resolve this issue.</p>`;
            document.querySelector('.results-panel .card')?.prepend(alert);
        }
        function removeAlert(){document.getElementById('keysAlert')?.remove();}
        
        // Poll for special events (keys exhausted, etc.)
        async function checkJobEvents(jobId){
            try{
                const r=await fetch(`${API}/jobs/${jobId}/logs?limit=10`);
                if(!r.ok)return;
                const logs=await r.json();
                for(const log of logs){
                    if(log.message.includes('API keys exhausted') && log.message.includes('Waiting')){
                        showKeysExhaustedAlert({message:log.message});
                        return;
                    }
                    if(log.message.includes('Job failed') && log.message.includes('contact support')){
                        showContactSupportAlert({message:log.message});
                        return;
                    }
                }
                // No alert conditions, remove any existing alert
                const job=await(await fetch(`${API}/jobs/${jobId}`)).json();
                if(job.status==='completed'||job.status==='running')removeAlert();
            }catch(e){}
        }
        
        // Add to polling
        const origLoadJob=loadJob;
        loadJob=async function(id){await origLoadJob(id);await checkJobEvents(id);};
        
        refreshJobs();
        
        // Image hover preview
        const imagePreview = document.createElement('div');
        imagePreview.id = 'imagePreview';
        imagePreview.innerHTML = '<img src="" alt="Preview">';
        document.body.appendChild(imagePreview);
        
        function showImagePreview(e, imgSrc) {
            const preview = document.getElementById('imagePreview');
            const img = preview.querySelector('img');
            img.src = imgSrc;
            preview.classList.add('visible');
            updatePreviewPosition(e);
        }
        
        function hideImagePreview() {
            const preview = document.getElementById('imagePreview');
            preview.classList.remove('visible');
        }
        
        function updatePreviewPosition(e) {
            const preview = document.getElementById('imagePreview');
            if (!preview.classList.contains('visible')) return;
            
            const padding = 15;
            let x = e.clientX + padding;
            let y = e.clientY + padding;
            
            // Get preview dimensions (use estimates if not yet rendered)
            const previewRect = preview.getBoundingClientRect();
            const previewWidth = previewRect.width || 250;
            const previewHeight = previewRect.height || 300;
            
            // Keep within viewport
            if (x + previewWidth > window.innerWidth - padding) {
                x = e.clientX - previewWidth - padding;
            }
            if (y + previewHeight > window.innerHeight - padding) {
                y = e.clientY - previewHeight - padding;
            }
            if (x < padding) x = padding;
            if (y < padding) y = padding;
            
            preview.style.left = x + 'px';
            preview.style.top = y + 'px';
        }
        
        // Attach hover events to images (using event delegation)
        document.addEventListener('mouseover', function(e) {
            // Check if hovering over sidebar image
            const sidebarImg = e.target.closest('.storyboard-sidebar-image');
            if (sidebarImg) {
                const img = sidebarImg.querySelector('img');
                if (img) showImagePreview(e, img.src);
                return;
            }
            
            // Check if hovering over scene divider image
            const sceneDivider = e.target.closest('.scene-divider');
            if (sceneDivider) {
                const img = sceneDivider.querySelector('img');
                if (img) showImagePreview(e, img.src);
                return;
            }
            
            // Check if hovering over simple mode thumbnail
            const thumbImg = e.target.closest('.image-thumb');
            if (thumbImg) {
                const img = thumbImg.querySelector('img');
                if (img) showImagePreview(e, img.src);
                return;
            }
            
            // If not hovering over any image element, hide preview
            hideImagePreview();
        });
        
        document.addEventListener('mouseout', function(e) {
            const sidebarImg = e.target.closest('.storyboard-sidebar-image');
            const sceneDivider = e.target.closest('.scene-divider');
            const thumbImg = e.target.closest('.image-thumb');
            
            if (sidebarImg || sceneDivider || thumbImg) {
                // Check if we're moving to a child element
                const related = e.relatedTarget;
                if (related && (
                    (sidebarImg && sidebarImg.contains(related)) ||
                    (sceneDivider && sceneDivider.contains(related)) ||
                    (thumbImg && thumbImg.contains(related))
                )) {
                    return;
                }
                hideImagePreview();
            }
        });
        
        // Also hide preview when mouse leaves the document
        document.addEventListener('mouseleave', function() {
            hideImagePreview();
        });
        
        document.addEventListener('mousemove', function(e) {
            // Only update position if preview is visible AND we're still over an image
            const preview = document.getElementById('imagePreview');
            if (!preview.classList.contains('visible')) return;
            
            // Check if still hovering over an image element
            const target = document.elementFromPoint(e.clientX, e.clientY);
            if (target) {
                const isOverImage = target.closest('.storyboard-sidebar-image') || 
                                   target.closest('.scene-divider') || 
                                   target.closest('.image-thumb');
                if (!isOverImage) {
                    hideImagePreview();
                    return;
                }
            }
            
            updatePreviewPosition(e);
        });
        
        // Event delegation for Voice Swap button - prevents missed clicks during DOM updates
        document.addEventListener('click', function(e) {
            const voiceBtn = e.target.closest('[data-voice-swap]');
            if (voiceBtn) {
                e.preventDefault();
                e.stopPropagation();
                const jobId = voiceBtn.dataset.voiceSwap;
                if (jobId) {
                    openVoiceSwap(jobId);
                }
            }
        });
        
        // =============================================================================
        // Tutorial System (iframe-based — content lives in /static/tutorial.html)
        // =============================================================================
        const TUTORIAL_STORAGE_KEY = 'veo_tutorial_dismissed';
        let tutorialScrollPollTimer = null;
        let tutorialHasReachedBottom = false;
        
        function openTutorial() {
            const overlay = document.getElementById('tutorialOverlay');
            const iframe = document.getElementById('tutorialIframe');
            const closeBtn = document.getElementById('tutorialCloseBtn');
            const hint = document.getElementById('tutorialScrollHint');
            const progressFill = document.getElementById('tutorialProgressFill');
            const pctLabel = document.getElementById('tutorialScrollPct');
            
            // Reset state
            tutorialHasReachedBottom = false;
            closeBtn.classList.remove('enabled');
            hint.classList.remove('hidden');
            progressFill.style.width = '0%';
            pctLabel.textContent = '0% read';
            document.getElementById('tutorialDontShow').checked = false;
            
            // Load tutorial page into iframe
            iframe.src = '/static/tutorial.html';
            
            // Show overlay
            overlay.classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Start polling iframe scroll position (cross-origin safe since same origin)
            if (tutorialScrollPollTimer) clearInterval(tutorialScrollPollTimer);
            tutorialScrollPollTimer = setInterval(pollTutorialScroll, 200);
        }
        
        function pollTutorialScroll() {
            try {
                const iframe = document.getElementById('tutorialIframe');
                if (!iframe || !iframe.contentWindow || !iframe.contentDocument) return;
                
                const doc = iframe.contentDocument;
                const scrollTop = doc.documentElement.scrollTop || doc.body.scrollTop;
                const scrollHeight = Math.max(
                    doc.documentElement.scrollHeight,
                    doc.body.scrollHeight
                ) - (iframe.clientHeight || doc.documentElement.clientHeight);
                
                if (scrollHeight <= 0) return; // Not loaded yet
                
                const pct = Math.min(100, Math.round((scrollTop / scrollHeight) * 100));
                
                document.getElementById('tutorialProgressFill').style.width = pct + '%';
                document.getElementById('tutorialScrollPct').textContent = pct + '% read';
                
                // Hide scroll hint after 15%
                if (pct > 15) {
                    document.getElementById('tutorialScrollHint').classList.add('hidden');
                }
                
                // Enable close at 95%
                if (pct >= 95 && !tutorialHasReachedBottom) {
                    tutorialHasReachedBottom = true;
                    document.getElementById('tutorialCloseBtn').classList.add('enabled');
                }
            } catch (e) {
                // iframe not ready yet — ignore
            }
        }
        
        function closeTutorial() {
            if (!tutorialHasReachedBottom) return;
            
            document.getElementById('tutorialOverlay').classList.remove('show');
            document.body.style.overflow = '';
            
            // Stop polling
            if (tutorialScrollPollTimer) {
                clearInterval(tutorialScrollPollTimer);
                tutorialScrollPollTimer = null;
            }
            
            // Clear iframe to free memory
            document.getElementById('tutorialIframe').src = 'about:blank';
            
            // Save preference
            if (document.getElementById('tutorialDontShow').checked) {
                try { localStorage.setItem(TUTORIAL_STORAGE_KEY, 'true'); } catch(e) {}
            }
        }
        
        function checkShowTutorial() {
            try {
                if (localStorage.getItem(TUTORIAL_STORAGE_KEY) === 'true') return;
            } catch(e) {}
            openTutorial();
        }
        
        // =============================================================================
        // Onboarding Sidebar — Reactive Step-by-Step Guide
        // =============================================================================
        const OB_STORAGE_KEY = 'veo_onboarding_state';
        const OB_DISMISSED_KEY = 'veo_onboarding_dismissed';
        let obCurrentStep = null;
        let obPollTimer = null;
        
        // Step definitions — each step has an id, condition checker, and content generator
        const OB_STEPS = [
            {
                id: 'api_keys',
                title: '🔧 Choose Your Method',
                check: () => {
                    // Pass if user has API keys OR has selected Flow mode
                    const hasKeysVar = typeof userApiKeys !== 'undefined' && Array.isArray(userApiKeys) && userApiKeys.length > 0;
                    console.log('[Onboarding] API key check — userApiKeys:', typeof userApiKeys, Array.isArray(userApiKeys) ? userApiKeys.length : 'N/A', 'hasKeys:', hasKeysVar);
                    if (hasKeysVar) return true;
                    // Also check the DOM — the keys list has items
                    const listEl = document.getElementById('apiKeysList');
                    if (listEl) {
                        const keyItems = listEl.querySelectorAll('.api-key-item');
                        if (keyItems.length > 0) {
                            console.log('[Onboarding] API key check — found', keyItems.length, 'key items in DOM');
                            return true;
                        }
                    }
                    // Also pass if Flow is selected
                    const backendBtn = document.querySelector('#backendToggle button.active');
                    if (backendBtn && backendBtn.dataset.value === 'flow') return true;
                    return false;
                },
                content: () => `
                    <div class="ob-step-num">1</div>
                    <div class="ob-step-title">Choose Your Method</div>
                    <div class="ob-step-desc">
                        <p>Pick how you want to generate videos. You have <strong>two options</strong>:</p>
                    </div>
                    
                    <div style="display:flex;flex-direction:column;gap:14px;margin:16px 0;">
                        <div style="padding:14px 16px;background:rgba(16,185,129,0.06);border:1px solid rgba(16,185,129,0.2);border-radius:10px;">
                            <div style="font-weight:600;color:var(--success);margin-bottom:8px;font-size:14px;">🔑 Option A: API Keys <span style="font-size:11px;font-weight:400;color:var(--text-muted);">(faster)</span></div>
                            <p style="font-size:12px;color:var(--text-secondary);line-height:1.6;margin:0;">Use your own Gemini API keys for direct video generation. Faster processing, no worker needed.</p>
                            <ol class="ob-step-list" style="margin-top:10px;font-size:12px;">
                                <li>Go to <a href="https://console.cloud.google.com" target="_blank">console.cloud.google.com</a> → <strong>"Start for Free"</strong></li>
                                <li><strong>Create a Project</strong> → enable <strong>"Generative Language API"</strong></li>
                                <li><strong>Credentials → + Create Credentials → API Key</strong></li>
                                <li>Click your <strong>profile avatar</strong> (top-right) → <strong>"🔑 API Keys"</strong> → paste it</li>
                            </ol>
                        </div>
                        
                        <div style="text-align:center;color:var(--text-muted);font-size:12px;font-weight:500;">— OR —</div>
                        
                        <div style="padding:14px 16px;background:rgba(99,102,241,0.06);border:1px solid rgba(99,102,241,0.2);border-radius:10px;">
                            <div style="font-weight:600;color:var(--accent);margin-bottom:8px;font-size:14px;">🖥️ Option B: Flow <span style="font-size:11px;font-weight:400;color:var(--text-muted);">(no API key needed)</span></div>
                            <p style="font-size:12px;color:var(--text-secondary);line-height:1.6;margin:0;">Use your <strong>Google account</strong> to generate videos through Google Flow — browser automation runs on your computer.</p>
                            <ol class="ob-step-list" style="margin-top:10px;font-size:12px;">
                                <li>In <strong>Settings</strong> below, set Method to <strong>"Flow"</strong></li>
                                <li>Click <strong>"🖥️ My Worker"</strong> in the top bar</li>
                                <li>Follow the setup to install & run the worker on your PC</li>
                                <li>Keep the worker running while generating</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="ob-tip"><strong>💡 Tip:</strong> Not sure? Try <strong>Flow</strong> first — it's free and uses your existing Google account. Switch to API Keys later for faster processing.</div>
                    <div class="ob-status waiting" id="obKeyStatus">
                        <span class="ob-spinner">⏳</span> Add an API key or select <strong>Flow</strong> in Settings to continue...
                    </div>
                `,
            },
            {
                id: 'upload_images',
                title: '📤 Upload Images',
                check: () => {
                    // Check multiple signals for image upload
                    if (uploadedImages.length > 0) return true;
                    if (uploadedFilesData.length > 0) return true;
                    // Also check DOM — the upload area shows a count
                    const countEl = document.getElementById('uploadedCount');
                    if (countEl && countEl.textContent.includes('✓')) return true;
                    return false;
                },
                content: () => `
                    <div class="ob-step-num">2</div>
                    <div class="ob-step-title">Upload Your Images</div>
                    <div class="ob-step-desc">
                        <p><strong>Drag & drop</strong> images onto the upload area on the left, or click to browse. Accepted formats: PNG, JPG, WebP.</p>
                        <p>The number of images you upload determines your editing mode:</p>
                    </div>
                    <ol class="ob-step-list">
                        <li><strong>1 image</strong> → <strong>Simple Mode</strong> — same image for all clips. Perfect for single-speaker talking heads.</li>
                        <li><strong>2+ images</strong> → <strong>Multi-scene mode</strong> — unlocks <strong>Auto-Cycle</strong> (images rotate automatically) and <strong>Storyboard</strong> (full manual control over scenes, transitions, and clip behavior).</li>
                    </ol>
                    <div class="ob-tip"><strong>💡 Tip:</strong> Use clear, well-lit, front-facing photos. Clean backgrounds help the AI focus on the subject. You can always add more images later to switch modes.</div>
                    <div class="ob-status waiting">
                        <span class="ob-spinner">⏳</span> Waiting for image upload...
                    </div>
                `,
            },
            {
                id: 'mode_single',
                title: '⚙️ Single Image Mode',
                condition: () => (uploadedImages.length === 1 || uploadedFilesData.length === 1),
                check: () => {
                    const ta = document.getElementById('dialogueInput');
                    return ta && ta.value.trim().length > 10;
                },
                content: () => `
                    <div class="ob-step-num">3</div>
                    <div class="ob-step-title">Simple Mode — Settings, Script & Generate</div>
                    <div class="ob-step-desc">
                        <p>You uploaded <strong>1 image</strong> → <strong>Simple Mode</strong>. The same image is used as the starting frame for every clip.</p>
                    </div>
                    
                    <div class="ob-step-desc"><strong style="color:var(--text-primary);font-size:14px;">⚙️ Settings (left panel)</strong></div>
                    <ol class="ob-step-list">
                        <li><strong>Language</strong> — Select the language your script is written in (EN, IT, ES, FR, DE). This affects auto-split word count and speaking rate.</li>
                        <li><strong>Words per line</strong> — How many words fit per clip (default ~21). Lower = shorter clips, higher = longer clips.</li>
                        <li><strong>Duration</strong> — Length of each clip. <strong>Use 8 seconds</strong> — it's required for Interpolation and 1080p resolution.</li>
                        <li><strong>Aspect Ratio</strong> — 16:9 for landscape (YouTube) or 9:16 for portrait (TikTok, Reels, Shorts).</li>
                        <li><strong>Resolution</strong> — 720p or 1080p. Higher quality requires 8s duration.</li>
                        <li><strong>Interpolation</strong> — <strong>Turn ON</strong>. Creates smooth motion between frames. Requires 8s duration.</li>
                        <li><strong>AI Prompts</strong> — ON = the AI optimizes visual prompts automatically. OFF = you write your own prompts per clip.</li>
                    </ol>
                    
                    <div class="ob-step-desc" style="margin-top:16px;"><strong style="color:var(--text-primary);font-size:14px;">✍️ Dialogue Script</strong></div>
                    <div class="ob-step-desc">
                        <p>Type or paste the text your subject will speak. This is the <strong>actual spoken dialogue</strong> — write it as natural speech.</p>
                        <p><strong>Auto-split</strong> (enabled by default) breaks long text into clips of ~8 seconds each. You can also turn it off and press Enter to manually define where each clip starts.</p>
                    </div>
                    <div class="ob-tip"><strong>💡 Writing tips:</strong> Use conversational language with contractions ("I'm", "don't", "we've"). Write numbers as words ("twenty five" not "25"). Keep sentences flowing naturally — avoid bullet points or fragmented phrases.</div>
                    
                    <div class="ob-step-desc" style="margin-top:12px;">
                        <p><strong>Context for AI</strong> (optional text area below the toggles) — Describe the speaker's role, mood, setting, or voice style. Example: <em>"Professional doctor, confident tone, medical office background"</em></p>
                    </div>
                    
                    <div class="ob-tip"><strong>🔄 Want multi-scene mode?</strong> Upload a 2nd image to unlock <strong>Auto-Cycle</strong> (images rotate through clips) and <strong>Storyboard</strong> (drag images to create scenes with transitions). Just drop more images in the upload area above.</div>
                    
                    <div class="ob-status waiting">
                        <span class="ob-spinner">⏳</span> Write your dialogue script to continue...
                    </div>
                `,
            },
            {
                id: 'mode_autocycle',
                title: '🔄 Auto-Cycle Mode',
                condition: () => (uploadedImages.length >= 2 || uploadedFilesData.length >= 2) && editorMode === 'auto',
                check: () => {
                    const lines = getDialogueLines();
                    return lines && lines.length > 0 && lines[0].trim().length > 5;
                },
                content: () => `
                    <div class="ob-step-num">3</div>
                    <div class="ob-step-title">Auto-Cycle Mode — Settings, Script & Scenes</div>
                    <div class="ob-step-desc">
                        <p>You uploaded <strong>${uploadedImages.length || uploadedFilesData.length} images</strong> in <strong>Auto-Cycle</strong> mode. Images rotate through clips automatically: Clip 1 → Image 1, Clip 2 → Image 2, ${(uploadedImages.length || uploadedFilesData.length) > 2 ? 'Clip 3 → Image 3, ' : ''}then back to Image 1.</p>
                    </div>
                    
                    <div class="ob-step-desc"><strong style="color:var(--text-primary);font-size:14px;">⚙️ Settings</strong></div>
                    <ol class="ob-step-list">
                        <li><strong>Language</strong> — Must match your script's language. Affects auto-split and speaking rate.</li>
                        <li><strong>Duration → 8 seconds</strong> — Required for Interpolation (smooth transitions between images) and 1080p.</li>
                        <li><strong>Aspect Ratio</strong> — 16:9 (landscape) or 9:16 (portrait).</li>
                        <li><strong>Resolution</strong> — 720p or 1080p (1080p requires 8s).</li>
                        <li><strong>Interpolation → ON</strong> — Especially important here: it creates the smooth morph effect as clips transition between different images.</li>
                        <li><strong>AI Prompts → ON</strong> — Let the AI optimize visual descriptions for each clip.</li>
                    </ol>
                    
                    <div class="ob-step-desc" style="margin-top:12px;"><strong style="color:var(--text-primary);font-size:14px;">🔀 Generation Mode</strong></div>
                    <div class="ob-step-desc">
                        <p>With 2+ images, you'll see a generation mode selector:</p>
                        <p><strong>🔀 Smart</strong> (recommended) — Generates odd clips first, then even clips use confirmed end frames for smooth transitions.</p>
                        <p><strong>⚡ Fast</strong> — All clips simultaneously. Fastest but transitions may be rougher.</p>
                        <p><strong>🔗 Safe</strong> — One at a time, sequentially. Slowest but maximum visual continuity.</p>
                    </div>
                    
                    <div class="ob-step-desc" style="margin-top:12px;"><strong style="color:var(--text-primary);font-size:14px;">✍️ Dialogue Script</strong></div>
                    <div class="ob-step-desc">
                        <p>Write the spoken dialogue as <strong>natural speech</strong>. Auto-split will break it into clips. Each clip gets the next image in rotation automatically.</p>
                    </div>
                    <div class="ob-tip"><strong>💡 Writing tips:</strong> Write conversationally — use contractions, spell out numbers as words ("thirty five" not "35"), and keep sentences flowing. The AI needs natural speech patterns to generate convincing lip-sync.</div>
                    
                    <div class="ob-step-desc" style="margin-top:8px;">
                        <p>Want more control? Switch to <strong>🎬 Storyboard</strong> mode (top-right of script editor) to manually assign images to specific clips.</p>
                    </div>
                    
                    <div class="ob-status waiting">
                        <span class="ob-spinner">⏳</span> Write your dialogue script to continue...
                    </div>
                `,
            },
            {
                id: 'mode_storyboard',
                title: '🎬 Storyboard Mode',
                condition: () => (uploadedImages.length >= 2 || uploadedFilesData.length >= 2) && editorMode === 'storyboard',
                check: () => {
                    const lines = getDialogueLines();
                    return lines && lines.length > 0 && lines[0].trim().length > 5;
                },
                content: () => `
                    <div class="ob-step-num">3</div>
                    <div class="ob-step-title">Storyboard Mode — Full Control</div>
                    <div class="ob-step-desc">
                        <p>You're in <strong>Storyboard</strong> mode with <strong>${uploadedImages.length || uploadedFilesData.length} images</strong>. This gives you complete control over which image appears in which clips, and how scenes transition.</p>
                    </div>
                    
                    <div class="ob-step-desc"><strong style="color:var(--text-primary);font-size:14px;">⚙️ Settings (same as other modes)</strong></div>
                    <ol class="ob-step-list">
                        <li><strong>Duration → 8 seconds</strong> — Required for Interpolation and 1080p.</li>
                        <li><strong>Interpolation → ON</strong> — Creates smooth morphs between scenes (especially for BLEND TO transitions).</li>
                        <li><strong>AI Prompts → ON</strong> recommended — Let AI optimize visual prompts.</li>
                        <li><strong>Language</strong> must match your script. Aspect ratio and resolution as needed.</li>
                    </ol>
                    
                    <div class="ob-step-desc" style="margin-top:16px;"><strong style="color:var(--text-primary);font-size:14px;">🎬 How Storyboard Works</strong></div>
                    <div class="ob-step-desc">
                        <p>Here's an example of the storyboard editor in action:</p>
                    </div>
                    <img src="/static/storyboard-example.png" alt="Storyboard example" style="width:100%;border-radius:8px;border:1px solid var(--border-color);margin:8px 0 4px;box-shadow:0 2px 12px rgba(0,0,0,0.3);">
                    <div style="font-size:10px;color:var(--text-muted);text-align:center;margin-bottom:14px;font-style:italic;">3 scenes, 2 images, 6 clips — with clip modes and transitions</div>
                    
                    <ol class="ob-step-list">
                        <li><strong>Drag images</strong> from the left sidebar into the text to create scene breaks. Each scene block shows which image it uses and which clip numbers it covers.</li>
                        <li><strong>Write dialogue</strong> inside each scene — lines within a scene will use that scene's image as their starting frame.</li>
                    </ol>
                    
                    <div class="ob-step-desc" style="margin-top:14px;"><strong style="color:var(--text-primary);font-size:14px;">🎨 Clip Modes</strong> <span style="font-size:12px;color:var(--text-muted);">(buttons inside each scene header)</span></div>
                    <div class="ob-step-desc">
                        <p><span style="background:#6366f1;color:white;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600;">BLEND</span> — Each clip starts from the <strong>original photo</strong>. The AI generates from that image each time. <strong>Default and recommended</strong> — most visually consistent.</p>
                        <p><span style="background:#10b981;color:white;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600;">CONTINUE</span> — Each clip starts from the <strong>last frame of the previous clip</strong>. Creates seamless flow — the subject's pose carries over naturally. Great for continuous monologues.</p>
                        <p><span style="background:#f59e0b;color:white;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600;">FRESH</span> — Each clip uses the original photo but with <strong>no interpolation/transitions</strong>. Completely standalone clips. Use for content you'll edit separately.</p>
                    </div>
                    
                    <div class="ob-step-desc" style="margin-top:14px;"><strong style="color:var(--text-primary);font-size:14px;">🔗 Scene Transitions</strong> <span style="font-size:12px;color:var(--text-muted);">(toggle between scenes)</span></div>
                    <div class="ob-step-desc">
                        <p><span style="color:#818CF8;font-weight:700;">🎬 BLEND TO</span> — The last clip of the previous scene <strong>smoothly morphs</strong> toward the next scene's image. Creates a cinematic flow between different subjects/settings.</p>
                        <p><span style="color:#EF4444;font-weight:700;">✂️ CUT TO</span> — <strong>Hard switch</strong> — no visual blending. The previous scene ends naturally, the next scene starts fresh from its own image. Use when scenes are very different.</p>
                    </div>
                    
                    <div class="ob-step-desc" style="margin-top:14px;"><strong style="color:var(--text-primary);font-size:14px;">✍️ Dialogue Script</strong></div>
                    <div class="ob-step-desc">
                        <p>Write natural speech inside each scene block. Auto-split divides text into clips within each scene. Write numbers as words, use contractions, keep it conversational.</p>
                    </div>
                    <div class="ob-tip"><strong>💡 Tip:</strong> Start with BLEND mode + BLEND TO transitions for the smoothest results. Use CUT TO when switching between very different people or locations.</div>
                    
                    <div class="ob-status waiting">
                        <span class="ob-spinner">⏳</span> Set up your scenes and write dialogue...
                    </div>
                `,
            },
            {
                id: 'generate',
                title: '🚀 Generate Video',
                check: () => selectedJobId != null,
                content: () => `
                    <div class="ob-step-num">4</div>
                    <div class="ob-step-title">Start Generation</div>
                    <div class="ob-step-desc">
                        <p>Everything is set up! Click the <strong>🚀 Start Generation</strong> button at the bottom of the settings panel.</p>
                        <p>The platform will:</p>
                    </div>
                    <ol class="ob-step-list">
                        <li>Validate your inputs (images, script, settings)</li>
                        <li>Upload frames to cloud storage</li>
                        <li>Generate AI prompts for each clip (if enabled)</li>
                        <li>Start processing clips — each takes about 1–3 minutes</li>
                    </ol>
                    <div class="ob-tip"><strong>💡 Tip:</strong> Clips process in parallel. A 10-clip job finishes much faster than 10× a single clip.</div>
                    <div class="ob-status waiting">
                        <span class="ob-spinner">⏳</span> Click "Start Generation" to begin...
                    </div>
                `,
            },
            {
                id: 'review',
                title: '✅ Review Clips',
                check: () => {
                    const cards = document.querySelectorAll('.clip-card.clip-approved');
                    return cards.length > 0;
                },
                content: () => `
                    <div class="ob-step-num">5</div>
                    <div class="ob-step-title">Review & Approve Your Clips</div>
                    <div class="ob-step-desc">
                        <p>Clips appear in the right panel as they complete. Watch each one and decide:</p>
                    </div>
                    <ol class="ob-step-list">
                        <li><strong>✓ Approve</strong> — Looks good! This clip will be included in the final video</li>
                        <li><strong>↻ Redo</strong> — Not great — regenerate a new version (up to 5 retries). Browse variants with ◀ ▶</li>
                        <li><strong>🗑 Delete</strong> — Remove this clip entirely</li>
                    </ol>
                    <div class="ob-tip"><strong>💡 Tip:</strong> Don't wait for all clips to finish. Approve good ones immediately, Redo bad ones — they process alongside the remaining clips.</div>
                    <div class="ob-status waiting">
                        <span class="ob-spinner">⏳</span> Approve at least one clip to continue...
                    </div>
                `,
            },
            {
                id: 'export',
                title: '📥 Export',
                check: () => false, // Always show this step when we're at this stage
                content: () => `
                    <div class="ob-step-num">6</div>
                    <div class="ob-step-title">Export Your Final Video</div>
                    <div class="ob-step-desc">
                        <p>Once you've approved all the clips you want, you have two export options:</p>
                    </div>
                    <ol class="ob-step-list">
                        <li><strong>📥 Download All</strong> — Each approved clip as a separate MP4 file. Great for editing in your own software.</li>
                        <li><strong>✂️ Export Final</strong> — Merges all approved clips into one continuous video. Opens a settings dialog with:
                            <br>• <strong>Frame trimming</strong> — Cut static frames from clip boundaries (default: 0 start, 7 end)
                            <br>• <strong>Smart Trim</strong> — Preserves first clip's opening and scene cuts
                            <br>• <strong>Audio enhancement</strong> — Remove laughter, DeepFilterNet noise removal, loudness normalization
                        </li>
                    </ol>
                    <div class="ob-step-desc" style="margin-top:12px;">
                        <p><strong>🎙️ Voice Swap</strong> (optional) — After exporting, replace the AI voice with a cloned real voice:</p>
                        <p><strong>OpenVoice v2</strong> — Upload a voice sample, low cost (~$0.01/run), adjustable similarity & pitch.</p>
                        <p><strong>ElevenLabs</strong> — Premium quality, requires API key + Voice ID, fine-grained controls.</p>
                    </div>
                    <div class="ob-tip"><strong>💡 Tip:</strong> Keep DeepFilterNet and Loudness Norm ON for the cleanest audio. Only use Voice Filter if the voice sounds muffled — it can sound robotic.</div>
                    <div class="ob-status done">
                        ✅ You've reached the final step! Export when ready. This guide will stay here if you need it.
                    </div>
                `,
            },
        ];
        
        // Helper: get the active step sequence based on current app state
        function obGetActiveSteps() {
            return OB_STEPS.filter(s => !s.condition || s.condition());
        }
        
        // Helper: find current step index in the active sequence
        function obGetCurrentIndex() {
            const steps = obGetActiveSteps();
            const idx = steps.findIndex(s => s.id === obCurrentStep);
            return idx >= 0 ? idx : 0;
        }
        
        function obGetDialogueLines() {
            // Try to use the global getDialogueLines if available
            if (typeof getDialogueLines === 'function') {
                try { return getDialogueLines(); } catch(e) {}
            }
            const ta = document.getElementById('dialogueInput');
            if (!ta) return [];
            return ta.value.split('\n').filter(l => l.trim());
        }
        
        // Render the current step
        function obRender() {
            const steps = obGetActiveSteps();
            const idx = obGetCurrentIndex();
            const step = steps[idx];
            if (!step) return;
            
            // Update header
            document.getElementById('obHeaderTitle').textContent = step.title;
            document.getElementById('obStepLabel').textContent = `Step ${idx + 1} of ${steps.length}`;
            
            // Update progress
            const pct = Math.round(((idx) / steps.length) * 100);
            document.getElementById('obProgressFill').style.width = pct + '%';
            
            // Update body
            document.getElementById('obBody').innerHTML = step.content();
            
            // Update nav buttons — always show back/next for manual browsing
            const nav = document.getElementById('obNav');
            const isFirst = idx === 0;
            const isLast = idx === steps.length - 1;
            
            nav.innerHTML = `
                ${!isFirst ? '<button class="btn btn-secondary" onclick="obGoBack()">← Back</button>' : '<div></div>'}
                ${!isLast ? '<button class="btn btn-secondary" onclick="obSkipStep()">Next →</button>' : '<div></div>'}
            `;
            
            // Save state
            obSaveState();
        }
        
        // Determine which step SHOULD be active based on current app state
        function obDetermineStep() {
            const steps = obGetActiveSteps();
            
            // Walk through steps and find the first incomplete one
            for (const s of steps) {
                if (!s.check()) return s.id;
            }
            
            // All steps complete — show the last step (export)
            return steps[steps.length - 1].id;
        }
        
        // Poll app state and auto-navigate to the right step
        let obLastDetermined = null;
        async function obPoll() {
            try {
                const shouldBe = obDetermineStep();
                
                // If the step changed, navigate to it
                if (shouldBe !== obLastDetermined) {
                    console.log('[Onboarding] Poll detected change:', obLastDetermined, '→', shouldBe);
                    obLastDetermined = shouldBe;
                    
                    const steps = obGetActiveSteps();
                    const currentIdx = steps.findIndex(s => s.id === obCurrentStep);
                    const targetIdx = steps.findIndex(s => s.id === shouldBe);
                    
                    if (targetIdx > currentIdx || currentIdx < 0) {
                        // Step completed — show brief success then advance
                        const statusEl = document.querySelector('#obBody .ob-status.waiting');
                        if (statusEl) {
                            statusEl.className = 'ob-status done';
                            statusEl.innerHTML = '✅ Done! Moving on...';
                            setTimeout(() => {
                                obCurrentStep = shouldBe;
                                obRender();
                            }, 800);
                        } else {
                            obCurrentStep = shouldBe;
                            obRender();
                        }
                    } else if (targetIdx < currentIdx) {
                        // User went backwards (e.g. deleted images) — follow them back
                        obCurrentStep = shouldBe;
                        obRender();
                    }
                }
                
                // Re-check if mode branch changed (auto-cycle ↔ storyboard)
                const steps = obGetActiveSteps();
                const currentInSteps = steps.findIndex(s => s.id === obCurrentStep);
                if (currentInSteps < 0) {
                    obCurrentStep = obDetermineStep();
                    obLastDetermined = obCurrentStep;
                    obRender();
                }
            } catch(e) {
                // Ignore poll errors — will retry
            }
            
            // Schedule next poll via setTimeout (avoids async overlap unlike setInterval)
            if (obPollTimer !== null) {
                obPollTimer = setTimeout(obPoll, 1500);
            }
        }
        
        function obGoBack() {
            const steps = obGetActiveSteps();
            const idx = obGetCurrentIndex();
            if (idx > 0) {
                obCurrentStep = steps[idx - 1].id;
                obRender();
            }
        }
        
        function obSkipStep() {
            const steps = obGetActiveSteps();
            const idx = obGetCurrentIndex();
            if (idx < steps.length - 1) {
                obCurrentStep = steps[idx + 1].id;
                obRender();
            }
        }
        
        function obMinimize() {
            const sidebar = document.getElementById('obSidebar');
            sidebar.classList.remove('open');
            document.body.classList.remove('onboarding-active');
            document.getElementById('obToggleTab').classList.add('visible');
            obSaveState();
        }
        
        function obReopen() {
            const sidebar = document.getElementById('obSidebar');
            sidebar.classList.add('open');
            document.body.classList.add('onboarding-active');
            document.getElementById('obToggleTab').classList.remove('visible');
            // Re-determine which step to show
            obCurrentStep = obDetermineStep();
            obRender();
            obSaveState();
        }
        
        function obDismiss() {
            const sidebar = document.getElementById('obSidebar');
            sidebar.classList.remove('open');
            document.body.classList.remove('onboarding-active');
            document.getElementById('obToggleTab').classList.remove('visible');
            if (obPollTimer !== null) { clearTimeout(obPollTimer); obPollTimer = null; }
            try { localStorage.setItem(OB_DISMISSED_KEY, 'true'); } catch(e) {}
        }
        
        function obSaveState() {
            try {
                localStorage.setItem(OB_STORAGE_KEY, JSON.stringify({
                    step: obCurrentStep,
                    minimized: !document.getElementById('obSidebar').classList.contains('open')
                }));
            } catch(e) {}
        }
        
        function obLoadState() {
            try {
                const raw = localStorage.getItem(OB_STORAGE_KEY);
                if (raw) return JSON.parse(raw);
            } catch(e) {}
            return null;
        }
        
        // Start the onboarding system
        async function obStart() {
            console.log('[Onboarding] obStart called. userApiKeys:', typeof userApiKeys, Array.isArray(userApiKeys) ? userApiKeys.length : 'N/A');
            // Check if dismissed
            try {
                if (localStorage.getItem(OB_DISMISSED_KEY) === 'true') {
                    console.log('[Onboarding] Dismissed, skipping');
                    return;
                }
            } catch(e) {}
            
            // Determine which step to show based on current app state
            obCurrentStep = obDetermineStep();
            console.log('[Onboarding] Determined step:', obCurrentStep);
            obLastDetermined = obCurrentStep;
            
            // Load saved minimized preference
            const saved = obLoadState();
            
            // Show sidebar (or minimized tab based on saved preference)
            if (saved && saved.minimized) {
                document.getElementById('obToggleTab').classList.add('visible');
            } else {
                document.getElementById('obSidebar').classList.add('open');
                document.body.classList.add('onboarding-active');
            }
            
            obRender();
            
            // Start polling via setTimeout chain (not setInterval — avoids async overlap)
            obPollTimer = setTimeout(obPoll, 1500);
        }
        
        // Hook into checkAuth — start onboarding after successful login
        function checkShowOnboarding() {
            setTimeout(() => {
                if (typeof obStart === 'function') obStart();
            }, 800);
        }
    </script>
</body>
</html>